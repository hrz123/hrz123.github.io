<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dijkstra&#39;s Shortest Path Algorithm|Dijkstra最短路径算法</title>
    <url>/2020/08/03/Dijkstra-s-Shortest-Path-Algorithm-Dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个图和图中的源顶点，找到从源到给定图中所有顶点的最短路径。</p>
<p>Dijkstra的算法与Prim的最小生成树算法非常相似。和Prim的MST一样，我们以给定的源为根，生成一个SPT（shortest path tree 最短路径树）。我们维护两个集合，一个集合包含最短路径树中包含的顶点，另一个集合包含尚未包含在最短路径树中的顶点。在算法的每一步，我们都会找到一个在另一个集合（尚未包含的集合）中的顶点，并且与源的距离最小。</p>
<p>下面是Dijkstra算法的详细步骤，用于寻找从单个源顶点到给定图中所有其他顶点的最短路径。</p>
<h2 id="算法">算法</h2>
<ol type="1">
<li>创建一个集合sptSet（最短路径树集合），用来跟踪最短路径树中包含的顶点，即这个集合中的点到源的最小距离已经被计算和确定下来。开始的时候，这个集合是空的。</li>
<li>给输出图中的所有顶点分配一个距离值。初始化所有距离值为INFINITE。为源顶点分配距离值为0，这样它就会被首先选中。</li>
<li>while sptSet不包含所有的顶点：
<ul>
<li>选取一个在sptSet中不存在的顶点u，并且它的距离值最小。</li>
<li>将u加入到sptSet中。</li>
<li>更新u的所有相邻顶点的距离值。要更新距离值，需要遍历所有相邻顶点。对于每一个相邻的顶点v，如果u的距离值（从源点）和边的权重之和小于v的距离值，那么更新v的距离值。</li>
</ul></li>
</ol>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python program for Dijkstra&#x27;s single</span></span><br><span class="line"><span class="comment"># source shortest path algorithm. The program is</span></span><br><span class="line"><span class="comment"># for adjacency matrix representation of the graph</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vertices</span>):</span></span><br><span class="line">        self.V = vertices</span><br><span class="line">        self.graph = [[<span class="number">0</span> <span class="keyword">for</span> column <span class="keyword">in</span> range(vertices)]</span><br><span class="line">                      <span class="keyword">for</span> row <span class="keyword">in</span> range(vertices)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printSolution</span>(<span class="params">self, dist</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Vertex tDistance from Source&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> range(self.V):</span><br><span class="line">            print(node, <span class="string">&quot;t&quot;</span>, dist[node])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># A utility function to find the vertex with</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># minimum distance value, from the set of vertices</span></span><br><span class="line">    <span class="comment"># not yet included in shortest path tree</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, dist, sptSet</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initilaize minimum distance for next node</span></span><br><span class="line">        min = float(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Search not nearest vertex not in the</span></span><br><span class="line">        <span class="comment"># shortest path tree</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(self.V):</span><br><span class="line">            <span class="keyword">if</span> dist[v] &lt; min <span class="keyword">and</span> sptSet[v] == <span class="literal">False</span>:</span><br><span class="line">                min = dist[v]</span><br><span class="line">                min_index = v</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_index</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Funtion that implements Dijkstra&#x27;s single source</span></span><br><span class="line">    <span class="comment"># shortest path algorithm for a graph represented</span></span><br><span class="line">    <span class="comment"># using adjacency matrix representation</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span>(<span class="params">self, src</span>):</span></span><br><span class="line"></span><br><span class="line">        dist = [float(<span class="string">&#x27;inf&#x27;</span>)] * self.V</span><br><span class="line">        dist[src] = <span class="number">0</span></span><br><span class="line">        sptSet = [<span class="literal">False</span>] * self.V</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cout <span class="keyword">in</span> range(self.V):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Pick the minimum distance vertex from</span></span><br><span class="line">            <span class="comment"># the set of vertices not yet processed.</span></span><br><span class="line">            <span class="comment"># u is always equal to src in first iteration</span></span><br><span class="line">            u = self.minDistance(dist, sptSet)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Put the minimum distance vertex in the</span></span><br><span class="line">            <span class="comment"># shotest path tree</span></span><br><span class="line">            sptSet[u] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Update dist value of the adjacent vertices</span></span><br><span class="line">            <span class="comment"># of the picked vertex only if the current</span></span><br><span class="line">            <span class="comment"># distance is greater than new distance and</span></span><br><span class="line">            <span class="comment"># the vertex in not in the shotest path tree</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> range(self.V):</span><br><span class="line">                <span class="keyword">if</span> self.graph[u][v] &gt; <span class="number">0</span> <span class="keyword">and</span> \</span><br><span class="line">                        sptSet[v] == <span class="literal">False</span> <span class="keyword">and</span> \</span><br><span class="line">                        dist[v] &gt; dist[u] + self.graph[u][v]:</span><br><span class="line">                    dist[v] = dist[u] + self.graph[u][v]</span><br><span class="line"></span><br><span class="line">        self.printSolution(dist)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Driver program</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This code is contributed by Divyanshu Mehta</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    g = Graph(<span class="number">9</span>)</span><br><span class="line">    g.graph = [</span><br><span class="line">        [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">8</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    g.dijkstra(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># Vertex tDistance from Source</span></span><br><span class="line"><span class="comment"># 0 t 0</span></span><br><span class="line"><span class="comment"># 1 t 4</span></span><br><span class="line"><span class="comment"># 2 t 12</span></span><br><span class="line"><span class="comment"># 3 t 19</span></span><br><span class="line"><span class="comment"># 4 t 21</span></span><br><span class="line"><span class="comment"># 5 t 11</span></span><br><span class="line"><span class="comment"># 6 t 9</span></span><br><span class="line"><span class="comment"># 7 t 8</span></span><br><span class="line"><span class="comment"># 8 t 14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>geeksForGeeks: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvcHl0aG9uLXByb2dyYW0tZm9yLWRpamtzdHJhcy1zaG9ydGVzdC1wYXRoLWFsZ29yaXRobS1ncmVlZHktYWxnby03Lw==">https://www.geeksforgeeks.org/python-program-for-dijkstras-shortest-path-algorithm-greedy-algo-7/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>GC的三种基本实现方式和优缺点</title>
    <url>/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h3 id="参考">参考：</h3>
<p>https://blog.csdn.net/longzw0/article/details/66970832</p>
<p>代码的未来–松本行弘</p>
<p>https://medium.com/<span class="citation" data-cites="NTulswani/understanding-and-implementing-a-garbage-collector-a19afb1bc418">@NTulswani/understanding-and-implementing-a-garbage-collector-a19afb1bc418</span>， 标记清除js代码简单实现</p>
<h3 id="将内存管理尤其是内存空间的释放实现自动化这就是gcgarbage-collection">将内存管理，尤其是内存空间的释放实现自动化，这就是GC（Garbage Collection）。</h3>
<p>GC是一个很古老的技术，从20世纪60年代就开始研究，还发表了不少论文。这项技术在大学实验室级别的地方已经应用了很长时间，但是可以说从20时间90年代Java出现之后，一般程序员才有缘解除到它，在此之前这项技术还只是少数人的专利。</p>
<h3 id="术语定义">术语定义</h3>
<h4 id="垃圾">1.垃圾</h4>
<p>所谓垃圾（Garbage），就是需要回收的对象。作为编写程序的人，是可以做出“这个对象已经不需要了”这样的判断，但是计算机是做不到的。因此如果程序（通过某个变量等等）可能会直接或间接的引用一个对象，那么这个对象就被视为<strong>“存活”；</strong>与之相反，已经引用不到的则被视为<strong>“死亡”</strong>。将这些死亡对象找出来，然后作为垃圾进行回收，这就是GC的本质。</p>
<h4 id="根">2.根</h4>
<p>所谓的根（Root），就是判断对象是否被引用的起始点。至于哪里的才是根，不同的语言和编译器都有不同的规定，但基本上是将变量和运行栈空间作为根。</p>
<h3 id="主要gc实现方式">主要GC实现方式</h3>
<h4 id="标记清除方式">1.标记清除方式</h4>
<p>标记清除（Mark and Sweep）是最早开发出来的GC算法（1960年）。它的原理非常简单：<strong>首先从根开始将可能被引用的对象用递归的方式进行标记，然后将没有标记到的对象作为垃圾进行回收。</strong></p>
<p>初始状态：</p>
<img data-src="/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/GC1.png" class>
<p>标记阶段：</p>
<img data-src="/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/GC2.png" class>
<img data-src="/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/GC3.png" class>
<p>清除阶段：</p>
<img data-src="/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/GC4.png" class>
<p>上述图片显示了标记清楚算法的大致原理。</p>
<p>”<strong>初始状态</strong>“图中显示了随着程序的运行而分配出一些对象的状态，一个对象可以对其他的对象进行引用。</p>
<p>”<strong>标记阶段</strong>“图中显示了GC开始执行，从根开始可以在被引用的对象上进行”标记“。大多数情况下，这种标记是通过对象内部的标志（Flag）来实现的。于是，被标记的对象我们将它涂黑。</p>
<p>紧接着<strong>被标记的对象所能引用的对象</strong>也会被打上标记。重复这一步骤就可以从根开始给可能被间接引用到的对象全部打上标记。到此为止的操作即被称为——<strong>标记阶段</strong>（Mark phase）。标记阶段完成时，<strong>被标记的对象就是”存活“对象，反之为”死亡“对象。</strong></p>
<p>标记清除算法的处理时间，是和存活对象数域对象总数的总和相关的。</p>
<p>作为标记清除的变形，还有一种叫做<strong>标记压缩</strong>（Mark and Compat）的算法，它不是将被标记的对象清除，而是将它们不断压缩。</p>
<h4 id="复制收集方式">2.复制收集方式</h4>
<p>标记清除算法有一个缺点，就是在分配了大量对象，并且其中只有一小部分存活的情况下，所消耗的时间会大大超过必要的值，这是因为在清除阶段还需要对大量死亡对象进行扫描。</p>
<p><strong>复制收集</strong>（Copy and Collection）则试图克服这一缺点。在这种算法中，<strong>会将从根开始被引用的对象复制到另外的空间中，然后，在将复制的对象所能够引用的对象用递归的方式不断复制下去</strong>。</p>
<p>初始状态（1）——旧空间：</p>
<img data-src="/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/GC5.png" class>
<p>新空间的开辟（2）——新空间：</p>
<img data-src="/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/GC6.png" class>
<p>复制对象（3）</p>
<img data-src="/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/GC7.png" class>
<p>如上图：</p>
<p>（1）部分是GC开始前的内存状态，这也同时代表着对象在内存中所占用的”旧空间“。</p>
<p>（2）在旧空间以外开辟”新空间“并将可能从根被引用的对象复制到新空间中。</p>
<p>（3）从已经复制的对象开始再将可以被引用的对象逐个复制到新空间当中……随着复制的进行，直到复制完成——最终”死亡“对象就留在了”旧空间”当中，接着将旧空间废弃掉，这样就可以将“死亡”对象是哟占用的空间一口气释放出来，而没有必要再次扫描“死亡”对象了。等到下次GC操作时，这次所创建的“新空间”就成为了将来的“旧空间”了。</p>
<p><strong>复制收集方式</strong>的过程相当于只存在<strong>标记清除方式</strong>中的<strong>标记阶段</strong>。<strong>由于清除阶段中需要对所有对象进行扫描，这样如果存在大量对象，且其中大量对象已经为“死亡”对象的情况下必然会造成不必要的资源和性能上的开销</strong>。</p>
<p>而在复制收集方式中就不存在这样的开销。<strong>但是和标记相比，将对象复制一份的开销相对要大，因此在“存活”对象相对比例较高的请情况下，反而不利。</strong></p>
<p>复制收集方式的另一个优点是：它具有局部性（Locality）。在复制收集的过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放置在距离较近的内存空间中的可能性会提高，这样被称为局部性。局部性高的情况下，内存缓存会更容易有效运作，程序的运行也能够得到提高。</p>
<h3 id="引用计数方式">引用计数方式</h3>
<p>引用计数方式是GC算法中最简单也最容易实现的一种，它和标记清除方式差不多是同一个时间被发明出来的。</p>
<p>它的原理是：<strong>在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。</strong></p>
<p>引用计数的增减，一般发生在变量复制，对象内容更新，函数结束（局部变量不再被引用）等时间点。当一个对象的引用计数为0时，则说明它将来不会再被引用，因此可以释放相应的内存空间。</p>
<p>（1）</p>
<img data-src="/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/GC8.png" class>
<p>（2）</p>
<img data-src="/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/GC9.png" class>
<p>（3）</p>
<img data-src="/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/GC10.png" class>
<p>如上图：</p>
<p>（1）中所有对象都保存着自己被多少个对象进行引用的数量（引用计数）——图中右上角的数字。</p>
<p>（2）当对象引用发生变化时，引用计数也会跟着变化。在这里图中的对象B到D的引用失效后，对象D的引用计数变为0，由于对象D的引用计数变为0，因此D到E和C的引用计数也分别减少。结果E的引用计数也变为0，于是对象E也会被释放。</p>
<p>（3）引用计数为0的对象被释放——“存活”的对象被保留下来。而这个GC过程中不需要对所有对象进行扫描。</p>
<h4 id="优点">优点：</h4>
<ul>
<li>相比标记清除和复制收集方式实现更容易。</li>
<li>当对象不再被引用的瞬间就会被释放。</li>
<li>其他GC机制中，要预测一个对象何时会被释放是很困难的，而在引用计数方式中则是立即被释放。</li>
<li>由于释放操作是针对个别执行的，因此和其他算法相比，由GC而产生的中断时间比较短。</li>
</ul>
<h4 id="缺点">缺点：</h4>
<img data-src="/2020/07/26/GC%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/GC11.png" class>
<ul>
<li>无法释放循环引用的对象。如上图A，B，C三个对象没有被其他对象引用，而是互相之间循环引用，因此它们的引用计数永远不会为0，结果这些对象就永远不会被释放。</li>
<li>必须在引用发生增减时对引用计数做出正确的增减，而如果漏掉或者更改了引用计数就会引发很难找到的错误。</li>
<li>引用计数不适合并行处理。如果多个线程同时对引用计数进行增减的话，引用计数的值就可能会产生不一致的问题（结果就会导致内存错误），为了避免这样的事情发生，对引用计数的操作必须采用独占的方式来进行。如果引用计数操作频繁进行，每次使用都要使用加锁等并发操作，其开销也不可小觑。</li>
</ul>
<p>实际的GC实现会涉及很多优化。</p>
]]></content>
      <tags>
        <tag>高级编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>K个一组翻转链表</title>
    <url>/2020/07/20/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>思路， 首先一个哨兵结点可以帮我们省去判断边界的代码，建立哨兵，并且令dummy.next = head</p>
<p>将pre指向开头</p>
<p>循环开始，只要head不为nil</p>
<p>令tail = pre</p>
<p>tail往下走k步，只要tail为nil，立即返回dummy.next</p>
<p>nxt记录下tail.next，head即将走向的下一个结点</p>
<p>反转head到tail中的节点，返回新的head和tail</p>
<p>def reverse(head, tail):</p>
<p>​ 反转代码，令pre指向tail.next，cur指向head</p>
<p>​ while prev != tail:</p>
<p>​ nxt = cur.next</p>
<p>​ cur.next = prev</p>
<p>​ prev = cur</p>
<p>​ cur = nxt</p>
<p>​ return tail, head</p>
<p>将pre的next指向新的head</p>
<p>pre.next = head</p>
<p>尾部已相连</p>
<p>更新pre指向tail</p>
<p>head指向nxt</p>
<p>最终head为nil时退出循环</p>
<p>返回dummy.next</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: ListNode, k: int</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        pre = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail = pre</span><br><span class="line">            <span class="comment"># 查看剩余部分长度是否大于k</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">                tail = tail.next</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                    <span class="keyword">return</span> dummy.next</span><br><span class="line">            nxt = tail.next</span><br><span class="line">            head, tail = self.reverse(head, tail)</span><br><span class="line">            <span class="comment"># 把子链表重新串联起来</span></span><br><span class="line">            pre.next = head</span><br><span class="line">            pre = tail</span><br><span class="line">            head = nxt</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, head, tail</span>):</span></span><br><span class="line">        prev = tail.next</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> prev != tail:</span><br><span class="line">            cur.next, cur, prev = prev, cur.next, cur</span><br><span class="line">        <span class="keyword">return</span> tail, head</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的锁</title>
    <url>/2020/08/22/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<h2 id="全局锁表锁行锁间隙锁">全局锁、表锁、行锁、间隙锁。</h2>
<p>间隙锁为了解决幻读，比较不同。</p>
<p>比如行锁，分成读锁和写锁。下图就是这两种类型行锁的冲突关系。</p>
<img data-src="/2020/08/22/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/MySQL%E4%B8%AD%E7%9A%84%E9%94%81.png" class>
<p>也就是说，跟行锁有冲突关系的是“另外一个行锁”。</p>
<p>但是间隙锁不一样，<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作</strong>。间隙锁之间都不存在冲突关系。</p>
<p>这句话不太好理解，举个例子：</p>
<img data-src="/2020/08/22/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/%E9%94%812.png" class>
<p>这里session B并不会被堵住，因为表t里并没有c=7这个记录，因此session A加的是间隙锁（5，10）。而session B也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但，它们之间不是冲突的。</p>
<p>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p>
<blockquote>
<p>备注：这篇文章中，如果没有特别说明，我们把间隙锁记为开区间，把 next-key lock 记为前开后闭区间。</p>
</blockquote>
<p>你可能会问说，这个 supremum 从哪儿来的呢？</p>
<p>这是因为 +∞是开区间。实现上，InnoDB 给每个索引加了一个不存在的最大值 supremum，这样才符合我们前面说的“都是前开后闭区间”。</p>
<p><strong>间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”。</strong></p>
<p>在前面的文章中，就用同学提到了这个问题。我把他的问题转述一下，对应到我们这个例子的表来说，业务逻辑是这样额：任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where id&#x3D;N for update;</span><br><span class="line"></span><br><span class="line">&#x2F;*如果行不存在*&#x2F;</span><br><span class="line">insert into t values(N,N,N);</span><br><span class="line">&#x2F;*如果行存在*&#x2F;</span><br><span class="line">update t set d&#x3D;N set id&#x3D;N;</span><br><span class="line"></span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<p>可能你会说，这个不是insert .. on duplicate key update 就能解决吗？但其实在有多个唯一键的时候，这个方法是不能满足这位提问同学的需求的。至于为什么，我会在后面的文章中再展开说明。</p>
<p>现在，我们就只讨论这个逻辑。</p>
<p>这个同学碰到的现象是，这个逻辑一旦有并发，就会碰到死锁。你一定也觉得奇怪，这个逻辑每次操作前用 for update 锁起来，已经是最严格的模式了，怎么还会有死锁呢？</p>
<p>这里，我用两个 session 来模拟并发，并假设 N=9。</p>
<img data-src="/2020/08/22/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/%E9%94%813.png" class>
<p>你看到了，其实都不需要用到后面的update语句，就已经形成死锁了。我们按语句执行顺序来分析一下：</p>
<ol type="1">
<li>session A执行select ... for update 语句，由于id=9这一行并不存在，因此会加上间隙锁（5，10；</li>
<li>session B执行select ... for update 语句，同样会加上间隙锁（5，10），间隙锁之间不会冲突，因此这个语句可以执行成功；</li>
<li>session B试图插入一行（9，9，9），被session A的间隙锁挡住了，只好进入等待；</li>
<li>session A试图插入一行（9，9，9），被session B的间隙锁挡住了。</li>
</ol>
<p>至此，两个session进入互相等待的状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句返回了。</p>
<p>你现在知道了，<strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的</strong>。其实，这还只是一个简单的例子，在下一篇文章中我们还会碰到更多、更复杂的例子。</p>
<p>你可能会说，为了解决幻读的问题，我们引入了这么一大串内容，有没有更简单一点的处理方法呢。</p>
<p>今天和你分析的问题都是在可重复读隔离级别下的，间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。这，也是现在不少公司使用的配置组合。</p>
<p>比如说，大家都用读提交，可是逻辑备份的时候，mysqldump 为什么要把备份线程设置成可重复读呢？（这个我在前面的文章中已经解释过了，你可以再回顾下第 6 篇文章《全局锁和表锁 ：给表加个字段怎么有这么多阻碍？》的内容）</p>
<p>然后，在备份期间，备份线程用的是可重复读，而业务线程用的是读提交。同时存在两种事务隔离级别，会不会有问题？</p>
<p>进一步地，这两个不同的隔离级别现象有什么不一样的，关于我们的业务，“用读提交就够了”这个结论是怎么得到的？</p>
<h2 id="加锁规则的经验总结">加锁规则的经验总结</h2>
<p>首先说明一下，这些加锁规则我没在别的地方看到过有类似的总结，以前我自己判断的时候都是想着代码里面的实现来脑补的。这次为了总结成不看代码的同学也能理解的规则，是我又重新刷了代码临时总结出来的。所以，这个规则有以下两条前提说明：</p>
<ol type="1">
<li>MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列 &lt;=5.7.24，8.0 系列 &lt;=8.0.13。</li>
<li>如果大家在验证中有发现 bad case 的话，请提出来，我会再补充进这篇文章，使得一起学习本专栏的所有同学都能受益。</li>
</ol>
<p>因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认是可重复读隔离级别。</p>
<p><strong>我总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</strong></p>
<ol type="1">
<li>原则 1：加锁的基本单位是 next-key lock。 next-key lock 是前开后闭区间。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<h2 id="参考">参考</h2>
<p>感谢丁奇老师的专栏，摘录部分，如有不妥，请通知我立即删除。https://time.geekbang.org/column/article/75659</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务隔离</title>
    <url>/2020/08/20/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="事务">事务</h2>
<p>和数据库打交道的时候，我们总是会用到事务，最经典的例子就是转账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。</p>
<p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到”事务“这个概念了。</p>
<p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</p>
<h2 id="隔离性与隔离级别">隔离性与隔离级别</h2>
<p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是”隔离性“。下面是ACID的简单定义。</p>
<ol type="1">
<li><p>原子性</p>
<p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p></li>
<li><p>一致性</p>
<p>数据库在事务执行前后都保持一致性的状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p></li>
<li><p>隔离性</p>
<p>一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p></li>
<li><p>持久性</p>
<p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p></li>
</ol>
<p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复度（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了”隔离级别“的概念。</p>
<p>在谈隔离级别之前，你首先要知道，你隔离的越严实，效率就会越低。因此很多时候，我们都要在二者之间巡展一个平衡点。SQL标准的事务隔离级别：读未提交（read uncommitted）、读提交（read committed）、可重复度（repeatable read）和串行化（serializable）。下面我逐一解释：</p>
<ul>
<li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复度隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化，顾名思义是对于同一行记录，”写“会加”写锁“，读会加”读锁“。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p>其中”读提交“和”可重复读“比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<img data-src="/2020/08/20/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB1.png" class>
<p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。</p>
<ul>
<li>若隔离级别是”读未提交“，则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</li>
<li>若隔离级别是”读提交“，则V1是1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</li>
<li>若隔离级别是”可重复读“，则V1、V2是1，V3是2、之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li>
<li>若隔离级别是”串行化“，则在事务B执行”将1改成2“的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看，V1、V2值是1，V3的值是2。</li>
</ul>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在”可重复读“隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在”读提交“隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，”读未提交“隔离级别下直接返回记录上的最新值，没有视图概念；而”串行化“隔离级别下直接用加锁的方式来避免并行访问。</p>
<p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是”读提交“，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，一定要记得将MySQL的给级别设置为”读提交“。</p>
<p>配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以使用show variables</p>
<p>来查看当前的值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show variables like <span class="string">&#x27;transaction_isolation&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>总结来说，存在即合理，每种隔离级别都有自己的使用场景，你要根据自己的业务情况来定。我想<strong>你可能会问那什么时候需要”可重复读“的场景呢</strong>？我们来看一个数据校对逻辑的案例。</p>
<p>假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p>
<p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p>
<h2 id="事务隔离的实现">事务隔离的实现</h2>
<p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p>
<p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作（前者记录在redo log，后者记录在undo log）。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
<p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<img data-src="/2020/08/20/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB2.png" class>
<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p>
<p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p>
<p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p>
<p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p>
<p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。</p>
<p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p>
<h2 id="事务的启动方式">事务的启动方式</h2>
<p>如上面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p>
<ol type="1">
<li>显式启动事务语句，begin或start transaction。配套的提交语句是commit，回滚语句是rollback。</li>
<li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且不不会自动提交。这个事务持续存在知道你主动执行commit或rollback语句，或者断开连接。</li>
</ol>
<p>有些客户端连接框架会默认连接成功后先执行一个et autocommit=0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p>
<p>因此，我会交易你总是使用set autocommit=1，通过显式语句的方式来启动事务。</p>
<p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二中凡是每个事务在开始时都不需要主动执行一次“begin”，减少额语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。</p>
<p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行commit work and chaini，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>
<p>你可以在information_schema库中的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>这篇文章，主要介绍了MySQL的事务隔离级别的现象和实现，根据实现原理分析了长事务存在的风险，以及如何用正确的方式避免长事务，希望举的例子能够帮助你理解事务，并更好的使用MySQL的事务特性。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL如何正确地显示随机消息？ </title>
    <url>/2020/08/28/MySQL%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%98%BE%E7%A4%BA%E9%9A%8F%E6%9C%BA%E6%B6%88%E6%81%AF%EF%BC%9F/</url>
    <content><![CDATA[<p>先说结论</p>
<p>如果你直接使用order by rand()，这个语句需要Using temporary和Using filesort，查询的执行代价往往是比较大的。所以，在设计的时候你要尽量避开这种写法。</p>
<p><strong>在实际应用的过程中，比较规范的用法是：尽量将业务逻辑写在业务代码中，让数据库只做”读写数据“的事情。</strong></p>
<h3 id="正确的方法">正确的方法</h3>
<p>下面这个流程：</p>
<ol type="1">
<li>取得整个表的行数，并记为C。</li>
<li>取得Y = floor(C * rand())。floor函数在这里的作用，就是取整数部分。</li>
<li>再用limit Y，1 取得一行。</li>
</ol>
<p>下面这段代码，就是上面流程的执行语句的序列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select count(*) into @C from t;</span><br><span class="line"><span class="keyword">set</span> @Y = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">sql</span> = <span class="keyword">concat</span>(<span class="string">&quot;select * from t limit &quot;</span>, @Y, <span class="string">&quot;,1&quot;</span>);</span><br><span class="line"><span class="keyword">prepare</span> stmt <span class="keyword">from</span> @<span class="keyword">sql</span>;</span><br><span class="line"><span class="keyword">execute</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br></pre></td></tr></table></figure>
<p>由于limit后面的参数不能直接跟变量，所以在上面的代码中使用prepare+execute的方法。你也可以把拼接SQL语句的方法写在应用程序中，会更简单些（其实我觉得也更规范，业务逻辑写在业务代码中）。</p>
<p>MySQL处理limit Y, 1的做法就是按顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为返回结果，因此这一步需要扫描Y+1行。再加上，第一步扫面的C行，总共需要扫描C+Y+1行。</p>
<p>跟直接order by rand()比起来，执行代价还是小很多的。</p>
<p>如果按照这种思路，随机取3个word的值呢？可以这么做：</p>
<ol type="1">
<li>取得整个表的行数，即为C</li>
<li>按照相同的随机方法得到Y1、Y2、Y3</li>
<li>再执行三个limit Y, 1语句得到三行数据。</li>
<li>可以优化成，假设Y1，Y2，Y3是由小到大的三个数，则可以优化成这样，这样扫描行数为Y3 id1 = select * from t limit <span class="citation" data-cites="Y1">@Y1</span>，1； id2= select * from t where id &gt; id1 limit <span class="citation" data-cites="Y2">@Y2</span><span class="citation" data-cites="Y1">@Y1</span>，1； select * from t where id &gt; id2 limit <span class="citation" data-cites="Y3">@Y3</span> - <span class="citation" data-cites="Y2">@Y2</span>，1；</li>
</ol>
<h3 id="参考">参考</h3>
<p>丁奇老师的<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83Mzc5NQ==">MySQL实战45讲<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL自增主键为什么不是连续的？</title>
    <url>/2020/08/28/MySQL%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<p>为了便于说明，我们创建一个表t，其中id是自增主键字段、c是唯一索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<h3 id="自增值修改机制">自增值修改机制</h3>
<p>在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p>
<ol type="1">
<li>如果插入数据时id字段指定为0、null或未指定值，那么就把这个表当前的AUTO_INCREMENT值填到自增字段；</li>
<li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。</li>
</ol>
<p>根据要插入的值和当前值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是X，当前的自增值是Y。</p>
<ol type="1">
<li>如果X&lt;Y，那么这个表的自增值不变；</li>
<li>如果X&gt;=Y，就需要把当前自增值修改为新的自增值。</li>
</ol>
<p><strong>新的自增值生成算法是</strong>：从auto_increment_offset开始，以auto_increment_increment为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。</p>
<p>其中，auto_increment_offset和auto_increment_increment是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。</p>
<blockquote>
<p>备注：在一些场景下，使用的就不全是默认值。比如，双M的主备结构里要求双写的时候，我们就可能会设置成auto_increment_increment=2，让一个库的自增id都是奇数，另一个库的自增id都是偶数，避免两个库生成的主键发生冲突。</p>
</blockquote>
<p>当auto_increment_offset和auto_increment_increment都是1的时候，新的自增值生成逻辑很简单，就是：</p>
<ol type="1">
<li>如果准备插入的值&gt;=当前自增值，新的自增值就是”准备插入的值+1“；</li>
<li>否则，自增值不变。</li>
</ol>
<p>这就引入了我们文章开头提到的问题，在这两个参数都设置为1的时候，自增主键id却不能保证是连续的，这是什么原因呢？</p>
<h3 id="自增值的修改时机">自增值的修改时机</h3>
<p>要回答这个问题，我们就要看一下自增值的修改时机。</p>
<p>假设，表t里面已经有了（1，1，1）这条记录，这时我再执行一条插入数据命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>这个语句的执行InnoDB引擎接口写入一行，传入的这一行的值是（0， 1， 1）；</li>
<li>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；</li>
<li>将传入的行的值改成（2，1，1）；</li>
<li>将表的自增值改成3；</li>
<li>继续执行插入数据操作，由于已经存在c=1的记录，所以报Duplicate key error，语句返回。</li>
</ol>
<p>对应的执行流程图如下：</p>
<img data-src="/2020/08/28/MySQL%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%9F/%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE1.jpg" class>
<p>可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键c冲突，所以id这一行并没有插入成功，但也没有将自增值再改回去。</p>
<p>所以，在这之后，再插入新的数据行时，拿到的自增id就是3。也就是说，出现了自增主键不连续的情况。</p>
<p>如下图所示就是完整的演示结果。</p>
<img data-src="/2020/08/28/MySQL%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%9F/%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE2.png" class>
<p>可以看到，这个操作序列复现了一个自增主键id不连续的现场（没有id=2的行）。可见，<strong>唯一键冲突是导致自增主键id不连续的第一种原因。</strong></p>
<p>同样地，<strong>事务回滚也会产生类似的现象，这就是第二种原因。</strong></p>
<p>下面这个语句序列就可以构造不连续的自增id，你可以自己验证一下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">// 插入的行是(3, 2, 2)</span><br></pre></td></tr></table></figure>
<p>你可能会问，为什么在出现唯一键冲突或者回滚的时候，MySQL没有把表t的自增值改回去呢？如果把表t的当前自增值从3改回2，再插入新数据的时候，不就可以生成id=2的一行数据了吗？</p>
<p>其实，MySQL这么设计是为了提升性能。接下来，我就跟你分析一下这个设计思路，看看<strong>自增值为什么不能回退。</strong></p>
<p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。</p>
<ol type="1">
<li>假设事务A申请到了id=2，事务B申请到Id=3，那么这时候表t的自增值是4，之后继续执行。</li>
<li>事务B正确提交了，但事务A出现了唯一键冲突.</li>
<li>如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情况：表里面已经有id=3的行，而当前的自增id值是2。</li>
<li>接下来，继续执行的其他事务就会申请到id=2，然后再申请到id=3。这是，就会出现插入语句报错”主键冲突“。</li>
</ol>
<p>而为了解决这个主键冲突，有两种方法：</p>
<ol type="1">
<li>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在。</li>
<li>把自增id的缩范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li>
</ol>
<p>可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个”允许自增id回退“的前提导致的。</p>
<p>因此，InnoDB放弃了这个设计，语句执行失败也不回退自增id。也正是因为这样，所以才只保证了自增id是递增的，但不保证是连续的。</p>
<h3 id="自增锁的优化">自增锁的优化</h3>
<p>可以看到，自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在MySQL5.1版本之前，并不是这样的.</p>
<p>接下来，我会先给你介绍下自增锁设计的历史，这样有助于你分析接下来的一个问题。</p>
<p>在MySQL5.0版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。</p>
<p>MySQL 5.1.22版本引入了一个新的策略，新增参数innodb_autoinc_lock_mode，默认值是1。</p>
<ol type="1">
<li>这个参数的值被设置成0时，表示采用之前MySQL 5.0版本的策略，即语句执行结束后才释放锁；</li>
<li>这个参数的值被设置为1时：
<ul>
<li>普通insert语句，自增锁在申请之后就马上释放；</li>
<li>类似insert...select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
</ul></li>
<li>这个参数值被设置为2的时候，所有申请自增主键的动作都是申请后就释放锁。</li>
</ol>
<p>你一定有两个疑问：<strong>为什么默认设置下，insert...select要使用语句级的锁？为什么这个参数的默认值不是2？</strong></p>
<p>答案是，这么设计还是为了数据的一致性。</p>
<p>我们一起来看一下这个场景：</p>
<img data-src="/2020/08/28/MySQL%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%9F/%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE3.png" class>
<p>在这个例子里，我往表t1中插入了4行数据，然后创建了一个相同结构的表t2，然后两个session同时执行向表t2中插入数据的操作。</p>
<p>你可以设想一下，如果session B是申请了自增值以后马上就释放自增锁，那么就可能出现这样的情况：</p>
<ul>
<li>session B先插入了亮条记录，（1，1，1）、（2，2，2）；</li>
<li>然后，session A来申请自增id得到id=3，插入了（3，5，5）；</li>
<li>之后，session B继续执行，插入两条记录（4，3，3）、（5，4，4）。</li>
</ul>
<p>你可能会说，这也没关系吧，毕竟session B的语义本身就没有要求表t2的所有行的数据都跟session A相同。</p>
<p>是的，从数据逻辑上看是对的。但是，如果我们现在的binlog_format=statement，你可以设想下，binlog会怎么记录呢？</p>
<p>由于两个session是同时执行插入数据命令的，所以binlog里面对表t2的更新日志只有两种情况：要么先记session A的，要么先记session B的。</p>
<p>但不论是哪一种，这个binlog拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的。这是，这个库就发生了数据不一致。</p>
<p>你可以分析一下，出现这个问题的原因是什么？</p>
<p>其实，这是因为原库session B的insert语句，生成的id不连续。这个不连续的id，用statement格式的binlog来串行执行，是执行不出来的。</p>
<p>而要解决这个问题，有两种思路：</p>
<ol type="1">
<li>一种思路是，让原库的批量插入数据语句，固定生成连续的id值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。</li>
<li>另一种思路是，在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是innodb_autoinc_lock_mode设置为2，同时binlog_format设置为row。</li>
</ol>
<p>因此，<strong>生产上，尤其是有insert...select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode=2，并且binlog_format=row。</strong>这样做，既能提升并发性，又不会出现数据一致性问题。</p>
<p>需要注意的是，我这里说的<strong>批量插入数据，包含的语句类型是insert...select、replace...select和load data语句</strong>。</p>
<p>但是，普通的insert语句里面包含多个value值的情况下，即使innodb_autoinc_lock_mode设置为1，也不会等语句执行完才释放锁。因为这类语句在申请自增id的时候，是可以精确计算出需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。</p>
<p>也就是所，批量插入数据的语句，之所以需要这么设置，是因为”不知道要预先申请多少个id“。</p>
<p>既然预先不知道要申请多少个自增id，那么一种直接的想法就是需要一个时申请一个。但如果一个select..insert语句要插入10万行数据，按照这个逻辑的话就要申请10万次。显然，这种申请自增id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。</p>
<p><strong>因此，对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：</strong></p>
<ol type="1">
<li>语句执行过程汇总，第一次申请自增id，会分配1个；</li>
<li>1个用完以后，这个语句第二次申请自增id，会分配2个；</li>
<li>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；</li>
<li>依次类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。</li>
</ol>
<p>举个例子，我们一起看看下面的这个语句序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c, d) <span class="keyword">select</span> c, d <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> ionto t2 <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>insert...select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一次申请到了id=1，第二次被分配了id=2和id=3，第三次被分配到id=4到id=7。</p>
<p>由于这条语句实际上只用上了4个id，所以id=5到id=7就被浪费掉了。之后，再执行insert into t2 values(null,5， 5），实际上插入的数据就是（8，5，5）。</p>
<p><strong>这是主键id出现自增id不连续的第三种原因。</strong></p>
<h3 id="小结">小结</h3>
<p>今天，我们从”自增主键为什么会出现不连续的值”这个问题开始，首先讨论了自增值的存储。</p>
<p>在MyISAM引擎里面，自增值是被写在数据文件上面的。而在InnoDB中，自增值是被记录在内存的。MySQL直到8.0版本，才给InnoDB表的自增值加上了持久化的能力，确保重启后一个表的自增值不变。（将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值。）</p>
<p>然后，我和你分享了在一个语句执行过程中，自增值改变的实际，分析了为什么MySQL在事务回滚的时候不能回收自增id。</p>
<p>MySQL 5.1.22版本开始引入的参数innodb_autoinc_lock_mode，控制了自增值申请时的锁范围。从并发性能的角度考虑，我建议你将其设置为2，同时将binlog_format设置为row。我在前面的文章中多次提到，binlog_format设置为row，是很有必要的。今天的例子给这个结论多了一个理由。</p>
<p>最后，我给你留一个思考题吧。</p>
<p>在最后一个例子中，执行insert into t2(c, d) select c,d from t；这个语句的时候，如果隔离级别是可重复读（RR, repeatable read)，binlog_format=statement。这个语句会对表t的所有记录和间隙加锁。</p>
<p>你觉得为什么需要这么做呢?</p>
<p>我的回答：</p>
<p>如果不加记录和间隙锁，而binlog_format又是statement。那么此时如果有另一个事务对t有写操作，比如insert into t values(x, x, x)，这时由于事务的隔离级别是可重复读，t2是看不到新增的数据的。而我们的binlog记录时如果将insert into t2(c, d) select c,d from t；记在了刚才那个语句的后面。那么在备库使用binlog同步的时候，备库会基于binlog恢复临时库，t2会看到新增的数据，就会造成主备数据的不一致。</p>
<h3 id="参考">参考</h3>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS84MDUzMQ==">MySQL实战45讲<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Nobody exists on purpose</title>
    <url>/2019/12/11/Nobody-exists-on-purpose/</url>
    <content><![CDATA[<p>Nobody exists on purpose.</p>
<p>Nobody belongs anywhere.</p>
<p>Everybody's gonna die.</p>
<p>Come watch TV.</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Prim&#39;s最小生成树算法</title>
    <url>/2020/08/21/Prim-s%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Prim算法是一种Greedy算法。它从一个空的生成树开始。其想法是维护两组顶点。第一组包含已经在MST中的顶点，另一组包含尚未在的顶点。在每一步，它都会考虑连接两组的所有边，并从这些边中挑选出最小权重的边。选取边后，它将边的另一个顶点移动到包含MST的集合中。</p>
<p>在图论中，连接两组顶点的一组边被称为切边（cut）。所有，在Prim算法的每一步，我们都要要找到一个cut（关于这两个集合的，一个包含已经在MST中的顶点，另一个包含其余的顶点），从cut中挑选出最小权重的边，并将这个顶点包含到MST集合（包含已经在MST中的顶点）中。</p>
<p><strong>Prim's Algorithm是如何工作的？</strong>Prim算法背后的思想很简单，一颗生成树意味着所有顶点必须是连接的。所以，两个不相干的顶点子集（上面讨论的）必须连接起来，才能组成一个生成树。而且它们必须用最小的权重边连接起来，才能使之成为一颗最小生成树。</p>
<p><strong>算法：</strong></p>
<ol type="1">
<li>创建一个集合mstSet，用来跟踪已经包含在MST中的顶点。</li>
<li>给输入图中的所有顶点分配一个键值。初始化所有的键值为infinity。为第一个顶点分配键值为0，这样它就会被首先选中。</li>
<li>while mstSet不包含所有的顶点
<ol type="1">
<li>选取一个在mstSet中没有的顶点u，并且其键值最小。</li>
<li>将u加入到mstSet中。</li>
<li>更新u的所有相邻顶点的键值，更新键值时，要遍历所有相邻顶点。对于每一个相邻顶点v，如果边u-v的权重小于v的前一个键值，则更新键值为u-v的权重。</li>
</ol></li>
</ol>
<p>使用键值的想法是为了从cut中挑选出最小权重的边。键值只用于尚未包含在MST中的顶点，这些顶点的键值表示连接它们与MST中包含的顶点集的最小权重边的权重。</p>
<img data-src="/2020/08/21/Prim-s%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/Prim1.jpg" class>
<p>集合mstSet开始的时候是空的，并且每个顶点键值时{0, INF, INF, INF, INF, INF, INF, INF}，INF表示无穷大。现在，选出一个拥有最小键值的顶点。顶点0被选出，将其放入mstSet。所以mstSet成为了{0}。在包括进mstSet之后，更新相邻顶点的键值。0的相邻顶点是1和7。1和7的键值被更新为4和8。下面的子图显示了顶点和它们的键值，只有有有限键值的顶点展示了出来。在MST中的顶点用绿颜色表示了出来。</p>
<img data-src="/2020/08/21/Prim-s%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/Prim2.jpg" class>
<p>选出有最小键值的顶点并且还没有被包括进MST（还不在mstSet）。顶点1被选出来，并且被加入mstSet。所以mstSet成为了{0, 1}。更新1的相邻顶点的键值。顶点2的键值变成了8。</p>
<img data-src="/2020/08/21/Prim-s%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/Prim3.jpg" class>
<p>选出具有最小键值的顶点，并且还没有包含在MST中（不在mstSet中）。我们可以选择顶点7或者2，我们让7被选中。所以mstSet现在变成了{0, 1, 7}。更新7的相邻顶点的键值，顶点6和8的键值变成了有限的（分别为1和7）。</p>
<img data-src="/2020/08/21/Prim-s%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/Prim4.jpg" class>
<p>选出具有最小键值的顶点，并且还没有包含在MST中（不在mstSet中）。顶点6被选中。所以mstSet现在为{0, 1, 7, 6}。更新6的相邻顶点的键值。5和8的键值被更新。</p>
<img data-src="/2020/08/21/Prim-s%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/Prim5.jpg" class>
<p>我们重复上面的步骤直到mstSet包含了给定图中所有的顶点。最终，我们得到了如下的图。</p>
<img data-src="/2020/08/21/Prim-s%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/Prim6.jpg" class>
<p><strong>如何实现上面的算法？</strong></p>
<p>我们用一个布尔数组mstSet[]表示MST中包含的顶点集合。如果一个值mstSet[v]为true，那么顶点v就在MST中，否则就不是。数组key[]用来存储所有顶点的键值。另一个数组parent[]用来存储MST中父节点的索引。parent数组是输出数组，用来显示构建的MST。</p>
<p>上面算法的时间复杂度为O(V^2)。如果使用邻接表表示输入图，那么在二叉堆的帮助下，Prim算法的时间复杂度可以降低到O（ElogV）。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python----socket编程</title>
    <url>/2020/08/28/Python-socket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="基于tcp的套接字编程">基于TCP的套接字编程：</h3>
<p>socket层的位置：socket在传输层和应用层之间</p>
<img data-src="/2020/08/28/Python-socket%E7%BC%96%E7%A8%8B/socket1.jpeg" class>
<h3 id="socket是什么">socket是什么：</h3>
<p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。</p>
<p>socket的底层封装对文件描述符的读写。</p>
<h3 id="套接字分类">套接字分类</h3>
<ol type="1">
<li>基于文件类型的套接字家族；套接字家族的名字：AF_UNIX</li>
<li>基于网络类型的套接字家族；套接字家族的名字：AF_INET</li>
</ol>
<h3 id="套接字工作流程">套接字工作流程</h3>
<img data-src="/2020/08/28/Python-socket%E7%BC%96%E7%A8%8B/socket2.jpeg" class>
<p>先从服务端说起。服务端先初始化Socket，然后与端口绑定（bind），对端口进行监听（listen），调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器（connect），如果连接成功，这时客户端与服务端的连接就建立了。客户端发送数据请求，服务器端接受请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>
<h3 id="socket模块的应用">socket模块的应用：</h3>
<h4 id="服务端套接字函数">服务端套接字函数</h4>
<p>s.bind() 绑定（主机，端口号）到套接字、s.listen()开始TCP监听、s.accept()被动接受TCP客户的连接，（阻塞式）等待连接的到来。</p>
<p>accept成功之后，会创建一个连接connection对象，以及客户端的ip_port信息。</p>
<p>con.close()关闭这个连接。s.close()关闭服务器。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 明确配置变量</span></span><br><span class="line">ip_port = (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>)</span><br><span class="line">back_log = <span class="number">5</span></span><br><span class="line">buffer_size = <span class="number">1024</span></span><br><span class="line"><span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">ser = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 套接字类型AF_INET，socket.SOCK_STREAM, tcp协议，基于流式的协议</span></span><br><span class="line">ser.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 对socket的配置重用ip和端口号</span></span><br><span class="line"><span class="comment"># 绑定端口号</span></span><br><span class="line">ser.bind(ip_port)  <span class="comment"># 写哪个ip就要运行在哪台机器上</span></span><br><span class="line"><span class="comment"># 设置半连接池</span></span><br><span class="line">ser.listen(back_log)  <span class="comment"># 最多可以连接多少个客户端</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 阻塞等待，创建连接</span></span><br><span class="line">    con, address = ser.accept()  <span class="comment"># 在这个位置进行等待，监听端口号</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 接受套接字的大小，怎么发就怎么收</span></span><br><span class="line">            msg = con.recv(buffer_size)</span><br><span class="line">            <span class="keyword">if</span> msg.decode(<span class="string">&#x27;utf-8&#x27;</span>) == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                <span class="comment"># 断开连接</span></span><br><span class="line">                con.close()</span><br><span class="line">            print(<span class="string">&#x27;服务器收到消息&#x27;</span>, msg.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    con.close()</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 关闭服务器</span></span><br><span class="line">ser.close()</span><br></pre></td></tr></table></figure>
<p>简化代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>)</span><br><span class="line">backlog = <span class="number">5</span></span><br><span class="line">buffer_size = <span class="number">1024</span></span><br><span class="line">ser = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">ser.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">ser.bind(ip_port)</span><br><span class="line">ser.listen(backlog)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    con, addr = ser.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            msg = con.recv(buffer_size)</span><br><span class="line">            print(<span class="string">&quot;服务端收到的消息是&quot;</span>, msg.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            con.send(<span class="string">&quot;hello&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> msg.decode(<span class="string">&#x27;utf-8&#x27;</span>) == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    con.close()</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">ser.close()</span><br></pre></td></tr></table></figure>
<p>socket.SOL_SOCKET设置这个让我们可以在套接字级别上设置选项。选项有一些常用取值，常用选项有：</p>
<ul>
<li><p>SO_BROADCAST广播消息的能力（只有udp支持广播，并且还必须是在支持广播消息的网络上（例如以太网，令牌环网等））、</p></li>
<li><p>SO_DEBUG，仅由TCP支持。当给一个TCP套接字开启本选项时，内核将为TCP在该套接字发送和接受的所有分组保留详细跟踪信息。这些信息保存在内核的某个环形缓冲区中，并可使用trpt程序进行检查。</p></li>
<li><p>SO_KEEPALIVE</p>
<p>给一个TCP套接字设置保持存活选项后，如果2小时内在该套接字的任何一方向上都没有数据交换，TCP就自动给对端发送一个保持存活探测分节。这是一个对端必须相应的TCP分节，它会导致以下3种情况之一。</p>
<p>（1）对端以期望的ACK响应。应用进程得不到通知（<strong>因为一切正常</strong>）。在又经过仍无动静的2小时后，TCP将发出另一个探测分节。</p>
<p>（2）对端以RST响应，它告知本端TCP：<strong>对端已崩溃且已重新启动</strong>。该套接字的待处理错误被置为ECONNRESET，套接字本身则被关闭。</p>
<p>（3）对端对保持存活探测分节没有任何响应。</p>
<p><strong>如果根本没有对TCP的探测分节的响应，该套接字的待处理错误就被置为ETIMEOUT，套接字本身则被关闭</strong>。然而如果该套接字收到一个ICMP错误作为某个探测分节的响应，那就返回响应的错误，套接字本身也被关闭。</p>
<p>本选项的功能是检测对端主机是否崩溃或变的不可达（譬如拨号调制解调器连接掉线，电源发生故障等等）。如果对端进程崩溃，它的TCP将跨连接发送一个FIN，这可以通过调用select很容易的检测到。</p>
<p><strong>本选项一般由服务器使用，不过客户也可以使用</strong>。服务器使用本选项时因为他们花大部分时间阻塞在等待穿越TCP连接的输入上，也就是说在等待客户的请求。然而如果客户主机连接掉线，电源掉电或者系统崩溃，服务器进程将永远不会知道，并将继续等待永远不会到达的输入。我们称这种情况为半开连接。保持存活选项将检测出这些半开连接并终止他们。</p></li>
<li><p>SO_LINGER</p>
<p>本选项指定close函数对面向连接的协议（例如TCP和SCTP，但不是UDP）如何操作。默认操作是close立即返回，但是如果有数据残留在套接字发送缓冲区中，系统将试着把这些数据发送给对端。</p></li>
<li><p>RCVBUF和SNDBUF接收和发送缓冲区</p></li>
<li><p>RCVLOWAT和SNDLOWAT接收和发送低水位</p></li>
<li><p>SO_RCVTIMEO 和 SO_SNDTIMEO套接字选项</p></li>
<li><p>SO_REUSEADDR 和 SO_REUSEPORT 套接字选项</p>
<p>SO_REUSEADDR所有的TCP服务器都应该指定本套接字选项，一个最重要的原因如下：</p>
<ul>
<li><p>SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知的端口，即使以前建立的将该端口用作他们的本地端口的连接仍存在。这个条件通常是这样碰到的：</p>
<p>​ （a）启动一个监听服务器；</p>
<p>​ （b）连接请求到达，派生一个子进程来处理这个客户；</p>
<p>​ （c）监听服务器终止，但子进程继续为现有连接上的客户提供服务；</p>
<p>​ （d）重启监听服务器。</p>
<p>默认情况下，当监听服务器在步骤d通过调用socket，bind和listen重新启动时，由于他试图捆绑一个现有连接（即正由早先派生的那个子进程处理着的连接）上的端口，从而bind调用会失败。但是如果该服务器在socket和bind两个调用之间设置了SO_REUSEADDR套接字选项，那么将成功。所有TCP服务器都应该指定本套接字选项，以允许服务器在这种情况下被重新启动。</p></li>
</ul></li>
</ul>
<p>这里关于套接字选项不做更多展开，附上链接参考，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNDQ4MDUvYXJ0aWNsZS9kZXRhaWxzLzc4NTc5Nzcx">https://blog.csdn.net/u010144805/article/details/78579771<i class="fa fa-external-link-alt"></i></span></p>
<p>客户端：p.connect(ip地址，端口号) 连接服务器</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">p = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">p.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    msg = input(<span class="string">&#x27;please input: &#x27;</span>)</span><br><span class="line">    <span class="comment"># 防止输入空消息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    p.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 收发消息一定要二进制，记得编码</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>
<p>简化代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">p = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">p.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">&#x27;please input: &#x27;</span>)</span><br><span class="line">    p.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    data = p.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>用户态：专门存放应用程序。内核态：专门存放操作系统的内核。</li>
<li>在socket 里面 from socket import * 这样可以减少代码量。</li>
<li>当发送回车换行，内容为空，没有必要发所以就会卡顿。当自己这一端 的内核态没东西会卡住recv()。加一个判断是否为空解决。</li>
<li>按照socket数据---&gt;内核态-----&gt;网卡的顺序发送 send()()都是发送socket数据 send()和recv()都是往自己的内存里面收发。</li>
</ul>
<img data-src="/2020/08/28/Python-socket%E7%BC%96%E7%A8%8B/socket3.jpeg" class>
<ul>
<li>端口号+ip地址+mac地址 = 哪个应用程序+哪台电脑+哪个房间（一一对应） 标示互联网上唯一的一个程序</li>
</ul>
<h3 id="udp套接字">udp套接字</h3>
<p>由于udp是无连接的所以比TCP更简洁。</p>
<p>服务端：recvfrom()接受的结果是发送的信息，和发送方的IP和端口号。sendto（信息，目标主机IP和端口号）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">udp_ser = socket(AF_INET, SOCK_DGRAM)  <span class="comment"># 数据报式的套接字</span></span><br><span class="line">udp_ser.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = udp_ser.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(data)  <span class="comment"># (b&#x27;asd&#x27;, (&#x27;127.0.0.1&#x27;, 60606))</span></span><br><span class="line">    udp_ser.sendto(<span class="string">&#x27;data&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>), data[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># udp_ser.close()</span></span><br></pre></td></tr></table></figure>
<p>简化代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">udp_ser = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">udp_ser.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data, addr = udp_ser.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(data, addr)</span><br><span class="line">    udp_ser.sendto(<span class="string">&#x27;hello&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>), addr)</span><br><span class="line">    <span class="keyword">if</span> data.decode(<span class="string">&#x27;utf-8&#x27;</span>) == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">udp_ser.close()</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">&#x27;input-1: &#x27;</span>)</span><br><span class="line">    s.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>), (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># s.close()</span></span><br></pre></td></tr></table></figure>
<p>简化代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">p = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">&#x27;please input: &#x27;</span>)</span><br><span class="line">    p.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>), (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line">    data, addr = p.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>
<p>这里和tcp的socket区别可以看出，recv方法和recvfrom方法的一个区别</p>
<ul>
<li>recv在自己这端缓冲区为空时，阻塞。<br>
</li>
<li>而recvfrom在自己这端的缓冲区为空时，就收一个空。</li>
</ul>
<h3 id="用udp实现两个不同客户端的交流">用udp实现两个不同客户端的交流：</h3>
<p>服务端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">udp_ser = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">udp_ser.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line">data_1, addr_1 = udp_ser.recvfrom(<span class="number">1024</span>)</span><br><span class="line">data_2, addr_2 = udp_ser.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data1 = udp_ser.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    udp_ser.sendto(data1[<span class="number">0</span>], addr_2)</span><br><span class="line">    data2 = udp_ser.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    udp_ser.sendto(data2[<span class="number">0</span>], addr_1)</span><br></pre></td></tr></table></figure>
<p>客户端1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">s.sendto(<span class="string">&#x27;hello&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>), (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">&#x27;input-1: &#x27;</span>)</span><br><span class="line">    s.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>), (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>客户端2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">s.sendto(<span class="string">&#x27;hello&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>), (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    msg = input(<span class="string">&#x27;input-2: &#x27;</span>)</span><br><span class="line">    s.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>), (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br></pre></td></tr></table></figure>
<h3 id="http三次握手四次挥手">HTTP三次握手、四次挥手</h3>
<img data-src="/2020/08/28/Python-socket%E7%BC%96%E7%A8%8B/socket4.jpeg" class>
<p>三次握手（因为刚开始没有数据传输所以可以合并），四次挥手（因为客户端到服务端数据传完可以断开，但是服务端的数据不一定发完，所以不能一次性断开） 握手：</p>
<ol type="1">
<li>客户端发送连接请求（syn）</li>
<li>服务器回应确认发送（ack），第一条客户端到服务器端的连接建好，并且向客户端发送连接请求（syn）</li>
<li>客户端回应确认发送（ack），第二条服务器端到客户端的连接建好。</li>
</ol>
<p>挥手（谁先发完，谁就断开连接）：</p>
<ol type="1">
<li>客户端发送请求断开连接（seq）<br>
</li>
<li>服务端回应确认（ack）此时客户端到服务端的链接断开</li>
<li>服务端发送请求断开连接（seq）</li>
<li>客户端回应确认（ack） 此时服务端到客户端的链接断开</li>
</ol>
<p>至此双向连接都已断开。</p>
<h3 id="http协议">HTTP协议</h3>
<p>特点：无状态的协议、基于请求/响应的模式。</p>
<p>POST方式有请求体，而GET方式没有请求体。在请求协议中，空行是用来和请求体分开。</p>
<p>部分参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accpect：接收类型  *&#x2F;* 代表全部接受，q&#x3D;0.8代表权重</span><br><span class="line">Accpect-Encoding  ：可接受压缩格式</span><br><span class="line">Accpect-Language：可接受的语言</span><br><span class="line">Refer：防盗链，从哪里过来的</span><br><span class="line">Connection： 3000毫秒的时间差</span><br><span class="line">Host：主机地址</span><br><span class="line">user-agent：请求头</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的方法解析顺序(MRO)</title>
    <url>/2020/08/30/Python%E7%9A%84%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F-MRO/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay Tree-II</title>
    <url>/2020/08/13/Splay-Tree-II/</url>
    <content><![CDATA[<h2 id="splay的插入操作">Splay的插入操作</h2>
<p>正如前篇博文所讲的，Splay树是一种自平衡的数据结构，最后一个访问的键总是根。插入操作和二叉搜索树的插入类似，额外多了一些步骤来保证新插入的键称为新的根节点。</p>
<p>以下是插入键值k到一个Splay Tree的不同情况</p>
<ol type="1">
<li>root是空：我们简单的分配一个新的节点，并将它作为root返回</li>
<li>splay（伸展）给定的键值k。如果k已经存在，那么它称为新的根节点。如果不存在，那么最后访问的叶子节点称为新的根节点。</li>
<li>如果新的根节点和k相同，什么都不做因为k已经存在了。</li>
<li>否则，分配内存产生新的节点，并且将k和根的键值比较。
<ol type="1">
<li>如果k比根的键值小，将root作为新节点的右孩子，复制root的左孩子作为新节点的左孩子，并且使root的左孩子置为NULL。</li>
<li>如果k比跟的键值大，将root作为新节点的左孩子，复制root的右孩子作为新节点的右孩子，并且使root的右孩子置为NULL。</li>
</ol></li>
<li>将新节点返回，作为整棵树的根。</li>
</ol>
<p>感觉Splay很大程度上是可以基于AVL树进行修改的，其中左旋、右旋、左右旋、右左旋操作是相同的，只是splay有splay操作。具体实现有时间会仔细看看，在下面参考的链接中有。</p>
<h2 id="参考">参考</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvc3BsYXktdHJlZS1zZXQtMi1pbnNlcnQtZGVsZXRlLz9yZWY9bGJw">https://www.geeksforgeeks.org/splay-tree-set-2-insert-delete/?ref=lbp<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay Tree</title>
    <url>/2020/08/08/Splay-Tree/</url>
    <content><![CDATA[<p>二叉搜索树最坏的时间复杂度比如查找、删除、插入是O(n)的。最坏的情况发生在这棵树已经倾斜了。我们可以使最坏情况的时间复杂度也为O(logn)使用AVL和红黑树。</p>
<h2 id="我们可以比avl和红黑树在实践中做得更好吗">我们可以比AVL和红黑树在实践中做得更好吗？</h2>
<p>像AVL和红黑树一样，splay tree也是自平衡二叉搜索树。splay tree的主要思想是将最近访问的项目放到树的根节点，这使得最近搜索过的项目可以在O(1)的时间复杂度内被搜索到，如果它再次被搜索。思想是使用访问的局部性（在一个典型的应用中，80%的访问是访问其中20%的项目）。想象一个场景，我们有数百万或数十亿的键但是只有它们中很少一部分会被经常访问，这在实际应用中非常有可能发生。</p>
<p>所有的splay tree操作都平均是O(logn)时间复杂度的，n是树中节点的数量。任何一个操作在最坏的情况下可能使用Theta(n)的时间。</p>
<h2 id="查找操作">查找操作</h2>
<p>splay tree的查找操作使用标准的BST查找，在查找同时，它同时还伸展（splay）（将一个节点移到根）。如果查找是成功的，那么找到的那个节点就被伸展并成为新根节点。否则，在到达NULL之前最后被访问的节点被伸展并成为新的根节点。</p>
<p>被访问的节点有以下几种情况。</p>
<ol type="1">
<li><p><strong>节点是根节点。</strong>我们简单地返回根节点，不会做任何事，因为访问的节点已经是根节点。</p></li>
<li><p>Zig：<strong>节点是root的子节点</strong>（该节点没有祖父母）。节点要么是根的左子节点（我们做右旋），要么是根的右子节点（我们做左旋）。</p>
<p>T1，T2和T3是树的子树，其根为y（在左侧）或x（在右侧）。</p></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    y                                     x</span><br><span class="line">   &#x2F; \     Zig (Right Rotation)          &#x2F;  \</span><br><span class="line">  x   T3   – - – - – - – - - -&gt;         T1   y </span><br><span class="line"> &#x2F; \       &lt; - - - - - - - - -              &#x2F; \</span><br><span class="line">T1  T2     Zag (Left Rotation)            T2   T3</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><p><strong>节点既有父节点，也有祖父节点</strong>。可以有以下几种情况。</p>
<p>3.a. <strong>Zig-Zig和Zag-Zag</strong> 节点是父节点的左儿子而且父节点同样也是祖父节点的左儿子（两次右旋），或者，节点是父节点的右儿子而且父节点也是祖父节点的右儿子（两次左旋）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Zig-Zig (Left Left Case):</span><br><span class="line">       G                        P                           X       </span><br><span class="line">      &#x2F; \                     &#x2F;   \                        &#x2F; \      </span><br><span class="line">     P  T4   rightRotate(G)  X     G     rightRotate(P)  T1   P     </span><br><span class="line">    &#x2F; \      &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;  &#x2F; \   &#x2F; \    &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;       &#x2F; \    </span><br><span class="line">   X  T3                   T1 T2 T3 T4                      T2  G</span><br><span class="line">  &#x2F; \                                                          &#x2F; \ </span><br><span class="line"> T1 T2                                                        T3  T4 </span><br><span class="line"></span><br><span class="line">Zag-Zag (Right Right Case):</span><br><span class="line">  G                          P                           X       </span><br><span class="line"> &#x2F;  \                      &#x2F;   \                        &#x2F; \      </span><br><span class="line">T1   P     leftRotate(G)  G     X     leftRotate(P)    P   T4</span><br><span class="line">    &#x2F; \    &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; &#x2F; \   &#x2F; \    &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;   &#x2F; \   </span><br><span class="line">   T2   X               T1 T2 T3 T4                  G   T3</span><br><span class="line">       &#x2F; \                                          &#x2F; \ </span><br><span class="line">      T3 T4                                        T1  T2</span><br></pre></td></tr></table></figure>
<p>3.b. <strong>Zig-Zag and Zag-Zig</strong> 节点是父节点的左儿子，父节点是祖父节点的右儿子（左旋，接着右旋），或者，节点父节点的右儿子，父节点是祖父节点的左儿子（右旋，接着左旋）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Zag-Zig (Left Right Case):</span><br><span class="line">       G                        G                            X       </span><br><span class="line">      &#x2F; \                     &#x2F;   \                        &#x2F;   \      </span><br><span class="line">     P   T4  leftRotate(P)   X     T4    rightRotate(G)   P     G     </span><br><span class="line">   &#x2F;  \      &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;  &#x2F; \          &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;   &#x2F; \   &#x2F;  \    </span><br><span class="line">  T1   X                   P  T3                       T1  T2 T3  T4 </span><br><span class="line">      &#x2F; \                 &#x2F; \                                       </span><br><span class="line">    T2  T3              T1   T2                                     </span><br><span class="line"></span><br><span class="line">Zig-Zag (Right Left Case):</span><br><span class="line">  G                          G                           X       </span><br><span class="line"> &#x2F;  \                      &#x2F;  \                        &#x2F;   \      </span><br><span class="line">T1   P    rightRotate(P)  T1   X     leftRotate(P)    G     P</span><br><span class="line">    &#x2F; \   &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;      &#x2F; \    &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;   &#x2F; \   &#x2F; \   </span><br><span class="line">   X  T4                    T2   P                 T1  T2 T3  T4</span><br><span class="line">  &#x2F; \                           &#x2F; \                </span><br><span class="line"> T2  T3                        T3  T4  </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="例子">例子</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         100                      100                       [20]</span><br><span class="line">         &#x2F;  \                    &#x2F;   \                        \ </span><br><span class="line">       50   200                50    200                      50</span><br><span class="line">      &#x2F;          search(20)    &#x2F;          search(20)         &#x2F;  \  </span><br><span class="line">     40          &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;     [20]         &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;         30   100</span><br><span class="line">    &#x2F;            1. Zig-Zig    \          2. Zig-Zig         \     \</span><br><span class="line">   30               at 40       30            at 100         40    200  </span><br><span class="line">  &#x2F;                               \     </span><br><span class="line">[20]                              40</span><br></pre></td></tr></table></figure>
<p>需要注意的是，搜索或splay操作不仅将被搜索的键带到了根节点，还平衡了BST。例如在上面的案例中，BST的高度减少了1。</p>
<h2 id="实现">实现</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// An AVL tree node </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">int</span> key; </span><br><span class="line">    node *left, *right; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Helper function that allocates </span></span><br><span class="line"><span class="comment">a new node with the given key and </span></span><br><span class="line"><span class="comment">  NULL left and right pointers. */</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> node* Node = <span class="keyword">new</span> node(); </span><br><span class="line">    Node-&gt;key = key; </span><br><span class="line">  Node-&gt;left = Node-&gt;right = <span class="literal">NULL</span>; </span><br><span class="line">  <span class="keyword">return</span> (Node); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to right </span></span><br><span class="line"><span class="comment">// rotate subtree rooted with y </span></span><br><span class="line"><span class="comment">// See the diagram given above. </span></span><br><span class="line"><span class="function">node *<span class="title">rightRotate</span><span class="params">(node *x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  node *y = x-&gt;left; </span><br><span class="line">    x-&gt;left = y-&gt;right; </span><br><span class="line">    y-&gt;right = x; </span><br><span class="line"> <span class="keyword">return</span> y; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to left </span></span><br><span class="line"><span class="comment">// rotate subtree rooted with x </span></span><br><span class="line"><span class="comment">// See the diagram given above. </span></span><br><span class="line"><span class="function">node *<span class="title">leftRotate</span><span class="params">(node *x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> node *y = x-&gt;right; </span><br><span class="line">   x-&gt;right = y-&gt;left; </span><br><span class="line">    y-&gt;left = x; </span><br><span class="line">  <span class="keyword">return</span> y; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// This function brings the key at </span></span><br><span class="line"><span class="comment">// root if key is present in tree. </span></span><br><span class="line"><span class="comment">// If key is not present, then it </span></span><br><span class="line"><span class="comment">// brings the last accessed item at </span></span><br><span class="line"><span class="comment">// root. This function modifies the </span></span><br><span class="line"><span class="comment">// tree and returns the new root </span></span><br><span class="line"><span class="function">node *<span class="title">splay</span><span class="params">(node *root, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="comment">// Base cases: root is NULL or </span></span><br><span class="line">  <span class="comment">// key is present at root </span></span><br><span class="line">   <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;key == key) </span><br><span class="line">       <span class="keyword">return</span> root; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Key lies in left subtree </span></span><br><span class="line"> <span class="keyword">if</span> (root-&gt;key &gt; key) </span><br><span class="line">  &#123; </span><br><span class="line">       <span class="comment">// Key is not in tree, we are done </span></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) <span class="keyword">return</span> root; </span><br><span class="line"></span><br><span class="line">     <span class="comment">// Zig-Zig (Left Left) </span></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;left-&gt;key &gt; key) </span><br><span class="line">     &#123; </span><br><span class="line">           <span class="comment">// First recursively bring the </span></span><br><span class="line">          <span class="comment">// key as root of left-left </span></span><br><span class="line">         root-&gt;left-&gt;left = splay(root-&gt;left-&gt;left, key); </span><br><span class="line"></span><br><span class="line">           <span class="comment">// Do first rotation for root, </span></span><br><span class="line">          <span class="comment">// second rotation is done after else </span></span><br><span class="line">           root = rightRotate(root); </span><br><span class="line">        &#125; </span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left-&gt;key &lt; key) <span class="comment">// Zig-Zag (Left Right) </span></span><br><span class="line">      &#123; </span><br><span class="line">           <span class="comment">// First recursively bring </span></span><br><span class="line">          <span class="comment">// the key as root of left-right </span></span><br><span class="line">            root-&gt;left-&gt;right = splay(root-&gt;left-&gt;right, key); </span><br><span class="line"></span><br><span class="line">         <span class="comment">// Do first rotation for root-&gt;left </span></span><br><span class="line">          <span class="keyword">if</span> (root-&gt;left-&gt;right != <span class="literal">NULL</span>) </span><br><span class="line">               root-&gt;left = leftRotate(root-&gt;left); </span><br><span class="line">       &#125; </span><br><span class="line"></span><br><span class="line">     <span class="comment">// Do second rotation for root </span></span><br><span class="line">      <span class="keyword">return</span> (root-&gt;left == <span class="literal">NULL</span>)? root: rightRotate(root); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> <span class="comment">// Key lies in right subtree </span></span><br><span class="line">  &#123; </span><br><span class="line">       <span class="comment">// Key is not in tree, we are done </span></span><br><span class="line">      <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> root; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Zag-Zig (Right Left) </span></span><br><span class="line">     <span class="keyword">if</span> (root-&gt;right-&gt;key &gt; key) </span><br><span class="line">        &#123; </span><br><span class="line">           <span class="comment">// Bring the key as root of right-left </span></span><br><span class="line">          root-&gt;right-&gt;left = splay(root-&gt;right-&gt;left, key); </span><br><span class="line"></span><br><span class="line">         <span class="comment">// Do first rotation for root-&gt;right </span></span><br><span class="line">         <span class="keyword">if</span> (root-&gt;right-&gt;left != <span class="literal">NULL</span>) </span><br><span class="line">               root-&gt;right = rightRotate(root-&gt;right); </span><br><span class="line">        &#125; </span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right-&gt;key &lt; key)<span class="comment">// Zag-Zag (Right Right) </span></span><br><span class="line">     &#123; </span><br><span class="line">           <span class="comment">// Bring the key as root of </span></span><br><span class="line">         <span class="comment">// right-right and do first rotation </span></span><br><span class="line">            root-&gt;right-&gt;right = splay(root-&gt;right-&gt;right, key); </span><br><span class="line">         root = leftRotate(root); </span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line">     <span class="comment">// Do second rotation for root </span></span><br><span class="line">      <span class="keyword">return</span> (root-&gt;right == <span class="literal">NULL</span>)? root: leftRotate(root); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// The search function for Splay tree. </span></span><br><span class="line"><span class="comment">// Note that this function returns the </span></span><br><span class="line"><span class="comment">// new root of Splay Tree. If key is </span></span><br><span class="line"><span class="comment">// present in tree then, it is moved to root. </span></span><br><span class="line"><span class="function">node *<span class="title">search</span><span class="params">(node *root, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> splay(root, key); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to print </span></span><br><span class="line"><span class="comment">// preorder traversal of the tree. </span></span><br><span class="line"><span class="comment">// The function also prints height of every node </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(node *root)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) </span><br><span class="line">  &#123; </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;root-&gt;key&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">     preOrder(root-&gt;left); </span><br><span class="line">     preOrder(root-&gt;right); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Driver code*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   node *root = newNode(<span class="number">100</span>); </span><br><span class="line">   root-&gt;left = newNode(<span class="number">50</span>); </span><br><span class="line"> root-&gt;right = newNode(<span class="number">200</span>); </span><br><span class="line">   root-&gt;left-&gt;left = newNode(<span class="number">40</span>); </span><br><span class="line">    root-&gt;left-&gt;left-&gt;left = newNode(<span class="number">30</span>); </span><br><span class="line">   root-&gt;left-&gt;left-&gt;left-&gt;left = newNode(<span class="number">20</span>); </span><br><span class="line"></span><br><span class="line">    root = search(root, <span class="number">20</span>); </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Preorder traversal of the modified Splay tree is \n&quot;</span>; </span><br><span class="line"> preOrder(root); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// This code is contributed by rathbhupendra </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="输出">输出</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preorder traversal of the modified Splay tree is</span><br><span class="line">20 50 30 40 100 200</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ol type="1">
<li>splay tree有优异的局部性特质。经常访问的元素很容易被找到。不长访问的元素都不在查找的路上。</li>
<li>所有的splay操作都平均使用O(logn)的时间复杂度。splay tree可以严格的证明，在任何操作的序列上，每次操作的平均时间为O(logn)（假设我们从一颗空树开始）。</li>
<li>splay tree与AVL树和红黑树相比更简单，因为每个树节点都不需要额外的空间。</li>
<li>与AVL树不同，splay树即使进行搜索操作等只读操作也可能改变。</li>
</ol>
<h2 id="splay-tree-的应用场景">splay tree 的应用场景</h2>
<p>splay tree已经成为了过去30年中发明的应用最广泛的基本数据结构，因为它是许多应用中最快的平衡搜索树类型。splay tree被用于Windows NT（在虚拟内存、网络和文件系统代码中）、gcc编译器和GNU C++库、sed字符串编辑器、Fore Systems网络路由器、Unix malloc最流行的实现、Linux可加载的内核模块和许多其他软件中（来源：http://www.cs.berkeley.edu/~jrs/61b/lec/36）。</p>
<h2 id="参考">参考</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvc3BsYXktdHJlZS1zZXQtMS1pbnNlcnQvP3JlZj1sYnA=">https://www.geeksforgeeks.org/splay-tree-set-1-insert/?ref=lbp<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="下一节我们讲splay的插入操作">下一节我们讲splay的插入操作</h2>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>The Humble Programmer by Edsger W. Dijkstra 伟大的 Dijkstra</title>
    <url>/2020/07/28/The-Humble-Programmer-by-Edsger-W-Dijkstra-%E4%BC%9F%E5%A4%A7%E7%9A%84-Dijkstra/</url>
    <content><![CDATA[<h2 id="原文">原文</h2>
<p>https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html</p>
<p>原文很长，这里摘录总结的内容。</p>
<h2 id="摘录">摘录</h2>
<p>让我结束发言。自动计算机已经陪伴我们四分之一个世纪。它们作为工具的能力对我们的社会产生了巨大的影响，但就这种能力而言，它们的影响只是我们文化表面上的一个涟漪，而与之相比，它们在人类文化史上前所未有的智力挑战能力方面将产生更深远的影响。层次系统似乎具有这样的特性：在一个层次上被视为无法分隔的东西，在下一个层次上被视为更详细的复合对象；因此，当我们把注意力从一个层次转移到下一个更低层次上时，适用于每个层次的自然空间或时间的颗粒就会减少一个数量级。我们用砖头来理解墙壁，用晶体来理解砖头，用分子来理解晶体等等。在一个层次系统中，可以有意义的区分的层次数量，有点正比于最大和最小的晶粒之间的比例的对数，因此，除非这个比例非常大，否则我们不能期望有很多次的层次。在计算机编程中，我们的基本构建的相关时间最小度量不到一微秒，但我们的程序可能需要几个小时的计算时间。我不知道有其他任何技术覆盖了10的10次方或更高的比例：计算机，凭借其神奇的速度，似乎是第一个为我们提供了一个高度层次化的既可能又必要的环境。这种挑战，即，面对编程任务，是如此的独特，以至于这种新奇的经验可以给我们很多关于自己的启示。<strong>它应该加深我们对设计和创造过程的理解，它应该让我们更好的控制组织思想的任务。</strong>如果它没有做到这一点，以我的品味，我们应该根本不配拥有电脑！</p>
<p><strong>它已经给了我们一些教训，我选择在这次演讲中强调的是以下几点。只要我们在处理任务时充分认识到它的巨大困难，只要我们坚持使用适度而优雅的编程语言，只要我们尊重人类思维的内在局限性，并以非常谦逊的程序员的身份处理任务，我们就会把编程工作做得更好。</strong></p>
<p>ACM Turing Lecture 1972</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll的优劣和原理</title>
    <url>/2020/08/27/epoll%E7%9A%84%E4%BC%98%E5%8A%A3%E5%92%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="epoll-网络事件收集器模型也有分发">epoll 网络事件收集器模型（也有分发）</h3>
<p>nginx事件分发机制，在其中的循环流程中，最关键的就是，nginx怎样能够快速的从操作系统的kernal中获取到等待处理的事件，这么一个简单的步骤，其实，经历了很长时间的解决。比如，到现在nginx主要在使用epoll这样一个网络事件收集器的模型。那么，下面我们来简单的回顾下，epoll有些什么样的特点。</p>
<p>首先，epoll 和 kqueue（mac os内核才有）随文件描述符（句柄数的增加，也表示并发连接数的增加）的增加，所消耗的时间几乎不变。而Poll和select所消耗的时间是急剧上升的。epoll基本与句柄数增加是无关的，所以它的性能会好很多，而且非常适合做大并发连接的处理。那么，为什么会这样呢？</p>
<h3 id="前提">前提</h3>
<p>高并发连接中，每次处理的活跃连接数量占比很小</p>
<blockquote>
<p>select 和 poll的实现是有问题的。每一次我去取操作系统的事件的时候，我都需要把这100万个连接通通地扔给操作系统，让它去依次地判断哪些连接上面有事件进来了，所以可以看到这里操作系统做了大量的无用功 ，它扫描了大量不活跃的连接。那么epoll就是用了这样的一个特性，因为每次处理的活跃连接的占比其实非常小，那么，它怎么实现的呢？其实非常简单，因为它维护了一个数据结构叫eventpoll。这里，它通过两个数据结构把这两件事分开了。也就是说，nginx每次取活跃连接的时候，我们只需要去遍历一个链表，这个链表里仅仅只有活跃的连接，这样我们的效率就很高。那么，我们还会经常做的操作是什么呢？比如说，nginx收到80端口建立连接的请求。那么，收到80端口建立连接成功以后呢，我们要添加一个读事件，这个读事件是用来读取HTTP消息的，那这时候呢，我可能会添加一个新的事件，或者写事件添加进来。这个时候添加呢，我只会放到这个红黑树中，这个二叉平衡树，它能保证我的插入效率值是logn。如果我现在不想再处理读事件或者写事件，我只需要从这个平衡二叉树中移除一个节点就可以了，同样是logn的时间复杂度。所以这个效率非常高。那么什么时候这个链表会有所增减呢。当我们读取一个事件的时候，链表中自然就没了。那么，当操作系统接收到网卡中发送来的一个报文的时候，那么这个链表就会增加一个新的元素，所以我们在使用epoll的时候，它的操作，添加修改删除，是非常快的，是logn复杂度的。而我们获取句柄的时候，只是去遍历这个rdllink，也就是ready准备好的所有的连接，是把它读取出来而已。那么，从内核态读取到用户态，只读这么一点东西，它的效率是非常高的。</p>
</blockquote>
<h3 id="实现">实现</h3>
<ul>
<li>红黑树</li>
<li>链表</li>
</ul>
<h3 id="使用">使用</h3>
<ul>
<li>创建</li>
<li>操作：添加/修改/删除</li>
<li>获取句柄</li>
<li>关闭</li>
</ul>
<p>以上，简单介绍了epoll的使用方法，它对我们理解nginx的事件驱动模型是有帮助的。</p>
<h3 id="参考">参考</h3>
<p>陶辉老师的<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb3Vyc2UvZGV0YWlsLzEwMDAyMDMwMS02ODM5NA==">Nginx核心知识100讲<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>grant之后要跟着flush privileges吗？ </title>
    <url>/2020/08/29/grant%E4%B9%8B%E5%90%8E%E8%A6%81%E8%B7%9F%E7%9D%80flush-privileges%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p>先说结论：</p>
<p><strong>正常情况下，grant命令之后，没有必要跟着执行flush privileges命令。</strong></p>
<p>那么，flush privileges是什么时候使用呢？显然，当数据表中的权限数据根内存中的权限数据不一样的时候，flush privileges语句可以用来重建内存数据，达到一致状态。</p>
<p>这种不一致往往是由不规范的操作导致的，比如直接用DML语句操作系统权限表。</p>
<p>直接操作系统表是不规范的操作。这个不一致状态也会导致一些更“诡异”的现象发生。不要直接操作系统表。</p>
<h3 id="小结">小结</h3>
<p>grant 语句会同时修改数据表和内存，判断权限的时候使用的是内存数据。因此，规范地使用 grant 和 revoke 语句，是不需要随后加上 flush privileges 语句的。</p>
<p>flush privileges 语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下再使用。而这种不一致往往是由于直接用 DML 语句操作系统权限表导致的，所以我们尽量不要使用这类语句。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>insert语句的锁为什么这么多？</title>
    <url>/2020/08/28/insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F/</url>
    <content><![CDATA[<p>在上一篇文章中，我提到MySQL对自增主键锁做了优化，尽量在申请到自增id以后，就释放自增锁。</p>
<p>因此，insert语句是一个很轻量的操作。不过，这个结论是对于“普通的insert语句”才有效。也就是说，还有些insert语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申请到自增id以后就立马释放自增锁。</p>
<p>那么，今天这篇文章，我们就一起来聊聊这个话题。</p>
<h3 id="insert...select语句">1. insert...select语句</h3>
<p>我们先从上一篇文章的话题说起吧。表t1和t2的表结构、初始化数据语句如下，今天的例子我们还是针对这两个表展开。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t</span><br></pre></td></tr></table></figure>
<p>现在，我们一起来看看为什么在可重复读隔离级别下，binlog_format=statement时执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> iinto t2(c, d) <span class="keyword">select</span> c, d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure>
<p>这个语句时需要对表t的所有行和间隙加锁呢？</p>
<p>其实，这个问题我们需要考虑的还是日志和数据的一致性。我们看下这个执行序列：</p>
<img data-src="/2020/08/28/insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F/insert-%E5%B9%B6%E5%8F%91insert%E5%9C%BA%E6%99%AF.png" class>
<p>实际的执行效果是，如果session B先执行，由于这个语句对表t主键索引加了（-∞，1]这个next-key lock，会在语句执行完成后，才允许session A的insert语句执行。</p>
<p>但如果没有锁的话，就可能出现session B的insert语句先执行，但是后写入binlog的情况。于是，在binlog_format=statement的情况下，binlog里面就记录了这样的语句序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c, d) <span class="keyword">select</span> c, d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure>
<p>这个语句到了备库执行，就会把id=-1这一行也写到表t2中，出现主备不一致。</p>
<h3 id="insert循环写入">2. insert循环写入</h3>
<p>当然了，执行insert...select的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。</p>
<p>如果现在有这么一个需求：要往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1。</p>
<p>此时，我们可以这么写这条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c, d) (<span class="keyword">select</span> c+<span class="number">1</span>, d <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这个语句的加锁范围，就是表t索引c上的(3, 4]和(4, supremum]的两个next-key lock，以及主键索引上id=4这一行。</p>
<p>它的执行流程也比较简单，从表t中按照索引c倒序，扫描第一行，拿到结果写入到表t2中。</p>
<p>因此整条语句的扫描行数是1。</p>
<p>这个语句执行的慢查询日志（slow log），如下图所示：</p>
<img data-src="/2020/08/28/insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F/insert-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97-%E5%B0%86%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E8%A1%A8t2.png" class>
<p>通过这个慢查询日志，我们看到Rows_examined=1，正好验证了执行这条语句的扫描行数为1。</p>
<p>那么，如果我们是要把这样的一行数据插入到表t中的话：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c, d) (<span class="keyword">select</span> c+<span class="number">1</span>, d <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这个语句的执行流程是怎样的？扫描行数又是多少呢？</p>
<p>这时候，我们再看慢查询日志就会发现不对了。</p>
<img data-src="/2020/08/28/insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F/insert-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97-%E5%B0%86%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E8%A1%A8t.png" class>
<p>可以看到，这时候的Rows_examined的值是5。</p>
<p>我在前面的文章提到过，希望你能够学会用explain的结果来“脑补”正条语句的执行过程。今天，我们就来一起试试。</p>
<p>如图4所示就是这条语句的explain结果。i</p>
<img data-src="/2020/08/28/insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F/insert-explain%E7%BB%93%E6%9E%9C.png" class>
<p>从Extra字段可以看到“Using temporary"字样，表示这个语句用到了临时表。也就是说，执行过程中，需要把表t的内容读出来，写入临时表。</p>
<p>图中rows显示的是1，我们不妨先对这个语句的执行流程做一个猜测：如果说是把子查询的结果读出来（扫描1行），写入临时表，然后再从临时表读出来（扫描1行），写回表t中。那么，这个语句的扫描行数就应该是2，而不是5。</p>
<p>所以，这个猜测不对。实际上，Explain结果里的rows=1是因为受到了limit 1的影响。</p>
<p>从另一个角度考虑的话，我们可以看看InnoDB扫描了多少行。如下图所示，是在执行这个语句前后查看innodb_rows_read的结果。</p>
<img data-src="/2020/08/28/insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F/insert-innodb-rows-read%E5%8F%98%E5%8C%96.png" class>
<p>可以看到，这个语句执行前后，Innodb_rows_read的值增加了4。因此默认临时表是使用Memory引擎的，所以这4行查的都是表t，也就是说对表t做了全表扫描。</p>
<p>这样，我们就把整个执行过程理清楚了：</p>
<ol type="1">
<li>创建临时表，表里有两个字段c和d。</li>
<li>按照索引c扫描表t，依次取c=4、3、2、1，然后回表，读到c和d的值写入临时表。这时，Rows_examined=4。</li>
<li>由于语义里面有limit 1，所以只取了临时表的第一行，再插入到表t中。这时，Rows_examined的值加1，变成了5。</li>
</ol>
<p>也就是说，这个语句会导致在表t上做全表扫描，并且会给索引c上的所有间隙都加上共享的next-key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据。</p>
<p>至于这个语句的执行为什么需要临时表，原因是这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历的过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。</p>
<p>由于实现上这个语句没有在子查询中就直接使用limit 1，从而导致了这个语句的执行需要遍历整个表t。它的优化方法也比较简单，就是用前面介绍的方法，先insert into到临时表temp_t，这样就只需要扫描一行；然后再从表temp_t里面取出这行数据插入表t1。</p>
<p>当然，由于这个语句涉及到的数据量很小，你可以考虑使用内存临时表来做这个优化。使用内存临时表优化时，语句序列的写法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t(c <span class="built_in">int</span>,d <span class="built_in">int</span>) <span class="keyword">engine</span>=<span class="keyword">memory</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t (<span class="keyword">select</span> c + <span class="number">1</span>, d <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> * <span class="keyword">from</span> temp_t;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> temp_t;</span><br></pre></td></tr></table></figure>
<h3 id="insert唯一键冲突">3. insert唯一键冲突</h3>
<p>前面的两个例子是使用insert...select的情况，接下来我要介绍的这个例子就是最常见的insert语句出现唯一键冲突的情况。</p>
<p>对于有唯一键的表，插入数据时出现唯一键冲突也是常见的情况了。我先给你举一个简单的唯一键冲突的例子。</p>
<img data-src="/2020/08/28/insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F/insert-%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81%E5%8A%A0%E9%94%81.png" class>
<p>这个例子也是在可重复读（repeatable read）隔离级别下执行的。可以看到，session B要执行的insert语句进入了锁等待状态。</p>
<p>也就是说，session A执行的insert语句，发生唯一键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁。我们前面说过，一个next-key lock就是由它的右边界的值定义的。这时候，session A持有索引c上的(5, 10]共享的next-key lock（读锁）。</p>
<p>至于为什么要加这个锁，其实我也没找到合理的解释。从作用上来看，这样做可以避免这一行被别的事务删掉。</p>
<p>这里官方文档有一个描述错误，认为如果冲突的是主键索引，就加记录锁，唯一索引才加next-key lock。但实际上，这两类索引冲突加的都是next-key lock。</p>
<p>这里，我就先和你分享一个经典的死锁场景。</p>
<img data-src="/2020/08/28/insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F/insert-%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81-%E6%AD%BB%E9%94%81.png" class>
<p>在session A执行rollback语句回滚的时候，session C几乎同时发现死锁并返回。</p>
<p>这个死锁产生的逻辑是这样的：</p>
<ol type="1">
<li>在T1时刻，启动session A，并执行insert语句，此时在索引c的c=5上加了记录锁。注意，这个索引是唯一索引，因此退化为记录锁（如果你的印象模糊了，可以回顾下<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83NTY1OQ==">第21篇文章<i class="fa fa-external-link-alt"></i></span>介绍的加锁规则）。</li>
<li>在T2时刻，session B要执行相同的insert语句，发现了唯一键冲突，加上读锁；同样地，session C也在索引c上，c=5这一个记录上，加了读锁。</li>
<li>T3时刻，session A回滚。这时候，session B和session C都试图继续执行插入操作，都要加上写锁。两个session都要等待对方的行锁，所以就出现了死锁。</li>
</ol>
<p>这个流程的状态变化图如下所示。</p>
<img data-src="/2020/08/28/insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F/insert-%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E5%9B%BE-%E6%AD%BB%E9%94%81.jpg" class>
<h3 id="insert-into-...-on-duplicate-key-update">4. insert into ... on duplicate key update</h3>
<p>上面这个例子是主键冲突后直接报错，如果是改写成</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">11</span>, <span class="number">10</span>, <span class="number">10</span>) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> d=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>的话，就会给索引c上(5, 10]加一个排他的next-key lock（写锁）。</p>
<p><strong>insert into ... on duplicate key update 这个语义的逻辑是，插入一行数据，如果碰到唯一键约束，就执行后面的更新语句。</strong></p>
<p>注意，如果有多个列违反了唯一性约束，就会按照索引的顺序，修改跟第一个索引冲突的行。</p>
<p>现在表t里面已经有了(1, 1, 1)和(2, 2, 2)这两行，我们再来看看下面这个语句执行的效果：</p>
<img data-src="/2020/08/28/insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F/insert-%E4%B8%A4%E4%B8%AA%E5%94%AF%E4%B8%80%E9%94%AE%E5%90%8C%E6%97%B6%E5%86%B2%E7%AA%81.png" class>
<p>可以看到，主键id是先判断的，MySQL认为这个语句跟id=2这一行冲突，所以修改的是id=2的行。</p>
<p>需要注意的是，执行这条语句的affected rows返回的是2，很容易在成误解。实际上，真正更新的只有一行，只是在代码实现桑，insert和update都认为自己成功了，update计数增加了1，insert计数增加了1。</p>
<h3 id="小结">小结</h3>
<p>今天这篇文章，我和你介绍了几种特殊情况下的insert语句。</p>
<p>insert...select时很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别下，这个语句会给select的表里扫描到的记录和间隙加读锁。</p>
<p>而如果insert和select的对象是同一个表，则有可能会造成循环写入。这种情况下，我们需要引入用户临时表来做优化。</p>
<p>insert语句如果出现唯一键冲突，会在冲突的唯一值上加共享的next-key lock（S锁）。因此，碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。</p>
<p>最后，我给你留一个问题吧。</p>
<p>你平时在两个表之间拷贝数据用的是什么方法，有什么注意事项吗？在你的应用场景里，这个方法，相较于其他方法的优势是什么呢？</p>
<p>另外，insert..select执行期间，有其他线程操作原表，会导致逻辑错误。其实这是不会的，如果不加锁，就是快照读。</p>
<p>一条语句执行期间，它的一致性视图是不会修改的，所以即使有其他事务修改了原表的数据，也不会影响这条语句看到的数据。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>insert语句的锁为什么这么多？</title>
    <url>/2020/08/28/insert%E8%AF%AD%E5%8F%A5%E7%9A%84%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%9F_%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p>在上一篇文章中，我提到MySQL对自增主键锁做了优化，尽量在申请到自增id以后，就释放自增锁。</p>
<p>因此，insert语句是一个很轻量的操作。不过，这个结论是对于“普通的insert语句”才有效。也就是说，还有些insert语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申请到自增id以后就立马释放自增锁。</p>
<p>那么，今天这篇文章，我们就一起来聊聊这个话题。</p>
<h3 id="insert...select语句">1. insert...select语句</h3>
<p>我们先从上一篇文章的话题说起吧。表t1和t2的表结构、初始化数据语句如下，今天的例子我们还是针对这两个表展开。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t</span><br></pre></td></tr></table></figure>
<p>现在，我们一起来看看为什么在可重复读隔离级别下，binlog_format=statement时执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> iinto t2(c, d) <span class="keyword">select</span> c, d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure>
<p>这个语句时需要对表t的所有行和间隙加锁呢？</p>
<p>其实，这个问题我们需要考虑的还是日志和数据的一致性。我们看下这个执行序列：</p>

<p>实际的执行效果是，如果session B先执行，由于这个语句对表t主键索引加了（-∞，1]这个next-key lock，会在语句执行完成后，才允许session A的insert语句执行。</p>
<p>但如果没有锁的话，就可能出现session B的insert语句先执行，但是后写入binlog的情况。于是，在binlog_format=statement的情况下，binlog里面就记录了这样的语句序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c, d) <span class="keyword">select</span> c, d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure>
<p>这个语句到了备库执行，就会把id=-1这一行也写到表t2中，出现主备不一致。</p>
<h3 id="insert循环写入">2. insert循环写入</h3>
<p>当然了，之心吧insert...select的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。</p>
<p>如果现在有这么一个需求：要往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1。</p>
<p>此时，我们可以这么写这条SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm内存模型全面解析</title>
    <url>/2020/08/28/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>jvm在拿到操作系统分配的内存后，将内存分成了5个区域。</p>
<p>按线程私有和线程共有分为：</p>
<p>线程私有：</p>
<ol type="1">
<li>栈（函数运行过程中的临时变量，存储基本类型，对象类型的指针）</li>
<li>本地方法栈（C++native方法运行的栈区，C++基本类型，与C++对象类型的指针）</li>
<li>程序计数器（指向程序当前运行的位置，字节码序列的位置）</li>
</ol>
<p>共有（属于同一进程）：</p>
<ol type="1">
<li>方法区（元空间）（全局静态方法、变量、类加载器，等等一些全局信息）</li>
<li>堆（存储实际对象）</li>
</ol>
<p>栈的空间出栈即可清空，但是堆上创建的对象是不能够随着函数的运行完毕去清理的，因为也不知道是否有其他线程也引用了当前对象，也使用了当前地址，所以它无法进行清空，因而用到了GC机制。</p>
<p>堆中注意，对于对象类型，堆中存储的依然是对象类型的指针，指向在堆中对象的实际位置，直到基本类型，存储的是实际值，形象地说是一连串的对象。</p>
<p>除了栈和堆，还需要在意方法区。方法区什么时候起作用呢，比如说public static void main这个main函数就是存在方法区的。或者比如static Integer i = 10;这个i就是存在方法区。因为方法区也是一个全局的，所以在不同函数的栈中也可以同时的调用方法区里面的i。Main.i去调用静态变量。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1519. 子树中标签相同的节点数</title>
    <url>/2020/08/01/leetcode-1519-%E5%AD%90%E6%A0%91%E4%B8%AD%E6%A0%87%E7%AD%BE%E7%9B%B8%E5%90%8C%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<h3 id="原题链接">原题链接</h3>
<p>https://leetcode-cn.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/</p>
<h3 id="原题简要描述">原题简要描述</h3>
<p>给你一棵树（即，一个连通的无环无向图），这棵树由编号从 <code>0</code> 到 <code>n - 1</code> 的 n 个节点组成，且恰好有 <code>n - 1</code> 条 <code>edges</code> 。树的根节点为节点 <code>0</code> ，树上的每一个节点都有一个标签，也就是字符串 <code>labels</code> 中的一个小写字符（编号为 <code>i</code> 的 节点的标签就是 <code>labels[i]</code> ）</p>
<p>边数组 <code>edges</code> 以 <code>edges[i] = [ai, bi]</code> 的形式给出，该格式表示节点 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>
<p>返回一个大小为 <em><code>n</code></em> 的数组，其中 <code>ans[i]</code> 表示第 <code>i</code> 个节点的子树中与节点 <code>i</code> 标签相同的节点数。</p>
<p>树 <code>T</code> 中的子树是由 <code>T</code> 中的某个节点及其所有后代节点组成的树。</p>
<p>这道题目问题的描述有点绕，我第一遍没有读明白，后来才明白。</p>
<p>其实就是将树变成无环无向图，有一个顶点。所有的边都给你了，顶点用数字表示，数字对应一个字符串的索引，让你写出每个数字的子树上（包括这个数字的顶点本身），有多少个和这个数字对应索引的字符相同的。</p>
<h3 id="代码">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个子函数</span></span><br><span class="line"><span class="comment"># 这个函数计算每一个节点为根的子树，所有标记的计数</span></span><br><span class="line"><span class="comment"># 因为用邻接表表示的边，我们为了防止边的重复访问，需要记录访问节点</span></span><br><span class="line"><span class="comment"># 因为没有环，所以我们只要记住前一个节点，在访问下一个节点的相邻节点的时候</span></span><br><span class="line"><span class="comment"># 不访问这个节点就可以了</span></span><br><span class="line"><span class="comment"># 参数为dfs(i, pre)， i就是这个节点的编号，pre就是前一个节点的编号</span></span><br><span class="line"><span class="comment"># 终止条件就是这个点的相邻节点都访问过了</span></span><br><span class="line"><span class="comment"># 这样我们在全局的一个数组变量中，更新相应的i的值即可</span></span><br><span class="line"><span class="comment"># 最后我们返回这个数组变量就是所求</span></span><br><span class="line"><span class="comment"># 利用了python中Counter有加法的api</span></span><br><span class="line"><span class="comment"># 我们可以简化代码</span></span><br><span class="line"><span class="comment"># 否则我们如果用字典，我们要遍历字典，把存在于本层的加上，不存在于本层的添加进来即可</span></span><br><span class="line"><span class="comment"># 稍微麻烦点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubTrees</span>(<span class="params">self, n: int, edges: List[List[int]], labels: str</span>) -&gt; \</span></span><br><span class="line"><span class="function">            List[int]:</span></span><br><span class="line">        edge_map = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            edge_map[e[<span class="number">0</span>]].append(e[<span class="number">1</span>])</span><br><span class="line">            edge_map[e[<span class="number">1</span>]].append(e[<span class="number">0</span>])</span><br><span class="line">        ans = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, pre</span>):</span></span><br><span class="line">            data = &#123;labels[i]: <span class="number">1</span>&#125;</span><br><span class="line">            <span class="keyword">for</span> nxt <span class="keyword">in</span> edge_map[i]:</span><br><span class="line">                <span class="keyword">if</span> nxt != pre:</span><br><span class="line">                    <span class="keyword">for</span> k, v <span class="keyword">in</span> dfs(nxt, i).items():</span><br><span class="line">                        <span class="keyword">if</span> k <span class="keyword">in</span> data:</span><br><span class="line">                            data[k] += v</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            data[k] = v</span><br><span class="line">            ans[i] = data[labels[i]]</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubTrees</span>(<span class="params">self, n: int, edges: List[List[int]], labels: str</span>) -&gt; \</span></span><br><span class="line"><span class="function">            List[int]:</span></span><br><span class="line">        edge_map = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            edge_map[e[<span class="number">0</span>]].append(e[<span class="number">1</span>])</span><br><span class="line">            edge_map[e[<span class="number">1</span>]].append(e[<span class="number">0</span>])</span><br><span class="line">        ans = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, pre</span>):</span></span><br><span class="line">            data = Counter(&#123;labels[i]: <span class="number">1</span>&#125;)</span><br><span class="line">            <span class="keyword">for</span> nxt <span class="keyword">in</span> edge_map[i]:</span><br><span class="line">                <span class="keyword">if</span> nxt != pre:</span><br><span class="line">                    data += dfs(nxt, i)</span><br><span class="line">            ans[i] = data[labels[i]]</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 207.课程表</title>
    <url>/2020/08/04/leetcode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本题可约化为： 课程安排图是否是 有向无环图(DAG)。</span></span><br><span class="line"><span class="comment"># 即课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。</span></span><br><span class="line"><span class="comment"># 思路是通过 拓扑排序 判断此课程安排图是否是 有向无环图(DAG) 。</span></span><br><span class="line"><span class="comment"># 拓扑排序原理： 对 DAG 的顶点进行排序，使得对每一条有向边 (u,v)，</span></span><br><span class="line"><span class="comment"># 均有 u（在排序记录中）比 v 先出现。</span></span><br><span class="line"><span class="comment"># 亦可理解为对某点 v 而言，只有当 v 的所有源点均出现了，v 才能出现。</span></span><br><span class="line"><span class="comment"># 通过课程前置条件列表 prerequisites 可以得到课程安排图的 邻接表 adjacency，</span></span><br><span class="line"><span class="comment"># 以降低算法时间复杂度，以下两种方法都会用到邻接表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.统计课程安排图中弄每个节点的入度，生成入度表indegrees</span></span><br><span class="line"><span class="comment"># 2.借助一个队列queue，将所有入度为0的节点入队。</span></span><br><span class="line"><span class="comment"># 3.当queue非空时，依次将队首节点出队，在课程安排图中删除此节点pre：</span></span><br><span class="line"><span class="comment">#    并不是真正从邻接表中删除此节点pre，而是将此节点对应所有邻接节点cur的入度-1</span></span><br><span class="line"><span class="comment">#    即indegrees[cur] -= 1.</span></span><br><span class="line"><span class="comment">#    当入度-1后邻接节点cur的入度为0，说明cur所有的前驱节点已经被&quot;删除&quot;，此时将cur入队。</span></span><br><span class="line"><span class="comment"># 4.在每次pre出队时，执行numCourses--;</span></span><br><span class="line"><span class="comment">#    若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。</span></span><br><span class="line"><span class="comment">#    换个角度说，若课程安排图中存在环，一定有节点的入度始终不为0。</span></span><br><span class="line"><span class="comment">#    因此，拓扑排序出队次数等于课程个数，返回numCourses==0判断课程是否可以成功安排</span></span><br><span class="line"><span class="comment"># 时间复杂度 O(N+M)： 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量；</span></span><br><span class="line"><span class="comment"># 空间复杂度 O(N+M)： 为建立邻接表所需额外空间，adjacency 长度为 N ，并存储 M 条临边的数据。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">self, numCourses: int,</span></span></span><br><span class="line"><span class="function"><span class="params">                  prerequisites: List[List[int]]</span>) -&gt; bool:</span></span><br><span class="line">        indegrees = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        adjacency = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="comment"># Get the indegree and adjacency of every course.</span></span><br><span class="line">        <span class="keyword">for</span> cur, pre <span class="keyword">in</span> prerequisites:</span><br><span class="line">            indegrees[cur] += <span class="number">1</span></span><br><span class="line">            adjacency[pre].append(cur)</span><br><span class="line">        <span class="comment"># Get all the courses with the indegree of 0.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(indegrees)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]:</span><br><span class="line">                queue.append(i)</span><br><span class="line">        <span class="comment"># BFS TopSort.</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            pre = queue.popleft()</span><br><span class="line">            numCourses -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> cur <span class="keyword">in</span> adjacency[pre]:</span><br><span class="line">                indegrees[cur] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> indegrees[cur]:</span><br><span class="line">                    queue.append(cur)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> numCourses</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原理是通过DFS判断图中是否有环</span></span><br><span class="line"><span class="comment"># 算法流程</span></span><br><span class="line"><span class="comment"># 1.借助一个标志列表flags，用于判断每个节点i（课程）的状态：</span></span><br><span class="line"><span class="comment">#    1.未被DFS访问：i==0</span></span><br><span class="line"><span class="comment">#    2.已被其他节点启动的DFS访问：i==-1</span></span><br><span class="line"><span class="comment">#    3.已被当前节点启动的DFS访问：i==1。</span></span><br><span class="line"><span class="comment"># 2.对numCourses个节点一次执行DFS，判断每个节点起步DFS是否存在换，若存在直接放回False</span></span><br><span class="line"><span class="comment">#    DFS流程</span></span><br><span class="line"><span class="comment">#    1.终止条件：</span></span><br><span class="line"><span class="comment">#      当flag[i] == -1，说明当前访问节点已被其他节点启动的DFS访问，</span></span><br><span class="line"><span class="comment">#      无需再重复搜索，直接返回True</span></span><br><span class="line"><span class="comment">#      当flag[i] == 1，说明在本轮DFS搜索中节点i被第2次访问，即课程安排图有环，直接返回False</span></span><br><span class="line"><span class="comment">#    2.将当前访问节点i对应flag[i]置1，即标记其本轮被DFS访问过；</span></span><br><span class="line"><span class="comment">#    3.递归访问当前节点i的所有邻接节点j，当发现环直接返回False；</span></span><br><span class="line"><span class="comment">#    4.当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点flag置为-1并返回True</span></span><br><span class="line"><span class="comment"># 3.若整个图DFS结束并未发现环，返回True</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">self, numCourses: int,</span></span></span><br><span class="line"><span class="function"><span class="params">                  prerequisites: List[List[int]]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, adjacency, flags</span>):</span></span><br><span class="line">            <span class="keyword">if</span> flags[i] == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> flags[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            flags[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> adjacency[i]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> dfs(j, adjacency, flags):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            flags[i] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        adjacency = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        flags = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        <span class="keyword">for</span> cur, pre <span class="keyword">in</span> prerequisites:</span><br><span class="line">            adjacency[pre].append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dfs(i, adjacency, flags):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 215. 数组中的第K个最大元素 </title>
    <url>/2020/08/07/leetcode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="借助本题深入了解快速排序中的随机选择和堆的堆化插入删除操作">借助本题深入了解快速排序中的随机选择，和堆的堆化、插入、删除操作</h2>
<h2 id="题目">题目</h2>
<h4 id="数组中的第k个最大元素"><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva3RoLWxhcmdlc3QtZWxlbWVudC1pbi1hbi1hcnJheS8=">215. 数组中的第K个最大元素<i class="fa fa-external-link-alt"></i></span></h4>
<p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<h3 id="思路">思路</h3>
<ol type="1">
<li>暴力解法</li>
</ol>
<p>题目要求我们找到”数组排序后的第k个最大的元素，而不是第k个不同的元素“。</p>
<p>因此，升序排序以后，目标元素的索引是 len - k ，这是最简单的思路。</p>
<ul>
<li>最简单同时也一定是最容易编码的，编码成功的几率最高，可以用这个简单思路编码的结果和其他思路编码的结果进行比对，验证高级算法的正确性；</li>
<li>在数据规模小、对时间复杂度、空间复杂度要求不高的时候，简单问题简单做；</li>
<li>思路简单的算法考虑清楚了，有些时候能为实现高级算法铺路，这道题也是如此；</li>
<li>低级算法往往容错性最好，即在输入不满足题目条件的时候，往往还能得到正确的答案，而高级算法对输入数据的要求就非常苛刻。</li>
</ul>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(nlogn)，这里n是数组的长度，主要是排序，语言内置的排序一般是优化的快排或者归并，O(nlogn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<ol start="2" type="1">
<li><h3 id="借助-partition-操作定位到最终排定以后索引为-len---k-的那个元素特别注意随机化切分元素">借助 partition 操作定位到最终排定以后索引为 <code>len - k</code> 的那个元素（特别注意：随机化切分元素）</h3></li>
</ol>
<p>以下是注意事项，因为很重要，所以放在前面说：</p>
<blockquote>
<p>快速排序虽然快，但是如果实现得不好，在遇到特殊测试用例的时候，时间复杂度会变得很高。</p>
</blockquote>
<p>分析：我们在学习"快速排序"的时候，接触的第1个操作就是partition（切分），简单介绍如下：</p>
<p>partition（切分）操作，使得：</p>
<ul>
<li>对于某个索引j，nums[j]已经排定，即nums[j]经过partition（切分）操作以后会放置在它“最终应该放置的地方”；</li>
<li>nums[left]到nums[j - 1]中的所有元素都不大于nums[j]；</li>
<li>nums[j + 1]到nums[right]中的所有元素都不小于nums[j]；</li>
</ul>
<p>partition（切分）操作总能排定一个元素，还能够知道这个元素它最终所在的位置，这样每经过一次partition（切分）操作就能缩小搜索的范围，这样的思想叫做“减而治之”（是分而治之的思想的特例）。</p>
<p>切分过程可以不借助额外的数组空间，仅通过交换数组元素来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">nums, l, r</span>):</span></span><br><span class="line">    pivot = r</span><br><span class="line">    right = l</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[pivot]:</span><br><span class="line">            nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">    nums[right], nums[pivot] = nums[pivot], nums[right]</span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(N)，这里N是数组的长度，可以通过主定理证明。</li>
<li>空间复杂度：O(1)</li>
</ul>
<blockquote>
<p>注意：本地必须随机初始化pivot元素，否则通过时间会很慢，因为测试中有极端用例。</p>
</blockquote>
<ol type="1">
<li>为了应对极端测试用例，使得递归树加深，可以在循环一开始的时候，随机交换第1个元素与它后面的任意1个元素的位置；</li>
</ol>
<p>说明：最极端的是顺序数组与倒序数组，此时递归树画出来是链表，时间复杂度退化为O(N^2)，根本达不到减治的效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">nums, l, r</span>):</span></span><br><span class="line">    rand = random.randint(l, r)</span><br><span class="line">    nums[r], nums[rand] = nums[rand], nums[r]</span><br><span class="line">    pivot = r</span><br><span class="line">    right = l</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[pivot]:</span><br><span class="line">            nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">    nums[right], nums[pivot] = nums[pivot], nums[right]</span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用双指针，将与pivot相等的元素等概率地分到pivot最终排定位置的两边。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">nums, l, r</span>):</span></span><br><span class="line">    <span class="comment"># randint 是包括左右区间的</span></span><br><span class="line">    random_index = random.randint(l, r)</span><br><span class="line">    nums[random_index], nums[l] = nums[l], nums[random_index]</span><br><span class="line"></span><br><span class="line">    pivot = nums[l]</span><br><span class="line"></span><br><span class="line">    lt = l + <span class="number">1</span></span><br><span class="line">    rt = r</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> lt &lt;= rt <span class="keyword">and</span> nums[lt] &lt; pivot:</span><br><span class="line">            lt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lt &lt;= rt <span class="keyword">and</span> nums[rt] &gt; pivot:</span><br><span class="line">            rt -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> lt &gt; rt:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        nums[lt], nums[rt] = nums[rt], nums[lt]</span><br><span class="line">        lt += <span class="number">1</span></span><br><span class="line">        rt -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    nums[l], nums[rt] = nums[rt], nums[l]</span><br><span class="line">    <span class="keyword">return</span> rt</span><br></pre></td></tr></table></figure>
<p>完整快速选择实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">nums, l, r</span>):</span></span><br><span class="line">            pivot = r</span><br><span class="line">            rand = random.randint(l, r)</span><br><span class="line">            nums[pivot], nums[rand] = nums[rand], nums[pivot]</span><br><span class="line">            right = l</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt;= nums[pivot]:</span><br><span class="line">                    nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">            nums[right], nums[pivot] = nums[pivot], nums[right]</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            pivot = partition(nums, l, r)</span><br><span class="line">            <span class="keyword">if</span> pivot == len(nums) - k:</span><br><span class="line">                <span class="keyword">return</span> nums[pivot]</span><br><span class="line">            <span class="keyword">if</span> pivot &lt; len(nums) - k:</span><br><span class="line">                l = pivot + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = pivot - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>优先队列、堆</li>
</ol>
<p>优先队列的想法是很朴素的。</p>
<p>我们可以维护大小为K的一个小顶堆：</p>
<ol type="1">
<li>如果当前堆不满，直接添加；</li>
<li>堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，大于堆顶，我们pop堆顶元素，插入新到的元素，让堆自己去调整内部结构。</li>
</ol>
<blockquote>
<p>说明：这里最合适的操作其实是replace，即直接把新读进来的数放在堆顶，然后执行下沉操作（siftDown）操作。python中有heapq.heappushpop()操作。Java中的PriorityQueue没有提供这个操作，只好先poll()再offer()。</p>
</blockquote>
<p>堆的写法有很多，以下的写法大同小异，没有本质差别。</p>
<p>假设数组有len个元素。</p>
<p>思路1：把len个元素都放入一个小顶堆堆中，然后在pop()出len-k个元素，此时小顶堆只剩下k个元素，堆顶元素就是数组的第k大元素。</p>
<p>思路2：把len个元素都放入一个大顶堆中，然后再pop出k-1个元素，因此前k-1大的元素都被弹出了，此时大顶堆的堆顶元素就是数组中的第k个最大元素。</p>
<p>下面给出第2中思路的实现，这里改变了原数组，如果不能改变原数组，我们要另外使用堆的空间，可以为k规模的大小，也可以为len规模的大小。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxheap</span>(<span class="params">a, i, size</span>):</span></span><br><span class="line">            l = i * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            r = i * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">            large = i</span><br><span class="line">            <span class="keyword">if</span> l &lt; size <span class="keyword">and</span> a[l] &gt; a[large]:</span><br><span class="line">                large = l</span><br><span class="line">            <span class="keyword">if</span> r &lt; size <span class="keyword">and</span> a[r] &gt; a[large]:</span><br><span class="line">                large = r</span><br><span class="line">            <span class="keyword">if</span> large != i:</span><br><span class="line">                nums[i], nums[large] = nums[large], nums[i]</span><br><span class="line">                maxheap(a, large, size)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buildheap</span>(<span class="params">a, size</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size &gt;&gt; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                maxheap(a, i, size)</span><br><span class="line"></span><br><span class="line">        heapsize = len(nums)</span><br><span class="line">        buildheap(nums, heapsize)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(heapsize - <span class="number">1</span>, heapsize - k, <span class="number">-1</span>):</span><br><span class="line">            nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">            heapsize -= <span class="number">1</span></span><br><span class="line">            maxheap(nums, <span class="number">0</span>, heapsize)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="考察点">考察点</h2>
<p>这道题目考查了快速选择（快速切分）操作的特性，时间复杂度的了解，和随机化保证时间复杂度不会退化得过于严重。</p>
<p>堆的解法考查了堆化、插入、和删除的代码写法，是非常好的面试题目。</p>
<h2 id="参考">参考</h2>
<p>https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/</p>
]]></content>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 23.合并K个排序链表</title>
    <url>/2020/08/11/leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<p>输入: [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6] 输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<p>是工业界很常见的一种操作，比如分布式系统中、数据库中，我们有多个索引是有序的，且在多个小文件中存储，我们要合并成一个新的有序链表。我们可以有哪些想法呢。</p>
<p>最暴力的解法是，每次遍历所有链表，找到最小的链表头，将结果链表的下一个指针指向该链表头，然后链表头指向其下一个节点。</p>
<ul>
<li>时间复杂度：找最小的链表头O(k)，假设链表平均长度n，要找O(nk)次，总体是O(k^2n)的。</li>
<li>空间复杂度：O(1)，不使用额外空间</li>
</ul>
<p>对于我来说最直接的想法是，建一个dummy哨兵链表节点，用cur指针指向dummy，同时观察所有链表的头部元素，选出最小的一个，将cur.next指向这个链表头，这个链表如果next不为Null，就加入这个链表头的集合中，否则就不加入，然后令cur=cur.next。这样加入我们共有K个链表，那么我们的集合就是K这么大，这样插入一个元素，每次删除其中最小元素都很高效的数据结构是堆。</p>
<ul>
<li>总的时间复杂度就是O(k*n*logk)。因为我们一共要插入和删除K次。</li>
<li>空间复杂度：O(K)，我们要使用一个K大小的堆。</li>
</ul>
<p>另一种想法用分治的方法进行合并。我们</p>
<ul>
<li>将k个链表配对，将一对中的链表合并。</li>
<li>第一轮合并以后，k个链表被合并成了k/2个链表，平均长度为2n/k，然后是k/4个链表，k/8个链表等等。</li>
<li>重复这一过程，直到我们得到了最终的有序链表。</li>
</ul>
<p>我们来分析一下复杂度：</p>
<ul>
<li>时间复杂度：我们知道合并两个有序链表，等于两个链表长度的和，所以是O(2n)，要合并k/2个，之后合并k/4个链表，合并时间复杂度是O(4n)，所以最终的时间复杂度还是O(n k log(k)) 。</li>
<li>空间复杂度：我们归并要使用递归，递归的深度为logk，所以我们要使用O(logk)的栈空间。</li>
</ul>
<h2 id="示例代码">示例代码</h2>
<p>使用堆合并</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="comment"># 这里的i为了排序</span></span><br><span class="line">        heap = [(l.val, i, l) <span class="keyword">for</span> i, l <span class="keyword">in</span> enumerate(lists) <span class="keyword">if</span> l]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            val, ind, l = heapq.heappop(heap)</span><br><span class="line">            cur.next = l</span><br><span class="line">            <span class="keyword">if</span> l.next:</span><br><span class="line">                l = l.next</span><br><span class="line">                heapq.heappush(heap, (l.val, ind, l))</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<p>分支合并</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        n = len(lists)</span><br><span class="line">        <span class="keyword">return</span> self.merge(lists, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, lists, l, r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">            <span class="keyword">return</span> lists[l]</span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        l1 = self.merge(lists, l, mid)</span><br><span class="line">        l2 = self.merge(lists, mid + <span class="number">1</span>, r)</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(l1, l2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        dummy = cur = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 329.矩阵中的最长递增路径</title>
    <url>/2020/08/01/leetcode-329-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix</p>
<p>给定一个整数矩阵，找出最长递增路径的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p>
<p>示例 1:</p>
<p>输入: nums = [ [9,9,4], [6,6,8], [2,1,1]] 输出: 4 解释: 最长递增路径为 [1, 2, 6, 9]。 示例 2:</p>
<p>输入: nums = [ [3,4,5], [3,2,6], [2,2,1]] 输出: 4 解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</p>
<h2 id="思路">思路</h2>
<p>我们可以对每一个点求出最长递增路径的长度，这样当相邻的点比该点小的时候，我们将该点的最长递增路径的长度加1，就是这个相邻点的最长递增路径的可能值。</p>
<p>这里面一定不会有重复访问的现象，因为是最长递增路径，不存在相同的值，我们可以放心的使用其他点已经求出的最长递增路径。</p>
<p>那么这个函数的参数也就出来了，dfs(i, j)。i，j表示是哪个点，函数求出的结果是这点为起始的最长递增路径长度。这个函数怎么求呢？首先自身就是一条路径，也就是最少是1。然后我们往四个方向扩散，这里判断越界，并且要确定这四个方向的值比当前大，否则不能扩散，假设我们已经求出了其他几个方向（小于等于四）的最长递增路径，这些方向上的点的值都是比当前大的，那么这个点的最长递增路径长度就是，这几个方向的最长递增路径的最大值加1，最终要和1比较一下更大，因为可能所有方向的值都小于等于当前。</p>
<p>最终我们可以加上记忆化，因为我们一旦算出来i，j的最长递增路径的长度之后，我们就可以重复的使用它，不会改变了。这可以节省时间。</p>
<h2 id="示例代码">示例代码</h2>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingPath</span>(<span class="params">self, matrix: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        h, w = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">return</span> memo[i, j]</span><br><span class="line">            memo[i, j] = <span class="number">1</span></span><br><span class="line">            cur = matrix[i][j]</span><br><span class="line">            <span class="keyword">for</span> di, dj <span class="keyword">in</span> ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>)):</span><br><span class="line">                _i, _j = i + di, j + dj</span><br><span class="line">                <span class="keyword">if</span> <span class="number">-1</span> &lt; _i &lt; h <span class="keyword">and</span> <span class="number">-1</span> &lt; _j &lt; w \</span><br><span class="line">                        <span class="keyword">and</span> matrix[_i][_j] &gt; cur:</span><br><span class="line">                    memo[i, j] = max(memo[i, j], <span class="number">1</span> + dfs(_i, _j))</span><br><span class="line">            <span class="keyword">return</span> memo[i, j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(dfs(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(h) <span class="keyword">for</span> j <span class="keyword">in</span> range(w))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优化空间使用矩阵来记忆化搜索：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingPath</span>(<span class="params">self, matrix: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        h, w = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        memo = [[<span class="number">0</span>] * w <span class="keyword">for</span> _ <span class="keyword">in</span> range(h)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> memo[i][j]:</span><br><span class="line">                <span class="keyword">return</span> memo[i][j]</span><br><span class="line">            memo[i][j] = <span class="number">1</span></span><br><span class="line">            cur = matrix[i][j]</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>)):</span><br><span class="line">                _i, _j = i + dx, j + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">-1</span> &lt; _i &lt; h <span class="keyword">and</span> <span class="number">-1</span> &lt; _j &lt; w \</span><br><span class="line">                        <span class="keyword">and</span> matrix[_i][_j] &gt; cur:</span><br><span class="line">                    memo[i][j] = max(memo[i][j], <span class="number">1</span> + dfs(_i, _j))</span><br><span class="line">            <span class="keyword">return</span> memo[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(dfs(i, j) <span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(range(h), range(w)))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 34.在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/08/10/leetcode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<ol start="34" type="1">
<li>在排序数组中查找元素的第一个和最后一个位置</li>
</ol>
<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure>
<h2 id="思路">思路</h2>
<p>这道题目当然可以给找左边界和右边界各写一个二分查找代码，因为比较简单就不写了。我们来看一下如何用一段代码找到临界索引。</p>
<p>我们有几个前提条件</p>
<ol type="1">
<li>数组中可能不出现该值。</li>
<li>数组中可能有重复元素。</li>
</ol>
<p>我们来分析一下：</p>
<ol type="1">
<li><p>对于一个元素，我们如果以插入的视角来看的话，这个元素有n+1个插入位置，对应的索引分别是0，1，2...，n。</p>
<ol type="1">
<li>如果我们插入的位置，左边都小于该元素，右边都大于等于该元素，那么插入位置的索引，就是第一个大于等于该元素的索引；</li>
<li>如果我们插入的位置，左边都小于等于该元素，右边都大于该元素，那么插入位置的索引，就是第一个大于该元素的索引，而这个索引减1，就是最后一个小于等于该元素的索引。</li>
</ol></li>
<li><p>由于数组中可能不存在该值，我们第一步求得第一个大于等于该元素的索引，</p>
<ol type="1">
<li>可能为n，也就是说数组中没有大于等于该值的元素</li>
<li>可能该索引对应的值不是等于该值，而是大于该值</li>
</ol>
<p>在这两种情况下，我们就不用再继续求右边的边界了。直接返回-1，-1</p></li>
<li><p>这两种情况，仅仅是对于nums[mid] == target时，采取的策略不同，我们可以用一个参数控制不同的表现</p></li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums, target, left</span>):</span></span><br><span class="line">      l, r = <span class="number">0</span>, len(nums)</span><br><span class="line">       <span class="keyword">while</span> l &lt; r:</span><br><span class="line">              mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; target <span class="keyword">or</span> (left <span class="keyword">and</span> nums[mid] == target):</span><br><span class="line">                        r = mid</span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                        l = mid + <span class="number">1</span></span><br><span class="line">       <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<p>这里返回的就是右侧集合的开始位置的下标。</p>
<h2 id="示例代码">示例代码</h2>
<p>这道题的解法如下，加上了不在数组的判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums, target, left</span>):</span></span><br><span class="line">            l, r = <span class="number">0</span>, len(nums)</span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; target <span class="keyword">or</span> (left <span class="keyword">and</span> nums[mid] == target):</span><br><span class="line">                    r = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">        left = binary_search(nums, target, <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> left == len(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> [left, binary_search(nums, target, <span class="literal">False</span>) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 363.矩形区域不超过K的最大数值和，通过此题好好了解前缀和的各种应用和变化</title>
    <url>/2020/08/10/leetcode-363-%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87K%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C%EF%BC%8C%E9%80%9A%E8%BF%87%E6%AD%A4%E9%A2%98%E5%A5%BD%E5%A5%BD%E4%BA%86%E8%A7%A3%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E5%90%84%E7%A7%8D%E5%BA%94%E7%94%A8%E5%92%8C%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定一个非空二维矩阵 matrix 和一个整数 k，找到这个矩阵内部不大于 k 的最大矩形和。</p>
<p>示例:</p>
<p>输入: matrix = [[1,0,1],[0,-2,3]], k = 2 输出: 2 解释: 矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。 说明：</p>
<p>矩阵内的矩形区域面积必须大于 0。 如果行数远大于列数，你将如何解答呢？</p>
<h2 id="思路">思路</h2>
<p>这道题目的思路是固定左右边界，对行进行前缀和和二分查找。</p>
<p>我们知道，前缀和可以让我们O(1)的时间复杂度知道任何区间和。</p>
<p>前缀和的典型构建方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pre = [<span class="number">0</span>]</span><br><span class="line">p = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">    p += n</span><br><span class="line">    pre.append(p)</span><br></pre></td></tr></table></figure>
<p>比如我们想知道i,j之间的区间和，包括i，j索引的话，我们的方法是pre[j+1] - pre[i]。</p>
<p>通过前缀和的变种，我们可以解决一些新的问题。</p>
<p>我们将前缀和变成hash set，就可以快速判断是否有一个区间和等于target。</p>
<p>我们可以插入排序的方法替换掉单纯的append，使前缀和有序，这样就可以用二分查找找到最接近某个target的区间和。</p>
<p>这道题目就利用了第二种想法。</p>
<p>我们固定左右边界，left和right，先将left到right之间的每一行的所有数值累加。这样我们就有了一列数。通过固定所有这样的left和right我们也就枚举了矩形所有的左边界和右边界。接着我们用第二种方法，边构建前缀和，编计算最接近target的矩形面积。</p>
<p>其大致代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pre = [<span class="number">0</span>]</span><br><span class="line">p = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> total:</span><br><span class="line">    p += r</span><br><span class="line">    loc = bisect.bisect_left(pre, p - k)</span><br><span class="line">    <span class="keyword">if</span> loc != len(pre):</span><br><span class="line">        res = max(res, p - pre[loc])</span><br><span class="line">    bisect.insort(pre, p)</span><br></pre></td></tr></table></figure>
<p>有了这段代码，再加上我们固定左右边界的代码，我们就可以解决这个问题。计算一下复杂度。</p>
<p>固定左右边界需要O(n^2)的时间复杂度，n为矩形的列数。生成前缀和遍历需要O(m)，m为矩阵的行数，搜索是O(logm)的，但是插入是O(m)的。所以总体上还是O(n^2m^2)的。但是常数项比较低。</p>
<h2 id="总体代码如下">总体代码如下</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumSubmatrix</span>(<span class="params">self, matrix: List[List[int]], k: int</span>) -&gt; int:</span></span><br><span class="line">        m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        total = [<span class="number">0</span>] * m</span><br><span class="line">        res = float(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> left <span class="keyword">in</span> range(n):</span><br><span class="line">            total[:] = [<span class="number">0</span>] * m</span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> range(left, n):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                    total[i] += matrix[i][right]</span><br><span class="line">                pre = [<span class="number">0</span>]</span><br><span class="line">                p = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> total:</span><br><span class="line">                    p += r</span><br><span class="line">                    loc = bisect.bisect_left(pre, p - k)</span><br><span class="line">                    <span class="keyword">if</span> loc != len(pre):</span><br><span class="line">                        res = max(res, p - pre[loc])</span><br><span class="line">                    bisect.insort(pre, p)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="另一道相似题目">另一道相似题目</h2>
<ol start="1546" type="1">
<li>和为目标值的最大数目不重叠非空子数组数目</li>
</ol>
<p>给你一个数组 nums 和一个整数 target 。</p>
<p>请你返回 非空不重叠 子数组的最大数目，且每个子数组中数字和都为 target 。</p>
<p>示例 1：</p>
<p>输入：nums = [1,1,1,1,1], target = 2 输出：2 解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 。 示例 2：</p>
<p>输入：nums = [-1,3,5,1,4,2,-9], target = 6 输出：2 解释：总共有 3 个子数组和为 6 。 ([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。 示例 3：</p>
<p>输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10 输出：3 示例 4：</p>
<p>输入：nums = [0,0,0], target = 0 输出：3</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 0 &lt;= target &lt;= 10^6</p>
<p>这道题目就是使用了第一种前缀和的变化，并应用了贪心的思想。</p>
<p>一旦发现target在区间和中，我们就重新统计前缀和。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNonOverlapping</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; int:</span></span><br><span class="line">        pre = &#123;<span class="number">0</span>&#125;</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            p += n</span><br><span class="line">            <span class="keyword">if</span> p - target <span class="keyword">in</span> pre:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                pre = &#123;<span class="number">0</span>&#125;</span><br><span class="line">                p = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.add(p)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 41.缺失的第一个正数</title>
    <url>/2020/08/06/leetcode-41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h3 id="leetcode-41-缺失的第一个正数">leetcode 41 缺失的第一个正数</h3>
<h3 id="问题描述">问题描述</h3>
<p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<p>示例 1:</p>
<p>输入: [1,2,0] 输出: 3 示例 2:</p>
<p>输入: [3,4,-1,1] 输出: 2 示例 3:</p>
<p>输入: [7,8,9,11,12] 输出: 1</p>
<p>提示：</p>
<p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p>
<h3 id="思路">思路</h3>
<p>这道题目和不使用任何额外空间的计数排序很像，因为都对时空复杂度做了严格的限制，我们都不得不改变原数组，设法将其改为我们能够利用的数据结构。否则这两道题目都无法有「真正」的解。不使用额外空间计数排序的那道题目规定数组的元素有一定的范围，我们可以利用32位整数的前16位计数，最终输出计数排序的结果。</p>
<p>这道题目我们要利用，关心的只有[1, N]之间的数，其他的数字我们其实并不关心，这作为前提。</p>
<h3 id="算法">算法</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果本题没有额外的时空复杂度要求，那么就很容易实现：</span></span><br><span class="line"><span class="comment"># 1. 我们可以将数组所有的数放入哈希表，随后从1开始依次枚举正整数，并判断其是否在哈希表中；</span></span><br><span class="line"><span class="comment"># 2. 我们可以从1开始依次枚举正整数，并遍历数组，判断其是否在数组中</span></span><br><span class="line"><span class="comment"># 如果数组的长度为N，那么第一种做法的时间复杂度为O(N)，空间复杂度为O(N)；</span></span><br><span class="line"><span class="comment"># 第二种做法的时间复杂度为O(N^2)，空间复杂度为O(1)。</span></span><br><span class="line"><span class="comment"># 「真正」满足此要求的算法是不存在的。但是我们可以退而求其次：利用给定数组中的空间来存储一些状态。</span></span><br><span class="line"><span class="comment"># 也就是说，如果题目给定的数组是不可修改的，那么就不存在满足时空复杂度要求的算法；</span></span><br><span class="line"><span class="comment"># 但如果我们可以修改给定的数组，那么是存在满足要求的算法的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一.哈希表</span></span><br><span class="line"><span class="comment"># 对于「前言」中提到的第一种做法</span></span><br><span class="line"><span class="comment"># 我们可以将数组所有的数放入哈希表，随后从1开始依次枚举正整数，并判断其是否在哈希表中；</span></span><br><span class="line"><span class="comment"># 仔细想一想，我们为什么要使用哈希表？这是因为哈希表是一个可以支持快速查找的数据结构：</span></span><br><span class="line"><span class="comment"># 给定一个元素，我们可以在O(1)的时间查找给元素是否在哈希表中。</span></span><br><span class="line"><span class="comment"># 因此，我们可以考虑将给定的数组设计成哈希表的「替代产品」。</span></span><br><span class="line"><span class="comment"># 实际上，对于一个长度为N的数组，其中更没有出现的最小正整数只能在[1, N+1]中。</span></span><br><span class="line"><span class="comment"># 这是因为如果[1,N]都出现了，那么答案是N+1，否则答案是[1, N]中没有出现的最小正整数。</span></span><br><span class="line"><span class="comment"># 这样一来，我们将所有在[1,N]范围内的数放入哈希表，也可以得到最终的答案。</span></span><br><span class="line"><span class="comment"># 而给定的数组恰好长度为N，这让我们有了一种将数组设计成哈希表的思路。</span></span><br><span class="line"><span class="comment"># 我们对数组进行遍历，对于遍历到的数x，如果它在[1,N]的范围内，那么就将数组的中的</span></span><br><span class="line"><span class="comment"># 第x-1个位置（注意：数组下标从0开始）打上『标记』。</span></span><br><span class="line"><span class="comment"># 在遍历结束后，如果所有的位置都打上了标记，那么答案是N+1，</span></span><br><span class="line"><span class="comment"># 否则答案是最小的没有打上标记的位置加1.</span></span><br><span class="line"><span class="comment"># 那么如何设计这个『标记』呢？由于数组中的数没有任何限制，因此这并不是一件很容易的事情。</span></span><br><span class="line"><span class="comment"># 但我们可以继续利用上面提到的性质：由于我们只在意[1,N]中的数</span></span><br><span class="line"><span class="comment"># 因此我们可以先对数组进行遍历，把不在[1,N]范围内的数修改成任意一个大于N的数（例如N+1）</span></span><br><span class="line"><span class="comment"># 这样一来，数组中的所有数就都是正数了，因此我们就可以将「标记」表示为「负号」。算法的流程如下</span></span><br><span class="line"><span class="comment"># 我们将数组中所有小于等于0的数修改成N+1</span></span><br><span class="line"><span class="comment"># 我们遍历数组中的每一个数x，它可能已经被打了标记，因此原本对应的数|x|，其中||为绝对值符号。</span></span><br><span class="line"><span class="comment"># 如果|x|∈[1,N]，那么我们给数组中的第|x|-1个位置添加一个负号。</span></span><br><span class="line"><span class="comment"># 注意如果它已经有负号，不需要重复添加；</span></span><br><span class="line"><span class="comment"># 在遍历完成之后，如果数组中的每一个数都是负数，那么答案是N+1，否则答案是第一个正数的位置加1.</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，遍历3次数组</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span>:</span><br><span class="line">                nums[i] = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            x = abs(nums[i])</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; x &lt;= n:</span><br><span class="line">                nums[x - <span class="number">1</span>] = nums[x - <span class="number">1</span>] <span class="keyword">if</span> nums[x - <span class="number">1</span>] &lt; <span class="number">0</span> <span class="keyword">else</span> -nums[x - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了打标记之外，我们哈可以使用置换的方法，将给定的数组「恢复」成下面的形式：</span></span><br><span class="line"><span class="comment"># 如果数组中包含x∈[1,N]，那么恢复后，数组的第x-1和元素为x。</span></span><br><span class="line"><span class="comment"># 在恢复后，数组应当有[1,2,...,N]的形式，但其中有若干个位置上的数是错误的</span></span><br><span class="line"><span class="comment"># 每一个错误的位置就代表一个缺失的正数。以题目中的示例2[3,4,-1,1]为例，</span></span><br><span class="line"><span class="comment"># 恢复后的数组应当为[1,-1,3,4]，我们就可以知道缺失的数为2.</span></span><br><span class="line"><span class="comment"># 那么我们如何将数组进行恢复呢？我们可以对数组进行一次遍历吗，对于遍历到的数x=nums[i]，</span></span><br><span class="line"><span class="comment"># 如果x∈[1, N]，我们就知道x应当出现在数组中的x-1的位置，因此交换nums[i]和nums[x-1]，</span></span><br><span class="line"><span class="comment"># 这样x就出现在了正确的位置。在完成交换之后，新的nums[i]可能还在[1,N]的范围内，</span></span><br><span class="line"><span class="comment"># 我们需要继续进行交换操作，直到x∉[1,N].</span></span><br><span class="line"><span class="comment"># 注意到上面的方法可能会陷入死循环，如果nums[i]恰好与nums[x-1]相等，那么就会无限交换下去。</span></span><br><span class="line"><span class="comment"># 此时我们有nums[i] = x = nums[x-1]，说明x已经出现在了正确的位置。</span></span><br><span class="line"><span class="comment"># 因此我们可以跳出循环，开始遍历下一个数。</span></span><br><span class="line"><span class="comment"># 由于每次的交换操作都会使得某一个数交换到正确的位置，因此交换的次数最多为N，</span></span><br><span class="line"><span class="comment"># 整个方法的时间复杂度为O(N)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt; nums[i] &lt;= n <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]:</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>], nums[i] = nums[i], nums[nums[i] - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 818.赛车</title>
    <url>/2020/08/12/leetcode-818-%E8%B5%9B%E8%BD%A6/</url>
    <content><![CDATA[<h2 id="示例解法">示例解法</h2>
<p>这道题目的dp要仔细分析。分析过程写在了注释中（个人习惯…）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们来分析这个问题</span></span><br><span class="line"><span class="comment"># 我们定义f(i)为距离终点为i时所需的指令大小</span></span><br><span class="line"><span class="comment"># 如果i == 2 ** n - 1，指令的长度就为n</span></span><br><span class="line"><span class="comment"># 如果i != 2 ** n - 1，我们有两种走法</span></span><br><span class="line"><span class="comment"># 假设 2**(n-1) -1 &lt; i &lt; 2 **n - 1</span></span><br><span class="line"><span class="comment"># 这样n就等于i的bit_length</span></span><br><span class="line"><span class="comment"># 一种是走到 j = 2 ** n - 1</span></span><br><span class="line"><span class="comment"># 我们的指令是A^nR，指令长度为n+1，我们到终点的距离是 j-i，一定小于i</span></span><br><span class="line"><span class="comment"># 一种是走到 j = 2 ** (n-1) - 1, j &lt; i</span></span><br><span class="line"><span class="comment"># 然后我们又往回走了 p = 2 ** k - 1, 现在我们的位置是 2 ** (n-1) - 2 ** k</span></span><br><span class="line"><span class="comment"># 指令长度是 A^(n-1)RA^kR n+k+1，我们现在距离终点 i - 2 **(n-1) + 2 ** k ,是小于i的</span></span><br><span class="line"><span class="comment"># 这样我们就得出了我们的递推公式</span></span><br><span class="line"><span class="comment"># f(i) = n if i == 2 ** n - 1</span></span><br><span class="line"><span class="comment"># f(i) = min(f(2**n -1 - i)+n+1, f(i-2**(n-1)+2**k)+n+k+1 k &lt; n-1)</span></span><br><span class="line"><span class="comment"># 初始化和边界条件f(0) = 0，注意向会回走的k不会大于等于n-1，因为等于n-1时就走到0了</span></span><br><span class="line"><span class="comment"># 返回值f(target)</span></span><br><span class="line"><span class="comment"># 优化复杂度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">racecar</span>(<span class="params">self, target: int</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] + [float(<span class="string">&#x27;inf&#x27;</span>)] * target</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">            n = i.bit_length()</span><br><span class="line">            <span class="keyword">if</span> i == (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>:</span><br><span class="line">                dp[i] = n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> - i] + n + <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">                    dp[i] = min(dp[i],</span><br><span class="line">                                dp[i - (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)) + (<span class="number">1</span> &lt;&lt; k)] + n + k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title>__new__和__init__的区别</title>
    <url>/2020/08/27/new-%E5%92%8C-init-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>先上代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;class.__new__ called&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> super(Student, cls).__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, height</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;class.__init__ called&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.height = height</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The height of Student %s if %s&quot;</span> % (self.name, self.height)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    xiaoming = Student(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="number">175</span>)</span><br><span class="line">    print(xiaoming)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>其中，<strong>new</strong>()不是一定要有，只有继承自object的类才有，该方法可以return父类（通过super(当前类名, cls).__new__())出来的实例，或者直接是object的__new__出来的实例。值得注意的是，在定义子类时没有重新定义__new__()时，Python默认调用该类父类的__new__()方法来构造该类实例，如果该类父类也没有重写__new__()，那么将一直追溯至object的__new__()方法，因为object是所有新式类的基类。如果子类中重写了__new__()方法，那么可以自由选择任意一个其他的新式类。</p>
<p>可见，当类中同时出现__new__()和__init__()时，先调用__new__，再调用__init__()，具体的执行过程为：</p>
<ol type="1">
<li>调用实例对象代码xiaoming = Student('xiaoming', 175);</li>
<li>传入name和height的参数，执行Student类的__new__()方法，该方法返回一个类的实例，通常会用父类super(Student, cls).__new__(cls)，<strong>new</strong>()产生的实例即__init__()的self；</li>
<li>用实例来调用__init__()方法，进行初始化实例对象的操作。</li>
</ol>
<p>可以看到，python中__new__()与__init__()的区别，</p>
<ol type="1">
<li>首先用法不同，<strong>new</strong>()用于创建实例，所以该方法是在实例创建之前被调用，它是类级别的方法，是个静态方法； 而__init__()用于初始化实例，所以该方法是在实例对象创建后被调用，它是实例级别的方法，用于设置对象属性的一些初始值。 由此可知，<strong>new</strong>()在__init__()之前被调用。如果__new__()创建的是当前类的实例，会自动调用__init__()，通过return调用的__new__()的参数cls来保证是当前类实例，如果是其他类的类名，那么创建返回的是其他类实例，就不会调用当前类的__init__()函数。</li>
<li>其次传入参数不同 <strong>new</strong>()至少有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别； <strong>init</strong>()至少有一个参数self，就是这个__new__返回的实例，<strong>init</strong>()在__new__()的基础上完成一些初始化的操作。</li>
<li>返回值不同 <strong>new</strong>()必须有返回值，返回实例对象； <strong>init</strong>()不需要有返回值。 另外谈谈__new__()的作用，<strong>new</strong>()方法主要用于继承一些不可变的class，比如int，str, tuple，提供一个自定义这些类的实例化过程的途径，一般通过重载__new__()的方法来实现。代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositiveInteger</span>(<span class="params">int</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, value</span>):</span></span><br><span class="line">        <span class="keyword">return</span> super(PositiveInteger, cls).__new__(cls, abs(value))</span><br><span class="line"></span><br><span class="line">a = PositiveInteger(<span class="number">-10</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>另外，<strong>new</strong>()方法还可以用来实现单例模式，也就是使每次实例化时只返回同一个实例对象。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用__new__实现python单例模式.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params">object</span>):</span></span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            <span class="keyword">with</span> Singleton._instance_lock:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> hasattr(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">                    Singleton._instance = object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    obj1 = Singleton()</span><br><span class="line">    obj2 = Singleton()</span><br><span class="line">    obj1.attr = <span class="string">&#x27;value1&#x27;</span></span><br><span class="line">    print(obj1.attr, obj2.attr)</span><br><span class="line">    print(obj1 <span class="keyword">is</span> obj2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3>
<ol type="1">
<li>实现单例模式的几种方式，new方式推荐使用，<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaHVjaG9uZy9wLzgyNDQyNzkuaHRtbCNfbGFiMl8xXzM=">链接<i class="fa fa-external-link-alt"></i></span></li>
<li>new 和 init 的区别，<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamF5bGl1L3AvOTAxMzE1NS5odG1s">链接<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现Trie(字典树、前缀树)</title>
    <url>/2020/07/20/python%E5%AE%9E%E7%8E%B0Trie-%E5%AD%97%E5%85%B8%E6%A0%91%E3%80%81%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<h2 id="wiki-百科上的介绍">wiki 百科上的介绍：</h2>
<p>Trie，字典树，也叫前缀树。是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，尔根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和比分内部节点所对应的键才有相关的值。</p>
<h2 id="应用">应用：</h2>
<p>trie常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<h2 id="要实现的方法">要实现的方法</h2>
<p>一般来讲trie要实现这么几个方法</p>
<ul>
<li>插入一个单词insert(word: str) -&gt; None</li>
<li>查找一个单词是否在trie中search(word:str) -&gt; bool</li>
<li>查找一个前缀是否在trie中startsWith(prefix:str) -&gt; bool</li>
</ul>
<h3 id="leetcode上的208题实现trie">leetcode上的208题<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXRyaWUtcHJlZml4LXRyZWUv">实现trie<i class="fa fa-external-link-alt"></i></span></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line">        self.end_of_word = <span class="string">&#x27;#&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: str</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            node = node.setdefault(char, &#123;&#125;)</span><br><span class="line">        node[self.end_of_word] = self.end_of_word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: str</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node[char]</span><br><span class="line">        <span class="keyword">return</span> self.end_of_word <span class="keyword">in</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix: str</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node[char]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>通常情况下没有必要使用一个trie node表示一个trie的节点，存入hash表和是否是结尾。结尾可以用一个特殊字符代替，判断这个字符是否在hash表中。这样每一个节点其实都是一个hash表。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现并查集</title>
    <url>/2020/07/15/python%E5%AE%9E%E7%8E%B0%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="python实现并查集">python实现并查集</h1>
<h2 id="并查集概念">并查集概念</h2>
<p>并查集（UnionFind）也被称为不相交集数据结构。顾名思义，并查集主要操作是合并与查询，它是把初始不相交的集合经过多次合并操作后合并为一个大集合，然后可以通过查询判断两个元素是否已经在同一个集合中了。</p>
<p>并查集的应用场景一般就是动态连通性的判断，例如判断网络中的两台电脑是否连通，在程序中判断两个变量名是否指向同一内存地址等。</p>
<h2 id="并查集的实现">并查集的实现</h2>
<h3 id="并查集的存储结构">并查集的存储结构</h3>
<p>并查集逻辑上是森林，我们可以选出一个根结点作为代表，其他子结点指向根结点表示都在同一片森林中。在这里，并不关心结点的子结点是谁，只关心父结点是谁，所以物理上可以简单用python的列表来表示并查集，列表的下标表示结点，列表元素的值表示父结点。</p>
<h3 id="并查集的api">并查集的API</h3>
<p>根据并查集的特性，可以设计以下api</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>(<span class="params">object</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;并查集&quot;&quot;&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;长度为n的并查集&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, p</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;查找p的根结点（祖先）&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;连通p,q 让q指向p&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;判断pq是否已经连通&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="并查集的初始化">并查集的初始化</h3>
<p>并查集的初始化有几种，无非就是用一种特殊的方式来表示初始的每一个元素都不相交，等待后续的合并操作。</p>
<p>第一种初始化的方式是用列表的下标初始化对应位置的值，当一个并查集S[i] == i时则判断它自己就是根结点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;长度为n的并查集&quot;&quot;&quot;</span></span><br><span class="line">  self.uf = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]      <span class="comment"># 列表为0位置空出</span></span><br><span class="line">  self.sets_count = n                                      <span class="comment"># 判断并查集里共有几个集合，初始化默认互相独立</span></span><br></pre></td></tr></table></figure>
<p>第二种初始化方式将列表每一个结点初始化为-1，列表的节点值为负数表示它自己就是根结点，这样做还有一个好处可以用-n表示自己的子结点数量，下面的按规模优化中可以让结点数量小的树并到结点多的树上，提高find操作的效率。我们就选用这种方式来初始化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;长度为n的并查集&quot;&quot;&quot;</span></span><br><span class="line">  self.uf = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="comment"># 列表0位置空出</span></span><br><span class="line">  self.sets_count = n                                       <span class="comment"># 判断并查集里共有几个集合，初始化默认互相独立</span></span><br></pre></td></tr></table></figure>
<h3 id="并查集的查询">并查集的查询</h3>
<p>查询操作是查找某个结点所在的集合，返回该集合的根结点，即返回列表的下标。下面是一种简单的查询，代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, p</span>):</span></span><br><span class="line">  <span class="keyword">while</span> self.uf[p] &gt;= <span class="number">0</span>:</span><br><span class="line">    p = self.yf[p]</span><br><span class="line">  <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
<p>可以很清楚的看出上面的方法很简单，找到结点元素值为负的表示找到了根结点并返回，但是该种方法在极端情况下（由树退化为链表）效率不高，查找的效率为O(n)，如左下图所示</p>
<img data-src="/2020/07/15/python%E5%AE%9E%E7%8E%B0%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B9%B6%E6%9F%A5%E9%9B%861.png" class>
<img data-src="/2020/07/15/python%E5%AE%9E%E7%8E%B0%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B9%B6%E6%9F%A5%E9%9B%862.png" class>
<p>查询是并查集的核心操作之一，它的效率也决定了整个算法的效率，所以在规模很大的情况下，O(n)的时间的复杂度是不被接受的，那就需要改进，改进的方法就是路径压缩。路径压缩的思想也很简单，就是在查找根结点的过程中，顺便把子结点的父结点改成根结点，这样下次查询的效率只需要O(1)的时间复杂度就可以完成，大大提高了效率。改进后效果图如右上图所示。</p>
<p>路径压缩的find操作可以通过递归来实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, p</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;尾递归&quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">if</span> self.uf[p] &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">  self.uf[p] = self.find(self.uf[p])</span><br><span class="line">  <span class="keyword">return</span> self.uf[p]</span><br></pre></td></tr></table></figure>
<p>可以发现这个递归是尾递归，可以改进成循环的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, p</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;查找p的根节点（祖先）&quot;&quot;&quot;</span></span><br><span class="line">  r = p                                                           <span class="comment"># 初始p</span></span><br><span class="line">  <span class="keyword">while</span> self.uf[p] &gt; <span class="number">0</span>:</span><br><span class="line">    p = self.uf[p]</span><br><span class="line">  <span class="keyword">while</span> r != p:                                           <span class="comment"># 路径压缩，把压缩下来的结点祖先全指向根结点</span></span><br><span class="line">    self.uf[r], r = p, self.uf[r]</span><br><span class="line">  <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
<h3 id="并查集的合并">并查集的合并</h3>
<p>合并两棵树的操作可以简单的规定让右边的树的根结点指向左边树的根结点，示意图如左下图所示。</p>
<img data-src="/2020/07/15/python%E5%AE%9E%E7%8E%B0%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B9%B6%E6%9F%A5%E9%9B%863.png" class>
<img data-src="/2020/07/15/python%E5%AE%9E%E7%8E%B0%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B9%B6%E6%9F%A5%E9%9B%864.png" class>
<p>直接右往左合并的缺点就是当右边的规模大于左边的规模时，在查找时，做路径压缩需要把右边所有的根结点更改为左边的根结点，如右上图所示，这明显有些划不来，所以合并的一种优化方式就是按规模合并，即吧规模小的树往规模大的树上合并。其实还有一种按秩合并（树高度小的往高度大的合并而不改变树的整体高度）。但是这种方法不与路径压缩兼容，因为路径压缩直接改变了数的高度，所以本人选择按规模合并和路径压缩结合的方式优化并查集。代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;连通p, q 让q指向p&quot;&quot;&quot;</span></span><br><span class="line">  proot = self.find(p)</span><br><span class="line">  qroot = self.find(q)</span><br><span class="line">  <span class="keyword">if</span> proot == qroot:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> self.uf[proot] &gt; self.uf[qroot]:     <span class="comment"># 负数比较，左边的规模更小</span></span><br><span class="line">    self.uf[qroot] += self.uf[proot]</span><br><span class="line">    self.uf[proot] = qroot</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    self.uf[proot] += self.uf[qroot]       <span class="comment"># 规模相加</span></span><br><span class="line">    self.uf[qroot] = proot</span><br><span class="line">  self.sets_count -= <span class="number">1</span>                  <span class="comment"># 连通后集合总数减一</span></span><br></pre></td></tr></table></figure>
<h3 id="连通性的判断">连通性的判断</h3>
<p>有了查找操作，判断两个结点是否连通就显得容易多了，一行代码就可以搞定，就是判断他们的根结点是否相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;判断pq是否已经连通&quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">return</span> self.find(p) == self.find(q)   <span class="comment"># 即判断两个结点是否是属于同一个祖先</span></span><br></pre></td></tr></table></figure>
<h3 id="完整代码附录">完整代码附录</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;并查集类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;长度为n的并查集&quot;&quot;&quot;</span></span><br><span class="line">        self.uf = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>)]    <span class="comment"># 列表0位置空出</span></span><br><span class="line">        self.sets_count = n                     <span class="comment"># 判断并查集里共有几个集合, 初始化默认互相独立</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def find(self, p):</span></span><br><span class="line">    <span class="comment">#     &quot;&quot;&quot;查找p的根结点(祖先)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#     r = p                                   # 初始p</span></span><br><span class="line">    <span class="comment">#     while self.uf[p] &gt; 0:</span></span><br><span class="line">    <span class="comment">#         p = self.uf[p]</span></span><br><span class="line">    <span class="comment">#     while r != p:                           # 路径压缩, 把搜索下来的结点祖先全指向根结点</span></span><br><span class="line">    <span class="comment">#         self.uf[r], r = p, self.uf[r]</span></span><br><span class="line">    <span class="comment">#     return p</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def find(self, p):</span></span><br><span class="line">    <span class="comment">#     while self.uf[p] &gt;= 0:</span></span><br><span class="line">    <span class="comment">#         p = self.uf[p]</span></span><br><span class="line">    <span class="comment">#     return p</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, p</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;尾递归&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.uf[p] &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        self.uf[p] = self.find(self.uf[p])</span><br><span class="line">        <span class="keyword">return</span> self.uf[p]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;连通p,q 让q指向p&quot;&quot;&quot;</span></span><br><span class="line">        proot = self.find(p)</span><br><span class="line">        qroot = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> proot == qroot:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> self.uf[proot] &gt; self.uf[qroot]:   <span class="comment"># 负数比较, 左边规模更小</span></span><br><span class="line">            self.uf[qroot] += self.uf[proot]</span><br><span class="line">            self.uf[proot] = qroot</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.uf[proot] += self.uf[qroot]  <span class="comment"># 规模相加</span></span><br><span class="line">            self.uf[qroot] = proot</span><br><span class="line">        self.sets_count -= <span class="number">1</span>                    <span class="comment"># 连通后集合总数减一</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断pq是否已经连通&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.find(p) == self.find(q)     <span class="comment"># 即判断两个结点是否是属于同一个祖先</span></span><br></pre></td></tr></table></figure>
<h2 id="转载">转载</h2>
<p>出处：https://www.cnblogs.com/yscl/p/10185293.html</p>
<p>作者：yscl</p>
<h4 id="参考">参考</h4>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaGFwamluL3AvNTQ3ODM1Mi5odG1s">数据结构--并查集的原理及实现<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RtX3ZpbmNlbnQvYXJ0aWNsZS9kZXRhaWxzLzc2NTU3NjQ=">并查集(Union-Find)算法介绍<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h4 id="其他并查集">其他并查集</h4>
<p>普通的并查集只是简单的记录了和集合的关系，即判断是否属于该集合，而带权并查集则是不仅记录了和集合的关系，还记录了集合内元素的关系，一般就是指代集合内元素和根结点的关系，实现起来也很简单，就是额外利用一个列表value[]，来记录每个节点与根结点的关系。然后在每次合并和路径压缩中更新权值。更新的规则遵循向量法则，处理环类关系的问题中，还可以取模更新。具体可以参考一下文章。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqcjM0MjY2MTkvYXJ0aWNsZS9kZXRhaWxzLzgyMzE1MTMz">https://blog.csdn.net/yjr3426619/article/details/82315133<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNzU2OTkvYXJ0aWNsZS9kZXRhaWxzLzgwMzc5MjYz">https://blog.csdn.net/u013075699/article/details/80379263<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bm1hb3hpYW5nL2FydGljbGUvZGV0YWlscy84MDk1OTMwMA==">https://blog.csdn.net/sunmaoxiang/article/details/80959300<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现简单布隆过滤器</title>
    <url>/2020/08/05/python%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="布隆过滤器">布隆过滤器</h2>
<p>布隆过滤器vshash table</p>
<p>布隆过滤器本质上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p>
<p>优点：<strong>空间效率</strong>和<strong>查询时间</strong>都<strong>远远超过</strong>一般的算法</p>
<p>缺点：有<strong>一定的误识别率</strong>和<strong>删除困难</strong></p>
<p>对于测试元素，当它验证这个元素所对应的⼆进制位是1的时候，那么它可能存在在布隆过滤器⾥⾯， 当它验证这个元素所对应的⼆进制位只要有⼀个不为1的话，那么我们可以百分之百肯定它不在。</p>
<p>那么接下来要怎么判断它到底是否存在？布隆过滤器只是放在最外⾯当⼀个缓存使的，当⼀个很快速的判断使的。当B查到了之后，布隆过滤器⾥⾯是存在的，那么B会继续到这台机器的DB⾥⾯去查。C不在布隆过滤器中，就不⽤查了。</p>
<h2 id="案例">案例</h2>
<ol type="1">
<li>比特币网络</li>
<li>分布式系统（Map-Reduce) - Hadoop、search engine
<ol type="1">
<li>搜索引擎，经常需要把大量的网页信息，图片信息存到整个服务器里面，一般来说，不同的网页是存在不同的集群里面的。那么就先去这个集群的布隆过滤器里面查一下。</li>
</ol></li>
<li>Redis缓存</li>
<li>垃圾邮件、评论等的过滤</li>
</ol>
<h2 id="简单实现示例">简单实现示例</h2>
<p>布隆过滤器主要有构造函数，和add一个元素，search一个元素，三个API需要实现。</p>
<p>构造函数，我们可以假定传入二进制数组的长度（工业实现中可能会传如元素的数量，然后推断出人禁止数组的长度），需要的哈希函数数量。</p>
<p>add的函数签名是 add(s:str) -&gt; None，我们假定查询的是字符串</p>
<p>search是search(s:str) -&gt;bool</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mmh3</span><br><span class="line"><span class="keyword">from</span> bitarray <span class="keyword">import</span> bitarray</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size: int, hash_num: int</span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.hash_num = hash_num</span><br><span class="line">        self.bit_array = bitarray(size)</span><br><span class="line">        self.bit_array.setall(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, s: str</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> seed <span class="keyword">in</span> range(self.hash_num):</span><br><span class="line">            result = mmh3.hash(s, seed) % self.size</span><br><span class="line">            self.bit_array[result] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, s: str</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> seed <span class="keyword">in</span> range(self.hash_num):</span><br><span class="line">            result = mmh3.hash(s, seed) % self.size</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.bit_array[result]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># Nope</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># Probably</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《相信未来》——食指</title>
    <url>/2019/12/05/%E3%80%8A%E7%9B%B8%E4%BF%A1%E6%9C%AA%E6%9D%A5%E3%80%8B%E2%80%94%E2%80%94%E9%A3%9F%E6%8C%87/</url>
    <content><![CDATA[<p>当蜘蛛网无情地查封了我的炉台</p>
<p>当灰烬的余烟叹息着贫困的悲哀</p>
<p>我依然固执地铺平失望的灰烬</p>
<p>用美丽的雪花写下：相信未来</p>
<p>当我的紫葡萄化为深秋的露水</p>
<p>当我的鲜花依偎在别人的情怀</p>
<p>我依然固执地用凝霜的枯藤</p>
<p>在凄凉的大地上写下：相信未来</p>
<p>我要用手指那涌向天边的排浪</p>
<p>我要用手掌那托住太阳的大海</p>
<p>摇曳着曙光那枝温暖漂亮的笔杆</p>
<p>用孩子的笔体写下：相信未来</p>
<p>我之所以坚定地相信未来</p>
<p>是我相信未来人们的眼睛</p>
<p>她有拨开历史风尘的睫毛</p>
<p>她有看透岁月篇章的瞳孔</p>
<p>不管人们对于我们腐烂的皮肉</p>
<p>那些迷途的惆怅、失败的苦痛</p>
<p>是寄予感动的热泪、深切的同情</p>
<p>还是给以轻蔑的微笑、辛辣的嘲讽</p>
<p>我坚信人们对于我们的脊骨</p>
<p>那无数次的探索、迷途、失败和成功</p>
<p>一定会给予热情、客观、公正的评定</p>
<p>是的，我焦急地等待着他们的评定</p>
<p>朋友，坚定地相信未来吧</p>
<p>相信不屈不挠的努力</p>
<p>相信战胜死亡的年轻</p>
<p>相信未来、热爱生命</p>
<p><br></p>
<p>食指</p>
<p>1968年 北京</p>
]]></content>
      <tags>
        <tag>青春</tag>
      </tags>
  </entry>
  <entry>
    <title>一次犯罪不过是污染了水流，而一次不公正的司法却污染了水源</title>
    <url>/2020/08/08/%E4%B8%80%E6%AC%A1%E7%8A%AF%E7%BD%AA%E4%B8%8D%E8%BF%87%E6%98%AF%E6%B1%A1%E6%9F%93%E4%BA%86%E6%B0%B4%E6%B5%81%EF%BC%8C%E8%80%8C%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%85%AC%E6%AD%A3%E7%9A%84%E5%8F%B8%E6%B3%95%E5%8D%B4%E6%B1%A1%E6%9F%93%E4%BA%86%E6%B0%B4%E6%BA%90/</url>
    <content><![CDATA[<p>张玉环事件有感</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>给时光以生命，给岁月以文明</title>
    <url>/2020/08/26/%E4%B8%8D%E6%98%AF%E7%BB%99%E6%96%87%E6%98%8E%E4%BB%A5%E5%B2%81%E6%9C%88%EF%BC%8C%E8%80%8C%E6%98%AF%E7%BB%99%E5%B2%81%E6%9C%88%E4%BB%A5%E6%96%87%E6%98%8E/</url>
    <content><![CDATA[<p><strong>给时光以生命，而不是给生命以时光。</strong>（这句话出自帕斯卡，To the time to life, rather than to life in time.老帕之所以有此言论，大概和他的生命状态有很大关系。帕斯卡从小体质虚弱，又因过度劳累而使疾病缠身。他只活到三十九岁，但一生辉煌，活得虽短却很精彩。正是这短暂的一生让他更清楚的看到生命的本质，福祸相依，这正是上帝的公平，或者说是概率的公平。他还说过一句非常有名的话：“人只不过是一根芦苇，是自然界最脆弱的东西，但他是一根能思想的芦苇。”）</p>
<p>网上的解释是：活着的每时每刻都要精彩，而不是让生命虚度，随着时光衰老。</p>
<p>我的理解是：给每一个此时此刻赋予生命的精彩，只要活得精彩就美好，不必强行续命。正如有些年老的人，其实与其在病床上忍受病痛的折磨，他们更愿意让自己在睡梦或者昏迷中死去。见过很多这样的老者。不愿接受病痛的折磨，这其实也体现了生命的尊严。比如，今年听说一位澳大利亚的老教授，100多岁，但是已没有故友活在人世，自己也疾病缠身，他选择到了可以执行安乐死的国家安乐死。他的原话说，没有人deserve这样的对待，这不是人该接受的对待，他宁可选择死亡。世界上没有感同身受，但是从他的话里也能知道在生命的最后，他宁可提前结束掉它。</p>
<p><strong>给岁月以文明，而不是给文明以岁月。</strong></p>
<p>网上解释：文明的灿烂与否并不是以时间来衡量的，宁可获得短暂的灿烂文明，而不愿苟且偷生。</p>
<p>我的理解是：努力创造出好的文明，来让岁月精彩，一旦文明终将走向衰败，不要强行延长它的寿命，让更好的文明来替代它，不要把这个文明变得丑陋，成为后来文明的障碍。</p>
<p>重复一下，<strong>给时光以生命，给岁月以文明</strong>。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>了解java GC过程</title>
    <url>/2020/08/28/%E4%BA%86%E8%A7%A3java-GC%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>堆的空间是用来存储我们new出来的对象的。当new的对象填充满堆区的话，就会导致内存爆掉，我们的程序就会OOM。jvm 的 GC是清理堆上的对象的。</p>
<p>首先我们应该判断这个对象应不应该被删除。那判断的标准是什么呢？有一个标准叫GCRoot。被</p>
<ol type="1">
<li>栈</li>
<li>本地方法栈</li>
<li>方法区（全局变量）</li>
</ol>
<p>直接或者间接引用的对象，是不能被删除的。</p>
<p>就引出了一个以GCRoot为根的树结构。</p>
<p>思路1：标记需要被删除，在扫描一遍，再删除。这就是<strong>标记清理。</strong></p>
<p>缺点：<strong>产生内存碎片。</strong>（导致虽然有内存，但申请不了大内存）</p>
<p>思路2：<strong>标记整理</strong>。在清除之后，后面的对象要补上来，后面的对象往前顶，减少内存碎片。</p>
<p>缺点：<strong>代价太大。所有的对象都要前移。</strong></p>
<p>思路3：<strong>复制算法</strong>。将整个内存一分为二。在1区标记是否删除，等到快满了。往2区进行复制，需要删除就不复制，不需要删除的就复制过来，并且是紧凑的复制。这样既避免了内存碎片问题，整个的开销也不大。</p>
<p>缺点：<strong>需要两倍的内存。</strong></p>
<p>实际的GC。</p>
<p>对堆区进行了划分，一部分叫年轻代（Young区），另一部分叫老年区（Old区）。对年轻代又进行了划分，有3个区。eden区，survive0区， survive1区。Old区只有一块。new对象都会在eden区。当eden区快满的时候就会触发GC。这个GC只是Young这个区域的GC，所以这个GC又叫做YoungGC。YoungGC的过程采用的是上面的复制算法。不需要删除的依次复制到survive0区。eden比较大的原因是，对象的生命周期往往较短，所以在产生它们的地方区域会比较大，但是幸存下来的比较小。survive0、survive1、eden的比例大概是1：1：8，默认设置下。那为什么需要两块survive区呢？这两个S区是交替工作的。幸存到S0区之后，会将E和S1区全部删除。然后等下一次E区快满了之后，再将S0和E所有对象标记，然后全部复制到S1区。S0和S1交替使用，作为幸存下来的区域。E+S1复制到S0，E+S0复制到S1，E+S1复制到S0，如此往复。结合了对象的"朝生夕死"的特征进行设计的。每一次YoungGC之后，活下来的对象的年龄就会加1，直到对象满了6岁，不再往survive区中复制了，就直接到Old区中。这个原因是因为，如果一个对象在6次GC的清理中都没有被清理掉，那很有可能60次GC都不会清理掉，它可能会永远存在，或者存在很长一段时间。所以我们直接把它放到Old区中维护，这样就省得每次都在这边复制了。另外Old区除了存了年龄是大于等于6岁的这样的一些对象，同时它还存一些大的对象。大对象的原因是如果我们在Eden进行复制的时候，大对象的消耗是比较大的。大对象主要是什么呢？比如说有一个1000万大小的int数组，它就是一个大对象，这个大对象就会直接存到Old区，不进行Young区的存储。那在Old区同样存在它快满了的问题，快满了就会触发GC。OldGC一般会同时伴随着YoungGC，所以它又叫FullGC。FullGC会引起stop the world。stop the world就是说整个java程序直接暂停，然后全力地进行垃圾回收，(因为已经没有内存可用了)。垃圾回收主要采用的是标记清理的算法，或者是标记整理的算法。那我们就明确了，1和2思路（标记清理和标记整理）主要是用于FullGC的，也就是Old区的GC，复制算法主要是Young区的GC。</p>
<p>这里举几个比较有名的垃圾收集器。</p>
<p>年轻代的垃圾收集器可能是ParNew。</p>
<p>老年代比较有名的可能是CMS。</p>
<p>分别用了复制算法和标记清理算法，来进行垃圾回收。</p>
<p>最新版的JDK已经不建议用以前的垃圾收集器了，而采用了一种全新的G1垃圾收集器。它有一种全新的理念。这里就不展开讲了。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>人要多读书</title>
    <url>/2020/07/26/%E4%BA%BA%E8%A6%81%E5%A4%9A%E8%AF%BB%E4%B9%A6/</url>
    <content><![CDATA[<p>天下没有谁生而知之，都是学而知之。人的学问哪来，您记住，无论谁啊，都算上， 大思想家，大文学家，大作家，也是俩字，记问之学。一个就是看书，《史记》上有这么一句话我把它记下来了，《三国志》有这么句话我把它记下来了。记，还有就是问。这我不懂，哎呦先生您看，这怎么回事。先生告诉你了啊，这个如何如何。所有人的学问，都是这么来的。记问之学，所以要广览多读。</p>
<p>至于发明创造，也需要了解已有知识，还是需要记 与 问。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>今年值得纪念的事情</title>
    <url>/2020/08/12/%E4%BB%8A%E5%B9%B4%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    <content><![CDATA[<h2 id="数据结构与算法">数据结构与算法</h2>
<ul>
<li>leetcode刷到300题啦，继续加油啊！</li>
<li>2020.08.22 第一次leetcode周赛全对，继续努力！</li>
<li>2020.08.23 leetcode周赛进了前500，继续努力！</li>
<li>2020.08.30 leetcode 204 周赛全国排名68，进入前100啦！世界排名239，进入前300啦！继续加油啊！</li>
</ul>
<h2 id="生活">生活</h2>
<ul>
<li>拔掉了最后两颗智齿，所有的智齿都没啦！</li>
<li>看完了《七武士》</li>
<li>读完了《被讨厌的勇气》 2020.8.26</li>
</ul>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>但行好事，莫问前程</title>
    <url>/2020/07/15/%E4%BD%86%E8%A1%8C%E5%A5%BD%E4%BA%8B%EF%BC%8C%E8%8E%AB%E9%97%AE%E5%89%8D%E7%A8%8B/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算解决全部其余所有数出现k次，找出唯一出现p次的数的题目</title>
    <url>/2020/07/22/%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A7%A3%E5%86%B3%E5%85%A8%E9%83%A8%E5%85%B6%E4%BD%99%E6%89%80%E6%9C%89%E6%95%B0%E5%87%BA%E7%8E%B0k%E6%AC%A1%EF%BC%8C%E6%89%BE%E5%87%BA%E5%94%AF%E4%B8%80%E5%87%BA%E7%8E%B0p%E6%AC%A1%E7%9A%84%E6%95%B0%E7%9A%84%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="问题描述">1. 问题描述</h2>
<p>给出只包含int类型的数组，所有值出现k(k&gt;1)次，除了一个值，这个值出现了p次（p&gt;1, p%k!=0)。找到这个值。</p>
<h2 id="从只有1bit的特殊情况开始">2. 从只有1bit的特殊情况开始</h2>
<p>为了应用位运算，我们应该重新思考integers是如何在计算机中被表示的--通过位。让我们先考虑1位。假如我们有一数组的一bit数（除了0就是1），我们要统计数组中的1，使得当统计1的计数器到达k时，计数器回到0并且重新统计（k和我们问题中提到的k一样）。为了跟踪我们已经遇到多少个1，我们需要一个计数器。假设计数器二进制表示有m位：xm, ..., x1（最重要的位到最不重要的位）。我们至少可以总结出计数器的以下四个特性。</p>
<ol type="1">
<li>计数器有一个初始状态，简单来讲为0</li>
<li>对于数组中的每一个输入，如果我们击中0，计数器应该保持不变</li>
<li>对于数组中的每一个输入，如果我们击中1，计数器应该增加1</li>
<li>为了覆盖k个计数，我们要求2^m&gt;=k，这意味着m &gt; logk</li>
</ol>
<p>这里是关键部分：当我们扫描数组时，计数器（从x1到xm）中的每个位如何变化。注意，我们被提示使用位运算。为了满足第2个属性，回想一下，如果另一个操作数为0，有哪些位操作不会改变操作数？是的，有位与x=x|0和位异或x=x^0。</p>
<p>好了，我们现在有一个表达式：x = x | i或者x = x^i，其中i是数组中的扫描元素。哪一个更好呢？我们还不知道。所以，让我们开始实际的计算。</p>
<p>开始的时候，计数器的所有位都初始化为0，即xm=0, ..., x1=0。由于我们要选择的位操作，保证了计数器的所有位在遇到0时都保持不变，所以直到我们遇到数组中第一个1，计数器将是0。当我们遇到第一个1的时候，我们得到：xm = 0, ... , x2=0, x1=1。让我们继续下去，直到打出第二个1，之后我们得到：xm=0, ... , x2=1, x1=0。注意，x1从1变成了0。对于x1 = x1 | i，在第二次计数之后，x1仍然会是1。所以很明显，我们应该使用x1 = x1 ^ i，那么x2, ..., xm呢？我们的想法是找到x2, ... , xm将改变其值的条件。以x2为例。如果我们打了一个1，需要改变x2的值，那么在我们进行改变之前，x1的值一定是多少？答案是：x1必须是1，否则我们不应该改变x2，因为把x1从0改成1就可以了。因此，只有当x1和i都是1时，x2才会改变值，或者数学上说，x2 = x2 ^ (x1 &amp; i)。同理，xm只有在，xm-1, ... , x1和i都是1的时候才会改变数值：xm = xm ^ (xm-1 &amp; ... &amp; x1 &amp; i)。ok，我们找到了这个位运算。</p>
<p>但是，你可能会注意到，上面发现的位运算将从0开始计数，直到2^m-1，而不是k。如果k &lt; 2^m - 1，我们需要一些”切割“机制，以在计数达到k时将计数器重新初始化为0。为此，我们对xm, ... , x1应用位AND，并使用一些称为mask的变量，即xm = xm &amp; mask, ... , x1 = x1 &amp; mask。如果我们能保证只有当计数达到k时，mask才为0，而在其他所有计数情况下为1，那么我们就完成了。我们如何实现这一点呢？试着想一想，计数为k的情况与其他所有情况的区别是什么？是的，是1的计数！对于每一个计数，我们对计数器的每一个位都有唯一的值，这可以看作是它的状态。如果我们把k写成二进制形式：km, ... ,k1, 我们就可以构造mask如下。</p>
<p>mask = ~(y1 &amp; y2 &amp; .. &amp; ym)，其中如果kj = 1, yj = xj， 如果kj = 0， yj = -xj ( j = 1 to m )</p>
<p>简单来讲，就是只有当x1..xm和k的所有位都相等的时候，mask才会为0</p>
<p>我们来举一些例子：</p>
<p>k = 3: k1 = 1, k2 = 1, mask = ~(x1 &amp; x2);</p>
<p>k = 5: k1 = 1, k2 = 1, k3 = 1, mask = ~(x1 &amp; ~x2 &amp; x3);</p>
<p>综上所述，我们的算法将是这样的（nums是输入数组）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">    xm ^= (xm<span class="number">-1</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    xm<span class="number">-1</span> ^= (xm<span class="number">-2</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    .....</span><br><span class="line">    x1 ^= i;</span><br><span class="line">    </span><br><span class="line">    mask = ~(y1 &amp; y2 &amp; ... &amp; ym) where yj = xj <span class="keyword">if</span> kj = <span class="number">1</span>, <span class="keyword">and</span> yj = ~xj <span class="keyword">if</span> kj = <span class="number">0</span> (j = <span class="number">1</span> to m).</span><br><span class="line"></span><br><span class="line">    xm &amp;= mask;</span><br><span class="line">    ......</span><br><span class="line">    x1 &amp;= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="位数的一般情况">3. 32位数的一般情况</h2>
<p>现在是时候把我们的结果从1位数的情况推广到32位整数了。一个直接的方法是为整数中的每个位创建32个计数器。但是，如果我们利用位操作的优势，我们也许可以”集体“管理所有的32个计数器，其中m是满足m&gt;=logk的最小整数。原因是位操作只适用于每个位，所以对不同位的操作是相互独立的（有点明显，对吧？）。这使得我们可以将32个计数器的对应位归为一个32位整数。下面是一个示意图，展示了如何做到这一点。</p>
<img data-src="/2020/07/22/%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A7%A3%E5%86%B3%E5%85%A8%E9%83%A8%E5%85%B6%E4%BD%99%E6%89%80%E6%9C%89%E6%95%B0%E5%87%BA%E7%8E%B0k%E6%AC%A1%EF%BC%8C%E6%89%BE%E5%87%BA%E5%94%AF%E4%B8%80%E5%87%BA%E7%8E%B0p%E6%AC%A1%E7%9A%84%E6%95%B0%E7%9A%84%E9%A2%98%E7%9B%AE/%E4%BD%8D%E8%BF%90%E7%AE%971.png" class>
<p>最上面的一行是32位的整数，其中每一个位，我们都有一个对应的m位计数器（由向上箭头下面的那一列所示）。由于对32位中每一个位的操作都是相互独立的，所以我们可以将比如说所有计数器的第m位，归为一个32位数（由橙色框所示）。这个32位数中的所有位（表示为xm）将遵循相同的位操作。由于每个计数器有m个位，我们最终得到m个32位数，对应于第二部分中定义的x1, ... , xm，但现在它们是32位数而不是1位数。因此，在上面开发的算法中，我们只需要将x1到xm视为32位整数而不是1位数。其他一切都将是相同的，我们就完成了。很简单，嗯？</p>
<h2 id="返回什么">4. 返回什么</h2>
<p>最后就是我们应该返回什么值，或者等价于x1到xm中哪一个会等于单一元素。为了得到正确的答案，我们需要了解m个32位整数x1到xm代表什么。以x1为例，x1有32位，我们把它们标注为r（r=1到32)。当我们扫描完输入数组后，x1的r-th位的值将由数组中所有元素的r-th为决定（更具体的说，假设数组中所有元素的r-th位1的总计数为q，那么最终r-th位就是q'=q%k，其二进制形式为：q'm, ... , q'1，那么根据定义，x1的r-th位将等于 q'1)。现在你可以问自己这个问题：如果x1的r-th位是1，这意味着什么？</p>
<p>答案是要找到能对这个1做出贡献的东西，一个出现了k次的元素会有贡献吗？不会，为什么？因为一个元素要做出贡献，至少要同时满足两个条件：这个元素的r-th位是1，这个1的出现次数不是k的整数倍，第一个条件是微不足道的。第二个条件来自于每当1的命中次数为k时，计数器就会回零，也就是x1中的对应位会被重置为0，对于一个出现了k次的元素，不可能同时满足这两个条件（违反第二条），所以它不会有贡献。所以，只有出现p（p%k!=0）次的单个元素才会做出贡献。如果p&gt;k，那么前k*[p/k] ([p/k]表示p/k的整数部分)的元素也不会做出贡献。所以我们总是可以设置p' = p % k，并说这个单元素有效地出现了p'次。</p>
<p>我们把p‘写成二进制形式：p'm, ... , p'1(注意p' &lt; k, 所以它将适合m位)。这里提出一个声明，xj等于这个单个元素的条件是p'j = 1(j =1 到 m)，下面给出一个快速证明：</p>
<p>如果xj的r-th位是1，我们可以放心的说这个单一元素的r-th位也是1（否则没有任何东西可以使xj的r-th位是1）。我们还要证明，如果xj的r-th位是0，那么单元素的r-th位只能是0，我们就假设在这种情况下，单元素的r-th位是1，我们看看会发生什么。在扫描结束时，这个1将被计算p'次。根据定义，xj的r-th位将等于p'j，也就是1，这与xj的r-th位为0的假设相矛盾，因此我们得出结论，只要p'j=1，xj的r-th位将始终与单一元素的r-th位相同。由于这对xj中的所有位都是真的（即对若r=1到32来说是真的），所以我们得出结论，只要p'j=1，xj将等于这个单一元素的值。</p>
<p>所以现在我们应该返回什么就很清楚了。只要用其二进制形式表达p'=p%k，只要p'j = 1，就可以返回对应的xj中的任何一个。总的来说，该算法将在O(n*logk)时间和O(logk)的空间内运行。</p>
<h2 id="快速例子几个">快速例子几个</h2>
<p>Here is a list of few quick examples to show how the algorithm works (you can easily come up with other examples):</p>
<ol type="1">
<li><code>k = 2, p = 1</code> <code>k</code> is <code>2</code>, then <code>m = 1</code>, we need only one 32-bit integer (<code>x1</code>) as the counter. And <code>2^m = k</code> so we do not even need a mask! A complete java program will look like:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int singleNumber(int[] nums) &#123;</span><br><span class="line">    int x1 &#x3D; 0;</span><br><span class="line">     </span><br><span class="line">    for (int i : nums) &#123;</span><br><span class="line">        x1 ^&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    return x1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><code>k = 3, p = 1</code> <code>k</code> is <code>3</code>, then <code>m = 2</code>, we need two 32-bit integers(<code>x2</code>, <code>x1</code>) as the counter. And <code>2^m &gt; k</code> so we do need a mask. Write <code>k</code> in its binary form: <code>k = '11'</code>, then <code>k1 = 1</code>, <code>k2 = 1</code>, so we have <code>mask = ~(x1 &amp; x2)</code>. A complete java program will look like:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int singleNumber(int[] nums) &#123;</span><br><span class="line">    int x1 &#x3D; 0, x2 &#x3D; 0, mask &#x3D; 0;</span><br><span class="line">     </span><br><span class="line">    for (int i : nums) &#123;</span><br><span class="line">        x2 ^&#x3D; x1 &amp; i;</span><br><span class="line">        x1 ^&#x3D; i;</span><br><span class="line">        mask &#x3D; ~(x1 &amp; x2);</span><br><span class="line">        x2 &amp;&#x3D; mask;</span><br><span class="line">        x1 &amp;&#x3D; mask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return x1;  &#x2F;&#x2F; Since p &#x3D; 1, in binary form p &#x3D; &#39;01&#39;, then p1 &#x3D; 1, so we should return x1. </span><br><span class="line">                &#x2F;&#x2F; If p &#x3D; 2, in binary form p &#x3D; &#39;10&#39;, then p2 &#x3D; 1, and we should return x2.</span><br><span class="line">                &#x2F;&#x2F; Or alternatively we can simply return (x1 | x2).</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><code>k = 5, p = 3</code> <code>k</code> is <code>5</code>, then <code>m = 3</code>, we need three 32-bit integers(<code>x3</code>, <code>x2</code>, <code>x1</code>) as the counter. And <code>2^m &gt; k</code> so we need a mask. Write <code>k</code> in its binary form: <code>k = '101'</code>, then <code>k1 = 1</code>, <code>k2 = 0</code>, <code>k3 = 1</code>, so we have <code>mask = ~(x1 &amp; ~x2 &amp; x3)</code>. A complete java program will look like:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int singleNumber(int[] nums) &#123;</span><br><span class="line">    int x1 &#x3D; 0, x2 &#x3D; 0, x3  &#x3D; 0, mask &#x3D; 0;</span><br><span class="line">   </span><br><span class="line">    for (int i : nums) &#123;</span><br><span class="line">        x3 ^&#x3D; x2 &amp; x1 &amp; i;</span><br><span class="line">        x2 ^&#x3D; x1 &amp; i;</span><br><span class="line">        x1 ^&#x3D; i;</span><br><span class="line">        mask &#x3D; ~(x1 &amp; ~x2 &amp; x3);</span><br><span class="line">        x3 &amp;&#x3D; mask;</span><br><span class="line">        x2 &amp;&#x3D; mask;</span><br><span class="line">        x1 &amp;&#x3D; mask;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return x1;  &#x2F;&#x2F; Since p &#x3D; 3, in binary form p &#x3D; &#39;011&#39;, then p1 &#x3D; p2 &#x3D; 1, so we can return either x1 or x2. </span><br><span class="line">                &#x2F;&#x2F; If p &#x3D; 4, in binary form p &#x3D; &#39;100&#39;, only p3 &#x3D; 1, which implies we can only return x3.</span><br><span class="line">                &#x2F;&#x2F; Or alternatively we can simply return (x1 | x2 | x3).</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lastly I would like to thank those for providing feedbacks to make this post better. Hope it helps and happy coding!</p>
<h2 id="相关力扣题目">相关力扣题目</h2>
<p>136 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2luZ2xlLW51bWJlci8=">https://leetcode-cn.com/problems/single-number/<i class="fa fa-external-link-alt"></i></span></p>
<p>137 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2luZ2xlLW51bWJlci1paS8=">https://leetcode-cn.com/problems/single-number-ii/<i class="fa fa-external-link-alt"></i></span></p>
<p>260 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2luZ2xlLW51bWJlci1paWkv">https://leetcode-cn.com/problems/single-number-iii/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么rowid是6个字节</title>
    <url>/2020/08/28/%E5%85%B3%E4%BA%8EMySQL%E7%9A%84row-ID/</url>
    <content><![CDATA[<p>首先官方文档是这么写的。参考<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS42L2VuL2lubm9kYi1pbmRleC10eXBlcy5odG1sIzp+OnRleHQ9RXZlcnklMjBJbm5vREIlMjB0YWJsZSUyMGhhcyUyMGEsZm9yJTIwdGhlJTIwcm93cyUyMGlzJTIwc3RvcmVkLiZhbXA7dGV4dD1UaGUlMjByb3clMjBJRCUyMGlzJTIwYSxhcmUlMjBwaHlzaWNhbGx5JTIwaW4lMjBpbnNlcnRpb24lMjBvcmRlci4=">MySQL5.6 Ref manual<i class="fa fa-external-link-alt"></i></span>。</p>
<p>每个InnoDB表都有一个特殊的索引，称为聚簇索引clustered index，行的数据就存储在这里。通常情况下，聚簇索引是主键的同义词。为了从查询、插入和其他数据库操作中获得最佳性能，你必须理解InnoDB是如何使用聚簇索引来优化每个表的最常见的查找和DML操作的。</p>
<ul>
<li>当你在表上定义一个primary key时，InnoDB就会把它作为聚簇索引。为你创建的每一个表定义一个主键。如果没有逻辑上唯一且非空的列或列集合，则添加一个新的自动增加列，其值会自动填入。</li>
<li>如果你没有为你的表定义primary key，MySQL会定位第一个Unique索引，其中所有的关键列都是Not Null。InnoDB使用它作为聚簇索引。</li>
<li>如果表没有primary key或合适的unique索引，InnoDB内部会在包含row id值的合成列上生成一个名为GEN_CLUST_INDEX的隐藏聚簇索引。行是由InnoDB分配给这种表中的行的ID来排序的。row id是一个6字节的字段，随着新行的插入而单调增加。因此，按row id排序的行在物理上是按插入顺序排列的。</li>
</ul>
<h5 id="聚簇索引是如何加快查询速度的">聚簇索引是如何加快查询速度的？</h5>
<p>通过聚簇索引访问行的速度很快，因为索引搜索会直接引导到包含所有行数据的页面。如果一张表很大，与使用与索引记录不同的页面存储行数据的存储组织相比，聚簇索引架构往往可以节省一次磁盘I/O操作。</p>
<h5 id="二级索引与聚簇索引的关系">二级索引与聚簇索引的关系</h5>
<p>除了聚簇索引以外的所有索引都称为二级索引。在InnoDB中，二级索引中的每条记录都包含改行的主键列，以及二级索引指定的列。InnoDB使用这个主键值来搜索聚簇索引中的行。</p>
<p>如果主键长，二级索引就会使用更多的空间，所以主键短是有利的。</p>
<h3 id="回答标题的问题">回答标题的问题</h3>
<img data-src="/2020/08/28/%E5%85%B3%E4%BA%8EMySQL%E7%9A%84row-ID/rowid1.gif" class>
<p>这里我没有找到mysql的rowid为什么是6个字节的答案，找到是关于oracle rowid的解释，猜测是互通的。</p>
<p>rowid是伪列。不会真正存在表的data block中，但是它会存在于index中。</p>
<p>扩展的rowid在磁盘上需要10个字节的存储空间，并使用18个字符来显示。</p>
<p>解释如下：</p>
<p>在oracle 8以前，一个rowid占用6个字节大小的存储空间（10 bit file# + 22bit block # + 16 bit row #)，rowid格式为：BBBBBBBB.RRRR.FFFF。</p>
<p>在oracle 8以后，rowid的存储空间扩大到了10个字节（32 bit object# + 10bit rfile# + 22 bit block# + 16 bit row#)，文件号仍然用10位表示，只是不再需要置换，为了向后兼容，同时引入了相对文件号（rfile#)，所以从Oracle7到Oracle8，rowid仍然无需发生变化。</p>
<p>这里我猜测，mysql rowid也是存储了 10位的文件号，22位的块号，16位的行号。</p>
<h3 id="更新已经得到答案">更新：已经得到答案。</h3>
<p>详见<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS84MzE4Mw==">文章<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>使用函数randa()来实现函数randb()</title>
    <url>/2020/07/21/%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0randa-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0randb/</url>
    <content><![CDATA[<h1 id="使用函数randa来实现函数randb">使用函数randa()来实现函数randb()</h1>
<p>原文引自：https://blog.csdn.net/wangruitao1991/article/details/51678815</p>
<p>我们由浅入深，首先来看：</p>
<ol type="1">
<li><p>给你一个能成1到7随机数的函数，用它写一个生成1到5的随机数。即使用rand7来实现rand5</p>
<p>rand7可以随机生成1，2，3，4，5，6，7，是等概率的，这里直观的想法是不断地电泳rand7，直到它生成1到5之间的数，然后返回。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  inx x = ~(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);  <span class="comment">// max int</span></span><br><span class="line">  <span class="keyword">while</span> (x &gt; <span class="number">5</span>)&#123;</span><br><span class="line">    x = rand7();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数可以等概率的产生1到5的数码？首先，它确确实实只会返回1到5这几个数，其次，对于这些数，都是由rand7等概率的产生的1/7，没有对任何一个数有偏袒，直觉告诉我们，rand5就是等概率的产生1到5的。事实呢？让我们来计算一下，产生1到5中的数是不是1/5就OK了。</p>
<p>产生1的概率：等于第一次产生1的概率，加上第一次生成6，7第二次产生1的概率，加上... $$ p(x=1) = 1/7 + 2/7 * 1/7 + (2/7)^2 * 1/7 + ... \</p>
<p>= 1/7 * (1 + 2/7 + (2/7)^2+...)\</p>
<p>= 1/7 * 1 / (1-2/7)\</p>
<p>= 1/5\ $$ 其他同理，所以从上面的分析，我们可以得到一个一般的结论，如果a &gt; b，那么一定可以用randa实现randb。其中，randa表示等概率生成1到a的函数，randb表示等概率生成1到b的函数。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">;<span class="comment">// a &gt; b</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  inx x = ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>); <span class="comment">// max int</span></span><br><span class="line"> <span class="keyword">while</span> (x &gt; b) &#123;</span><br><span class="line">      x = randa();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还有没有优化的空间呢。我们想如果a大于b很多，那么这个循环大多数是无法退出的。这是我们可以找到一个最接近a的b的整数倍<strong>b * (A/b)</strong>，大于这个整数倍就继续循环，否则就返回 <strong>randa()%b + 1 </strong>。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a &gt; b</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x =  ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>); <span class="comment">//  max int</span></span><br><span class="line">  <span class="keyword">while</span> (x &gt; b * (a / b)) &#123;</span><br><span class="line">    x = randa();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x % b + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，a大于b时这个问题得到完美的解决了。那么a小于b的时候呢。</p>
<p>比如，如何用rand5实现rand7。</p>
<p>我们只需要将rand5映射到一个能产生更大随机数的randa，a &gt; 7，这个问题就可以解决了。这里要注意，映射之后的randa也应该是等概率生成1到a的。</p>
<p>如何映射呢。其实可以将rand5想象成一个五进制数。2个rand5就可以表示25种情况。</p>
<p>5 * (rand5() - 1) + rand5()，可以等概率的产生1-25之间的数字。</p>
<p>根据上面的模板我们可以得到以下的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>); <span class="comment">// max int</span></span><br><span class="line">  <span class="keyword">while</span> (x &gt; <span class="number">7</span>) &#123;</span><br><span class="line">    x = <span class="number">5</span> * (rand5() - <span class="number">1</span>) + rand5();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在根据上面的模板简化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>); <span class="comment">// max int</span></span><br><span class="line">  <span class="keyword">while</span> (x &gt; <span class="number">21</span>) &#123;</span><br><span class="line">    x = <span class="number">5</span> * (rand5() - <span class="number">1</span>) + rand5();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x % <span class="number">7</span> +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上文分析，我们可以得到步骤如下：</p>
<ol type="1">
<li>如果a &gt; b，进入步骤2；否则构造Randa2 = a * (Randa – 1) + Randa， 表示生成1到a2 随机数的函数。如果a2 仍小于b，继教构造 Randa3 = a * (Randa2 - 1) + Randa…直到ak &gt; b，这时我们得到Randak , 我们记为RandA。</li>
<li>步骤1中我们得到了RandA(可能是Randa或Randak )，其中A &gt; b， 我们用下述代码构造Randb：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A &gt; b</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Randb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = ~(<span class="number">1</span>&lt;&lt;<span class="number">31</span>); <span class="comment">// max int</span></span><br><span class="line">    <span class="keyword">while</span>(x &gt; b*(A/b)) <span class="comment">// b*(A/b)表示最接近A且小于A的b的倍数</span></span><br><span class="line">        x = RandA();</span><br><span class="line">    <span class="keyword">return</span> x%b + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面一系列的分析可以发现，如果给你两个生成随机数的函数Randa和Randb， 你可以通过以下方式轻松构造Randab，生成1到a*b的随机数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Randab &#x3D; b * (Randa - 1) + Randb</span><br><span class="line">Randab &#x3D; a * (Randb - 1) + Randa</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>区间树</title>
    <url>/2020/07/30/%E5%8C%BA%E9%97%B4%E6%A0%91/</url>
    <content><![CDATA[<h2 id="参考">参考：</h2>
<p>https://www.geeksforgeeks.org/interval-tree/</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc0NjYyMTgvd2hhdC1hcmUtdGhlLWRpZmZlcmVuY2VzLWJldHdlZW4tc2VnbWVudC10cmVlcy1pbnRlcnZhbC10cmVlcy1iaW5hcnktaW5kZXhlZC10Izp+OnRleHQ9U2VnbWVudCUyMHRyZWUlMjBzdG9yZXMlMjBpbnRlcnZhbHMlMkMlMjBhbmQsd2l0aCUyMGElMjBnaXZlbiUyMGludGVydmFsJTIyJTIwcXVlcmllcy4=">https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t#:~:text=Segment%20tree%20stores%20intervals%2C%20and,with%20a%20given%20interval%22%20queries.<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="实际问题简单记类似于点的添加和删除和查找都要快速点的解决办法是平衡bst使得这几种操作都变成ologn区间的添加删除类似查找的是overlap这时就需要用到区间树">实际问题（简单记，类似于点的添加和删除和查找，都要快速，点的解决办法是平衡BST，使得这几种操作都变成O(logn)，区间的添加删除类似，查找的是overlap，这时就需要用到区间树）</h2>
<p>Consider a situation where we have a set of intervals and we need following operations to be implemented efficiently. <strong>1)</strong> Add an interval <strong>2)</strong> Remove an interval <strong>3)</strong> Given an interval x, find if x overlaps with any of the existing intervals.</p>
<p>考虑我们有一个集合的区间，并且我们需要以下操作能够有效率的实现：</p>
<ol type="1">
<li>添加一个区间</li>
<li>删除一个区间</li>
<li>对于一个给定的区间x，找出x是否有和任意一个已经存在的区间有重合。</li>
</ol>
<p><strong><em>Interval Tree:</em></strong> The idea is to augment a self-balancing Binary Search Tree (BST) like <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvcmVkLWJsYWNrLXRyZWUtc2V0LTEtaW50cm9kdWN0aW9uLTIv">Red Black Tree<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvYXZsLXRyZWUtc2V0LTEtaW5zZXJ0aW9uLw==">AVL Tree<i class="fa fa-external-link-alt"></i></span>, etc to maintain set of intervals so that all operations can be done in O(Logn) time.</p>
<p>Every node of Interval Tree stores following information. a) <strong>i</strong>: An interval which is represented as a pair <em>[low, high]</em> b) <strong>max</strong>: Maximum <em>high</em> value in subtree rooted with this node.</p>
<p>区间的最小值用作BST的键值来保持BST的顺序。那么插入和删除就和自平衡BST的插入删除一样。</p>
<img data-src="/2020/07/30/%E5%8C%BA%E9%97%B4%E6%A0%91/%E5%8C%BA%E9%97%B4%E6%A0%911.png" class>
<p>那么我们就来看找重合区间的操作。</p>
<p>Following is algorithm for searching an overlapping interval <em>x</em> in an Interval tree rooted with <em>root</em>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Interval overlappingIntervalSearch(root, x)</span><br><span class="line">1) If x overlaps with root&#39;s interval, return the root&#39;s interval.</span><br><span class="line"></span><br><span class="line">2) If left child of root is not empty and the max  in left child </span><br><span class="line">is greater than x&#39;s low value, recur for left child</span><br><span class="line"></span><br><span class="line">3) Else recur for right child.</span><br></pre></td></tr></table></figure>
<p><strong><em>How does the above algorithm work?</em></strong> Let the interval to be searched be x. We need to prove this in for following two cases.</p>
<p><strong><em>Case 1:</em></strong> <em>When we go to right subtree, one of the following must be true.</em> a) There is an overlap in right subtree: This is fine as we need to return one overlapping interval. b) There is no overlap in either subtree: We go to right subtree only when either left is NULL or maximum value in left is smaller than <em>x.low</em>. So the interval cannot be present in left subtree.</p>
<p><strong><em>Case 2:</em></strong> <em>When we go to left subtree, one of the following must be true.</em> a) There is an overlap in left subtree: This is fine as we need to return one overlapping interval. b) There is no overlap in either subtree: This is the most important part. We need to consider following facts. … We went to left subtree because <em>x.low &lt;= max</em> in left subtree …. max in left subtree is a high of one of the intervals let us say <em>[a, max]</em> in left subtree. …. Since <em>x</em> doesn’t overlap with any node in left subtree <em>x.low</em> must be smaller than ‘<em>a</em>‘. …. All nodes in BST are ordered by low value, so all nodes in right subtree must have low value greater than ‘<em>a</em>‘. …. From above two facts, we can say all intervals in right subtree have low value greater than <em>x.low</em>. So <em>x</em> cannot overlap with any interval in right subtree.</p>
<p><strong>Applications of Interval Tree:</strong> Interval tree is mainly a geometric data structure and often used for windowing queries, for instance, to find all roads on a computerized map inside a rectangular viewport, or to find all visible elements inside a three-dimensional scene (Source <span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcnZhbF90cmVl">Wiki<i class="fa fa-external-link-alt"></i></span>).</p>
<p><strong>Interval Tree vs <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvc2VnbWVudC10cmVlLXNldC0xLXN1bS1vZi1naXZlbi1yYW5nZS8=">Segment Tree<i class="fa fa-external-link-alt"></i></span></strong> Both segment and interval trees store intervals. Segment tree is mainly optimized for queries for a given point, and interval trees are mainly optimized for overlapping queries for a given interval.</p>
<p>区间树和线段树都是存储区间的，不同的是线段是针对给定点的查询进行优化，区间树针对给定区间的重叠查询进行优化。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双蛋问题以及更主要的其更通用化且有用的问题的解</title>
    <url>/2020/07/26/%E5%8F%8C%E8%9B%8B%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E6%9B%B4%E4%B8%BB%E8%A6%81%E7%9A%84%E5%85%B6%E6%9B%B4%E9%80%9A%E7%94%A8%E5%8C%96%E4%B8%94%E6%9C%89%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="题目leetcode-887.-鸡蛋掉落">题目：LeetCode <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VwZXItZWdnLWRyb3Av">887. 鸡蛋掉落<i class="fa fa-external-link-alt"></i></span></h2>
<p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。</p>
<p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p>
<p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p>
<p>你的目标是确切地知道 F 的值是多少。</p>
<p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p>
<p>示例 1：</p>
<p>输入：K = 1, N = 2 输出：2 解释： 鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。 否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。 如果它没碎，那么我们肯定知道 F = 2 。 因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。 示例 2：</p>
<p>输入：K = 2, N = 6 输出：3 示例 3：</p>
<p>输入：K = 3, N = 14 输出：4</p>
<p>提示：</p>
<p>1 &lt;= K &lt;= 100 1 &lt;= N &lt;= 10000</p>
<h2 id="思路">思路</h2>
<h3 id="基本想法">基本想法</h3>
<p>首先，我们可以看到要得到较大的楼层和鸡蛋的答案，小的情况下的结果是有用的分析，这就导致了动态递推。</p>
<p>定义子问题，也就是定义子状态。</p>
<p>我们有两个变量</p>
<ul>
<li>还有多少可以扔的鸡蛋 i ，(0 &lt;= i &lt;= K)</li>
<li>还剩下几层楼来测试 j ，(i &lt;= j &lt;= N)</li>
</ul>
<p>结果就是我们子问题</p>
<p>dp[i][j]就是在还有i个鸡蛋，j层楼的时候，我们要得到这个目标楼层所用的最小次数。</p>
<h3 id="dp方程">DP方程</h3>
<p>初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[1][j] &#x3D; j, j &#x3D; 1...N # one egg, check each floor from 1 to j</span><br><span class="line">dp[i][0] &#x3D; 0, i &#x3D; 1...K # no floor, no drop needed to get the optimal floor</span><br><span class="line">dp[i][1] &#x3D; 1, i &#x3D; 1...K # one floor, only check once</span><br></pre></td></tr></table></figure>
<p>递推方程</p>
<p>为了得到递归关系，我们来考虑一个测试案例。3个鸡蛋和100层楼 对于写一次降落，我可以从1到100中选择楼层，比如我选择25。 这个掉落有2种可能的结果。</p>
<ul>
<li>蛋碎了，我现在有2个蛋，可以选择的楼层变成了1~24。</li>
<li>鸡蛋仍然安全，我仍然有3个鸡蛋，要选择的楼层变成26~100。</li>
</ul>
<p>考虑最坏的情况，用上面的dp定义，我们可以把下一次选择楼层25的情况找目标楼层的情况描述成：</p>
<p>dp[3][100] = 1 + max(dp[2][24], dp[3][75])</p>
<p>除了第25层，对于下次抛下，我们也可以选择1到100层其他楼层。每一次抛下都类似于25层的情况。最终的结果将是所有这些可能的下次抛下的楼层的选择的最小值。</p>
<p>dp[3] [100] = min(..., 1 + max(dp[2] [23], dp[3] [76]), 1 + max(dp[2] [24], dp[3] [75]), 1 + max(dp[2] [25], dp[3] [74]), ...) (拿24、25、26举例)</p>
<p>最终的递推方程是： <span class="math display">\[
dp[i] [j] = 1 + min(max(dp[i-1] [k-1], dp[i] [j-k]))， k = 1, 2, ...，j
\]</span></p>
<h3 id="暴力解法">暴力解法：</h3>
<p>有了刚才的递推公式，暴力解法应该是O(kn^2)时间复杂度</p>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">self, K: int, N: int</span>) -&gt; int:</span></span><br><span class="line">        dp = [[float(<span class="string">&#x27;inf&#x27;</span>)] * (N + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(K + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">1</span>][j] = j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, K + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, j + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = min(dp[i][j],</span><br><span class="line">                                   <span class="number">1</span> + max(dp[i - <span class="number">1</span>][k - <span class="number">1</span>], dp[i][j - k]))</span><br><span class="line">        <span class="keyword">return</span> dp[K][N]</span><br></pre></td></tr></table></figure>
<p>或者减少空间复杂度的下面代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">self, K: int, N: int</span>) -&gt; int:</span></span><br><span class="line">        dp = list(range(N + <span class="number">1</span>))</span><br><span class="line">        _dp = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(K - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">                _dp[j] = <span class="number">1</span> + min(max(dp[k - <span class="number">1</span>], _dp[j - k])</span><br><span class="line">                                 <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, j + <span class="number">1</span>))</span><br><span class="line">            dp, _dp = _dp, dp</span><br><span class="line">        <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure>
<h3 id="优化1对每个dpi-j选择k">优化1，对每个dp[i] [j]选择k</h3>
<p>我们的暴力解法在leetcode上超时了，提示我们要检查for循环中不必要的迭代。更具体的说，为了得到每次抛下最适合的k值，我们不需要遍历从i到j的所有楼层， dp[i] [k]是一个随k的升高而升高的函数。这意味着dp[i-1] [k-1]将会升高而dp[i] [j-k]将会降低，当k从1到j的时候。最优的k值将在中点这两个值相遇的时候。所以为了得到最优的k值，我们可以对k从1到j做一个二分搜索。</p>
<p>这将使得第三个对k循环从O(n)的时间复杂度下降到O(logn)。总时间复杂度是O(knlogn)。使用二分搜索，我们只能做自底向上的dp，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">self, K: int, N: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> j</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> d[i, j]</span><br><span class="line">            lo, hi = <span class="number">0</span>, j</span><br><span class="line">            <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">                mid = (lo + hi) / <span class="number">2</span></span><br><span class="line">                left, right = dfs(i - <span class="number">1</span>, mid - <span class="number">1</span>), dfs(i, j - mid)</span><br><span class="line">                <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                    lo = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    hi = mid</span><br><span class="line">            res = <span class="number">1</span> + max(dfs(i - <span class="number">1</span>, lo - <span class="number">1</span>), dfs(i, j - lo))</span><br><span class="line">            d[i, j] = res</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(K, N)</span><br></pre></td></tr></table></figure>
<h3 id="优化2为每个dpi-1..n-选择-k_1-..-k_n">优化2，为每个dp[i] [1..N] 选择 k_1 .. k_N</h3>
<p>再进一步，到现在为止，我们仍然在为了每个dp[i] [j]寻找从1到j的最优层数k。事实上，我们可以看到，随着j的增加，每个dp[i] [j]的最优楼层k也在增加。这意味着一旦我们得到了dp[i] [j]的最优k，我们就可以保存当前k值，直接开始下一轮的for-loop，而不用再从0开始启动k。这样，在第三个for-loop中，由于j在第二个for-loop中从1到N，k只会从1到N一次，总的时间复杂度为O(kN)。代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">self, K: int, N: int</span>) -&gt; int:</span></span><br><span class="line">        dp = [[float(<span class="string">&#x27;inf&#x27;</span>)] * (N + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(K + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">1</span>][j] = j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, K + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span> k &lt; j + <span class="number">1</span> <span class="keyword">and</span> dp[i][j - k] &gt; dp[i - <span class="number">1</span>][k - <span class="number">1</span>]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[K][N]</span><br></pre></td></tr></table></figure>
<h3 id="优化3空间复杂度">优化3，空间复杂度</h3>
<p>通常情况下，如果dp的递归关系是基于之前状态的恒定长度，我们可以节省一个维度的空间复杂度。在这里，当前行dp[i]是基于当前行和前行得到更新的，所以我们可以只记录这两行，并在迭代过程中进行更新，以节省一维的空间复杂度。最终时间复杂度O(kn)，空间复杂度O(n)。代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">self, K: int, N: int</span>) -&gt; int:</span></span><br><span class="line">        dp = range(N + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, K + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            ndp = [<span class="number">0</span>, <span class="number">1</span>] + [float(<span class="string">&#x27;inf&#x27;</span>)] * (N - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span> k &lt; j + <span class="number">1</span> <span class="keyword">and</span> ndp[j - k] &gt; dp[k - <span class="number">1</span>]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                ndp[j] = <span class="number">1</span> + dp[k - <span class="number">1</span>]</span><br><span class="line">            dp = ndp</span><br><span class="line">        <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure>
<p>优化代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># f(i, j)还剩i个鸡蛋，k层楼，最少需要的次数</span></span><br><span class="line"><span class="comment"># 距离f(2, 100) 2个鸡蛋100层楼</span></span><br><span class="line"><span class="comment"># 选了25层，碎了，没碎</span></span><br><span class="line"><span class="comment">#        max(f(i-1, k-1) , f(i, j-k))</span></span><br><span class="line"><span class="comment"># f(i, j) = min(max(f(i-1, k-1), f(i, j-k))) + 1 for k in 1..j</span></span><br><span class="line"><span class="comment"># 初始化和边界条件</span></span><br><span class="line"><span class="comment"># f(i,1) = 1,一层只需要一次，只要鸡蛋数大于等于1</span></span><br><span class="line"><span class="comment"># f(1,j) = j,一个鸡蛋只能从最低层一个一个实验</span></span><br><span class="line"><span class="comment"># 层数加上一个哨兵0，这样访问索引即是层数，并且当k等于1时，递推到f(i, 0)为0</span></span><br><span class="line"><span class="comment"># 在一层碎了，f(i, 0) = 0</span></span><br><span class="line"><span class="comment"># 返回值，f(K,N)</span></span><br><span class="line"><span class="comment"># 优化复杂度</span></span><br><span class="line"><span class="comment"># 我们的k不用从1开始，随着j的增加，最合适的k层也是在增加的，对于每一个i，我们都重新开始计k</span></span><br><span class="line"><span class="comment"># 在这一轮中，k从上一次最佳开始，最佳的时候f(i-1, k-1) &gt;= f(i, j-k)</span></span><br><span class="line"><span class="comment"># 我们取f(i-1, k-1)，更新f(i, j) = f(i-1,k-1)+1</span></span><br><span class="line"><span class="comment"># 可降低时间复杂度为O(KN)</span></span><br><span class="line"><span class="comment"># 空间复杂度，我们可以使用两个数组滚动</span></span><br><span class="line"><span class="comment"># 一个代表i-1个鸡蛋时，一个表示i个鸡蛋时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">self, K: int, N: int</span>) -&gt; int:</span></span><br><span class="line">        dp = list(range(N + <span class="number">1</span>))</span><br><span class="line">        ndp = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, K + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span> k &lt;= j <span class="keyword">and</span> dp[k - <span class="number">1</span>] &lt; ndp[j - k]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                ndp[j] = dp[k - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            dp, ndp = ndp, dp</span><br><span class="line">        <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>我个人建议按照以下逻辑来思考这个问题。</p>
<ol type="1">
<li>为什么要用dp？在什么情况下我们应该用dp来解决问题？</li>
<li>问题中描述一个状态的基本情况和递归关系是什么？</li>
<li>根据以上分析，dp公式是什么？</li>
<li>实现蛮力解决。</li>
<li>优化：找到dp数组的模式，哪些迭代是不必要的，可以节省的？</li>
<li>时间和空间复杂度是多少？有什么办法可以节省一个维度的空间复杂度？</li>
</ol>
<h2 id="转载感谢">转载感谢</h2>
<p>感谢优秀题解</p>
<p>https://leetcode.com/problems/super-egg-drop/discuss/159079/Python-DP-from-kn2-to-knlogn-to-kn</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>可不可以使用join</title>
    <url>/2020/08/26/%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8join/</url>
    <content><![CDATA[<ol type="1">
<li><p>能不能使用join语句？</p>
<ol type="1">
<li>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，是没问题的。</li>
<li>如果使用Block Nested_Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</li>
</ol></li>
<li><p>如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？</p>
<ol type="1">
<li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</li>
<li>如果是Block Nested-Loop Join算法：
<ul>
<li>在oin_buffer_size足够大的时候，是一样的；</li>
<li>在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。</li>
</ul></li>
<li>所以总是选择小表做驱动表。</li>
</ol></li>
<li><p>什么叫做小表？</p>
<p><strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是”小表“，应该作为驱动表。</strong></p></li>
<li><p>总体来看，不论是在原表上加索引，还是用有索引的临时表，我们的思路都是让 join 语句能够用上被驱动表上的索引，来触发 BKA 算法，提升查询性能。</p></li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的实现(大顶堆、小顶堆)</title>
    <url>/2020/08/07/%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0-%E5%A4%A7%E9%A1%B6%E5%A0%86%E3%80%81%E5%B0%8F%E9%A1%B6%E5%A0%86/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 堆的实现.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxheap</span>(<span class="params">a, i, size</span>):</span></span><br><span class="line">    l = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    r = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">    large = i</span><br><span class="line">    <span class="keyword">if</span> l &lt; size <span class="keyword">and</span> a[l] &gt; a[large]:</span><br><span class="line">        large = l</span><br><span class="line">    <span class="keyword">if</span> r &lt; size <span class="keyword">and</span> a[r] &gt; a[large]:</span><br><span class="line">        large = r</span><br><span class="line">    <span class="keyword">if</span> large != i:</span><br><span class="line">        a[i], a[large] = a[large], a[i]</span><br><span class="line">        maxheap(a, large, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildheap</span>(<span class="params">a, size</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size &gt;&gt; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        maxheap(a, i, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">a, val, size</span>):</span></span><br><span class="line">    a.append(val)</span><br><span class="line">    <span class="keyword">assert</span> a[size - <span class="number">1</span>] == val</span><br><span class="line">    i = size - <span class="number">1</span></span><br><span class="line">    p = i &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> p &gt;= <span class="number">0</span> <span class="keyword">and</span> a[p] &lt; a[i]:</span><br><span class="line">        a[p], a[i] = a[i], a[p]</span><br><span class="line">        i = p</span><br><span class="line">        p = i &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 小顶堆</span></span><br><span class="line"><span class="comment"># def minheap(a, i, size):</span></span><br><span class="line"><span class="comment">#     l = 2 * i + 1</span></span><br><span class="line"><span class="comment">#     r = 2 * i + 2</span></span><br><span class="line"><span class="comment">#     small = i</span></span><br><span class="line"><span class="comment">#     if l &lt; size and a[l] &lt; a[small]:</span></span><br><span class="line"><span class="comment">#         small = l</span></span><br><span class="line"><span class="comment">#     if r &lt; size and a[r] &lt; a[small]:</span></span><br><span class="line"><span class="comment">#         small = r</span></span><br><span class="line"><span class="comment">#     if small != i:</span></span><br><span class="line"><span class="comment">#         a[i], a[small] = a[small], a[i]</span></span><br><span class="line"><span class="comment">#         minheap(a, small, size)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def buildheap(a, size):</span></span><br><span class="line"><span class="comment">#     for i in range(size &gt;&gt; 1, -1, -1):</span></span><br><span class="line"><span class="comment">#         minheap(a, i, size)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 示例</span></span><br><span class="line">    nums = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">    heapsize = len(nums)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建堆</span></span><br><span class="line">    buildheap(nums, heapsize)</span><br><span class="line">    print(nums)</span><br><span class="line">    <span class="comment"># output:</span></span><br><span class="line">    <span class="comment"># [5, 4, 3, 1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 插入</span></span><br><span class="line">    <span class="comment"># nums.append(6)</span></span><br><span class="line">    <span class="comment"># heapsize += 1</span></span><br><span class="line">    <span class="comment"># i = heapsize - 1</span></span><br><span class="line">    <span class="comment"># while i &gt;&gt; 1 &gt;= 0 and nums[i] &gt; nums[i &gt;&gt; 1]:</span></span><br><span class="line">    <span class="comment">#     nums[i], nums[i &gt;&gt; 1] = nums[i &gt;&gt; 1], nums[i]</span></span><br><span class="line">    <span class="comment">#     i &gt;&gt;= 1</span></span><br><span class="line">    <span class="comment"># print(nums)</span></span><br><span class="line">    heapsize += <span class="number">1</span></span><br><span class="line">    insert(nums, <span class="number">6</span>, heapsize)</span><br><span class="line">    print(nums)</span><br><span class="line">    <span class="comment"># output:</span></span><br><span class="line">    <span class="comment"># [6, 5, 4, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除</span></span><br><span class="line">    heapsize -= <span class="number">1</span></span><br><span class="line">    nums[<span class="number">0</span>], nums[heapsize] = nums[heapsize], nums[<span class="number">0</span>]</span><br><span class="line">    maxheap(nums, <span class="number">0</span>, heapsize)</span><br><span class="line">    print(nums)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># output:</span></span><br><span class="line">    <span class="comment"># [5, 2, 3, 1, 0, 4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>学会承担责任</title>
    <url>/2019/12/26/%E5%AD%A6%E4%BC%9A%E6%89%BF%E6%8B%85%E8%B4%A3%E4%BB%BB/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>实现KMP算法</title>
    <url>/2020/07/25/%E5%AE%9E%E7%8E%B0KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>转载自王争老师数据结构与算法之美字符串匹配基础下https://time.geekbang.org/column/article/71845</p>
<h2 id="概述">概述</h2>
<p>字符串匹配算法，可以分为单模式串匹配算法，和多模式串匹配算法，单模式串匹配算法包括了BF（暴力匹配O(m*n)，但因为可以及早停止，实际感觉并没有很差）、RK（O(n)，n为主串长度，利用哈希加速，哈希函数要取好，不要超过int的最大值，遍历一遍主串就可以算出全部n-m+1个哈希值）、BM（Boyer-Moore，性能最好的算法，使用好后缀、坏字符，从最后一个字符开始匹配）、KMP（好前缀、坏字符）四种算法。</p>
<p>这里介绍不是那么复杂的KMP算法。</p>
<p>（PS. 其实个人觉得，要学好算法，语文非常地重要，不亚于数学，要严谨准确而清晰易懂）</p>
<h2 id="思路与算法">思路与算法</h2>
<h3 id="kmp-算法基本原理">KMP 算法基本原理</h3>
<p>在模式串和主串匹配的过程中，把不能匹配的那个字符叫作<strong>坏字符</strong>，把已经匹配的那段字符串叫作<strong>好前缀</strong>。</p>

<p>当遇到坏字符的时候，我们就要把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较。这个比较的过程能否更高效了呢？可以不用一个字符一个字符的比较了吗？</p>

<p>KMP 算法就是在试图寻找一种规律：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性滑动很多位？</p>
<p>我们只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是k。我们把模式串一次性往后滑动 j - k 位，相当于，每次遇到坏字符，我们就把j更新为k，i不变，然后继续比较。</p>

<p>为了表述起来方便，我把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫做<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫做<strong>最长可匹配前缀子串</strong>。</p>

<p>如何来求好前缀的最长可匹配前缀和后缀子串呢？我们发现，这个问题其实不涉及主串，只需要通过模式串本身就能求解。所以，能不能事先预处理计算好，在模式串和主串匹配的过程中，直接拿过来就用呢？</p>
<p>其实和BM算法（后面会讲到）类似，KMP算法可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。我们把这个数组定义为<strong>next数组</strong>（或者叫longest prefix suffix，最长的前缀的后缀的下标，如果到了结尾就用-1表示不存在)，很多书中还给这个数组起了一个名字，叫<strong>失效函数</strong>（failure function）。</p>
<p>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标。这句话有点拗口，举个例子就懂了。</p>

<p>有个next数组，我们很容易就可以实现KMP算法了。我先假设next数组已经计算好了，先给出KMP算法的框架代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KMPSearch</span>(<span class="params">p, s</span>):</span></span><br><span class="line">    m = len(p)</span><br><span class="line">    n = len(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create lps[] that will hold the longest prefix suffix</span></span><br><span class="line">    <span class="comment"># values for pattern</span></span><br><span class="line">    lps = get_lps(p, m)</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span>  <span class="comment"># index for p[]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[i] != p[j]:</span><br><span class="line">            j = lps[j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == p[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j == m:</span><br><span class="line">            <span class="comment"># print(&quot;Found pattern at index &quot; + str(i - j + 1))</span></span><br><span class="line">            <span class="comment"># j = lps[j - 1] + 1</span></span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="失效函数计算方法">失效函数计算方法</h3>
<p>基本原理剪完了，现在来看最复杂的部分，也就是next数组是如何计算的。</p>
<p>当然，我们可以用非常笨的方法，比如要计算下面这个模式串 b 的 next[4]，我们就把 b[0, 4]的所有后缀子串，从长到短找出来，依次看看，是否能跟模式串的前缀子串匹配。很显然，这个方法也可以计算得到 next 数组，但是效率非常低。有没有更加高效的方法呢？</p>

<p>我们按照下标从小到大，依次计算 next 数组的值。当我们要计算 next[i]的时候，前面的 next[0]，next[1]，……，next[i-1]应该已经计算出来了。利用已经计算出来的 next 值，我们是否可以快速推导出 next[i]的值呢？如果 next[i-1]=k-1，也就是说，子串 b[0, k-1]是 b[0, i-1]的最长可匹配前缀子串。如果子串 b[0, k-1]的下一个字符 b[k]，与 b[0, i-1]的下一个字符 b[i]匹配，那子串 b[0, k]就是 b[0, i]的最长可匹配前缀子串。所以，next[i]等于 k。但是，如果 b[0, k-1]的下一字符 b[k]跟 b[0, i-1]的下一个字符 b[i]不相等呢？这个时候就不能简单地通过 next[i-1]得到 next[i]了。这个时候该怎么办呢？</p>
<p>我们假设 b[0, i]的最长可匹配后缀子串是 b[r, i]。如果我们把最后一个字符去掉，那 b[r, i-1]肯定是 b[0, i-1]的可匹配后缀子串，但不一定是最长可匹配后缀子串。所以，既然 b[0, i-1]最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于 b[i]，那么我们就可以考察 b[0, i-1]的次长可匹配后缀子串 b[x, i-1]对应的可匹配前缀子串 b[0, i-1-x]的下一个字符 b[i-x]是否等于 b[i]。如果等于，那 b[x, i]就是 b[0, i]的最长可匹配后缀子串。</p>
<p>可是，如何求得b[0, i-1]的次长可匹配后缀子串呢？次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串又对应最长可匹配前缀子串b[0, y]。于是，查找b[0, i-1]的次长可匹配后缀子串，这个问题就变成，查找b[0, y]的最长匹配后缀子串，其中y = next[i-1]</p>

<p>按照这个思路，我们可以考察完所有的 b[0, i-1]的可匹配后缀子串 b[y, i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于 b[i]，那这个 b[y, i]就是 b[0, i]的最长可匹配后缀子串。</p>
<p>前面已经给出 KMP 算法的框架代码了，现在把这部分的代码也写出来了。这两部分代码合在一起，就是整个 KMP 算法的代码实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lps</span>(<span class="params">p, m</span>):</span></span><br><span class="line">    lps = [<span class="number">-1</span>] * m</span><br><span class="line">    k = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">while</span> k != <span class="number">-1</span> <span class="keyword">and</span> p[k + <span class="number">1</span>] != p[i]:</span><br><span class="line">            k = lps[k]</span><br><span class="line">        <span class="keyword">if</span> p[k + <span class="number">1</span>] == p[i]:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        lps[i] = k</span><br><span class="line">    <span class="keyword">return</span> lps</span><br></pre></td></tr></table></figure>
<h2 id="最后整体的实现">最后整体的实现</h2>
<p>Python3版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KMPSearch</span>(<span class="params">self, p, s</span>):</span></span><br><span class="line">        <span class="comment"># 特判</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = len(p), len(s)</span><br><span class="line">        lps = self.get_lps(p, m)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> j != <span class="number">0</span> <span class="keyword">and</span> s[i] != p[j]:</span><br><span class="line">                j = lps[j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == p[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == m:</span><br><span class="line">                <span class="comment"># return i - m + 1</span></span><br><span class="line">                print(<span class="string">&quot;find at &#123;&#125;&quot;</span>.format(i - m + <span class="number">1</span>))</span><br><span class="line">                j = lps[j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_lps</span>(<span class="params">self, p, m</span>):</span></span><br><span class="line">        lps = [<span class="number">-1</span>] * m</span><br><span class="line">        k = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">while</span> k != <span class="number">-1</span> <span class="keyword">and</span> p[i] != p[k + <span class="number">1</span>]:</span><br><span class="line">                k = lps[k]</span><br><span class="line">            <span class="keyword">if</span> p[i] == p[k + <span class="number">1</span>]:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            lps[i] = k</span><br><span class="line">        <span class="keyword">return</span> lps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    sol = Solution()</span><br><span class="line"></span><br><span class="line">    s = <span class="string">&quot;abcruizheuhuruizheaasdasd&quot;</span></span><br><span class="line">    p = <span class="string">&quot;ruizhe&quot;</span></span><br><span class="line">    res = sol.KMPSearch(p, s)</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉搜索树、B树、B+树、B*树理解</title>
    <url>/2020/07/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="平衡二叉搜索树">平衡二叉搜索树</h2>
<h3 id="概念">概念：</h3>
<p>平衡二叉搜索是基于二分法的策略提高数据的查找速度的二叉树的数据结构；</p>
<h3 id="特点">特点：</h3>
<p>平衡二叉搜索树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少物管数据的检索，大大提升了数据检索的速度；平衡二叉树的数据结构组转过程有以下规则。</p>
<ol type="1">
<li>非叶子节点只能允许最多两个子节点存在；</li>
<li>每一个非叶子节点的左子树上所有结点都小于当前节点的值，右子树上所有结点都大于当前节点的值；</li>
<li>树左右两边的层级数相差不会大于1；</li>
<li>没有值相等重复的结点；</li>
<li>左右子树也是平衡二查搜索树。</li>
</ol>
<h2 id="b树">B树</h2>
<h3 id="概念-1">概念：</h3>
<p>B树和二叉树稍有不同的是B树属于多叉树又名平衡多路搜索树（查找路径不只两个）。</p>
<h3 id="规则">规则：</h3>
<ol type="1">
<li>排序方式：所有结点关键字是按递增次序排列，并遵循左小右大原则；</li>
<li>子节点数：非叶子节点的子节点数&gt;1，且&lt;=M，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路，当M=2是时二叉树，M=3时是三叉）；</li>
<li>关键字数：枝结点的关键字数量大于等于ceil(M/2)-1 且小于等于M-1个（ceil是向正无穷方向取整的函数，如ceil(1.1) = 2）;</li>
<li>所有叶子节点都在同一层、叶子节点除了包含了关键字和关键字记录的指针外，也有指向其子节点的指针，只不过其指针地址都为null，对应下图最后一层节点的空格子。</li>
</ol>
<p>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）</p>
<img data-src="/2020/07/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%90%86%E8%A7%A3/B%E6%A0%91.jpg" class>
<ul>
<li><p>B树的查找流程</p>
<p>如上图如果要从上图中找到E字母，查找流程如下</p>
<ol type="1">
<li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往左找到左边的子节点</li>
<li>拿到关键字D和G，D&lt;E&lt;G所以直接找到D和G中间的节点。</li>
<li>拿到E和F，因为E=E所以直接返回关键字和指针信息（如果树结构立面没有包含所要查找的节点则返回null)；</li>
</ol></li>
<li><p>B树的插入节点流程</p>
<p>定义一个5阶树（平衡五路搜索树），现在我们要把3，8，31，11，23，29，50，28这些数字构建一个5阶树出来；</p>
<p>遵循规则：</p>
<ol type="1">
<li>节点拆分规则：单签是要组成一个5路搜索树，那么此时m=5，关键字数必须&lt;=5-1（这里关键字数&gt;4就要进行节点拆分）；</li>
<li>排序规则：满足节点本身比左子树左右节点大，比右子树所有节点小的排序规则。</li>
</ol>
<p>先插入3、8、31、11</p>
<img data-src="/2020/07/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%90%86%E8%A7%A3/B%E6%A0%912.jpg" class>
<p>再插入23、29</p>
<img data-src="/2020/07/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%90%86%E8%A7%A3/B%E6%A0%913.png" class>
<p>再插入50、28</p>
<img data-src="/2020/07/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%90%86%E8%A7%A3/B%E6%A0%914.png" class></li>
<li><p>B树节点的删除</p>
<p>规则：</p>
<ol type="1">
<li>节点合并规则：当前是要组成一个5路查找树，那么此时m=5，关键字数必须大于等于ceil(5/2)-1（这里就是关键字数&lt;2就要进行节点合并）</li>
<li>满足节点本身比左子树所有结点大，比右子树所有结点小的排序规则；</li>
<li>关键字数小于二时先从子节点取，子节点没有符合条件时就向父节点取，取中间值往父节点放；</li>
</ol>
<img data-src="/2020/07/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%90%86%E8%A7%A3/B%E6%A0%915.png" class>
<h3 id="特点-1">特点：</h3>
<p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p></li>
</ul>
<h2 id="b树-1">B+树</h2>
<h3 id="概念-2">概念：</h3>
<p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。</p>
<h3 id="规则-1">规则：</h3>
<ol type="1">
<li>B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</li>
<li>B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li>
<li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li>
<li>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料，这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的。Mysql 的B+树是用第一种方式实现）;</li>
</ol>
<img data-src="/2020/07/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%90%86%E8%A7%A3/B%E6%A0%916.jpg" class>
<img data-src="/2020/07/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%90%86%E8%A7%A3/B%E6%A0%917.jpg" class>
<h3 id="特点-2">特点：</h3>
<ol type="1">
<li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li>
<li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li>
<li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>
<li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ol>
<p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p>
<h2 id="b树-2">B*树</h2>
<h3 id="规则-2">规则：</h3>
<p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p>
<p>（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是ceil(m/2)，b树的初始化个数为（ceil(2/3*m)</p>
<p>（2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</p>
<h3 id="特点-3">特点：</h3>
<p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额外分解次数变得更少；</p>
<img data-src="/2020/07/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E7%90%86%E8%A7%A3/B%E6%A0%918.jpg" class>
<h2 id="总结">总结</h2>
<p><strong>1、相同思想和策略</strong></p>
<p>从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p>
<p><strong>2、不同的方式的磁盘空间利用</strong></p>
<p>不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集侦查无向图中的环</title>
    <url>/2020/08/21/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BE%A6%E6%9F%A5%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%8E%AF/</url>
    <content><![CDATA[<p>并查集是一种数据结构，它跟踪一个集合的元素被分割成若干不相干（不重叠）的子集。union-find算法是一种对这种数据结构执行两种有用操作的算法：</p>
<p>Find：确定一个特定的元素在哪个子集里。这可以用来确定两个元素是否在同一个子集中。</p>
<p>Union：将两个子集连接成一个单一的子集。</p>
<p>在这篇文章中，我们将讨论并查集的应用。这个应用就是检查一个给定的图是否有环。</p>
<p>UnionFInd算法可以检查一个无向图是否有环。注意到我们已经讨论过一种检查环的<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvZGV0ZWN0LWN5Y2xlLXVuZGlyZWN0ZWQtZ3JhcGgvP3JlZj1sYnA=">方法<i class="fa fa-external-link-alt"></i></span>。这是另一种使用并查集的防范。这个方法假设图中没有自环。</p>
<p>我们可以在一个1D数组中跟踪子集，我们称它为parent[]。</p>
<p>我们考虑如下图：</p>
<img data-src="/2020/08/21/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BE%A6%E6%9F%A5%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%8E%AF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BE%A6%E6%9F%A5%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%8E%AF.png" class>
<p>对于每条边，用边的两个顶点做子集。如果两个顶点都已经在同一个子集中，就发现了一个环。</p>
<p>初始化时，parent的所有槽位都初始化为-1（意味着每个子集中只有一个项目）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0   1   2</span><br><span class="line">-1 -1  -1 </span><br></pre></td></tr></table></figure>
<p>现在逐一处理所有的边。</p>
<p>边0-1：找到顶点0和1所在的子集。由于它们在不同的子集中，我们对它们进行union操作。为了取union，可以让结点0作为节点1的父结点，或者反之。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0   1   2    &lt;----- 1 is made parent of 0 (1 is now representative of subset &#123;0, 1&#125;)</span><br><span class="line">1  -1  -1</span><br></pre></td></tr></table></figure>
<p>边1-2：1已经在subset 1中，2在subset 2中，所以取union</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0   1   2    &lt;----- 2 is made parent of 1 (2 is now representative of subset &#123;0, 1, 2&#125;)</span><br><span class="line">1   2  -1</span><br></pre></td></tr></table></figure>
<p>边0-2：0在subset 2中，2也在subset 2中。因此，包括这条边形成了一个环。</p>
<p>为什么0的子集和和2相同？</p>
<p>0-&gt;1-&gt;2 // 1是0的父结点2是1的父结点。</p>
<p>根据以上解释，下面是实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># undirected_graph.py</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k</span>):</span></span><br><span class="line">        self.uf = [<span class="number">-1</span>] * (k + <span class="number">1</span>)</span><br><span class="line">        self.sets_count = k</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, p</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.uf[p] &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        self.uf[p] = self.find(self.uf[p])</span><br><span class="line">        <span class="keyword">return</span> self.uf[p]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">        p_root = self.find(p)</span><br><span class="line">        q_root = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> p_root == q_root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.uf[p_root] &gt; self.uf[q_root]:</span><br><span class="line">            self.uf[q_root] += self.uf[p_root]</span><br><span class="line">            self.uf[p_root] = q_root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.uf[p_root] += self.uf[q_root]</span><br><span class="line">            self.uf[q_root] = p_root</span><br><span class="line">        self.sets_count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.find(p) == self.find(q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vertices</span>):</span></span><br><span class="line">        self.V = vertices</span><br><span class="line">        self.graph = defaultdict(list)</span><br><span class="line">        self.uf = UnionFind(vertices)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addEdge</span>(<span class="params">self, u, v</span>):</span></span><br><span class="line">        self.graph[u].append(v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCyclic</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.graph:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> self.graph[i]:</span><br><span class="line">                <span class="keyword">if</span> self.uf.is_connected(i, j):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                self.uf.union(i, j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    g = Graph(<span class="number">3</span>)</span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    g.addEdge(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    g.addEdge(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">    print(g.isCyclic())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>弱小和无知不是生存的障碍，傲慢才是--《三体》</title>
    <url>/2020/02/25/%E5%BC%B1%E5%B0%8F%E5%92%8C%E6%97%A0%E7%9F%A5%E4%B8%8D%E6%98%AF%E7%94%9F%E5%AD%98%E7%9A%84%E9%9A%9C%E7%A2%8D%EF%BC%8C%E5%82%B2%E6%85%A2%E6%89%8D%E6%98%AF-%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序的多种写法</title>
    <url>/2020/08/11/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<p>快速排序作为一种基础的算法，广泛用于各种语言的内置排序库中，其中java使用了双基准快速排序（主要是双基准更有效的利用了计算机的缓存机制）。它是一种原地的，空间复杂度为O(1)、时间复杂度O(nlogn)、不稳定的排序算法。分为切分，和递归两个步骤。其中切分的步骤可以帮助我们以O(n)的时间复杂度找到数组中某种排名为K的元素。然而在实际实现中，快排有一些小技巧，也是我们必须要掌握的一种算法。</p>
<p>以下给出python版本的实现代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">self, nums: List[int]</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.quickSortHelper(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSortHelper</span>(<span class="params">self, nums, l, r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pivot = self.partition(nums, l, r)</span><br><span class="line">        self.quickSortHelper(nums, l, pivot - <span class="number">1</span>)</span><br><span class="line">        self.quickSortHelper(nums, pivot + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def partition(self, nums, l, r):</span></span><br><span class="line">    <span class="comment">#     ran = random.randint(l, r)</span></span><br><span class="line">    <span class="comment">#     nums[r], nums[ran] = nums[ran], nums[r]</span></span><br><span class="line">    <span class="comment">#     pivot = r</span></span><br><span class="line">    <span class="comment">#     right = l</span></span><br><span class="line">    <span class="comment">#     for i in range(l, r):</span></span><br><span class="line">    <span class="comment">#         if nums[i] &lt;= nums[pivot]:</span></span><br><span class="line">    <span class="comment">#             nums[i], nums[right] = nums[right], nums[i]</span></span><br><span class="line">    <span class="comment">#             right += 1</span></span><br><span class="line">    <span class="comment">#     nums[right], nums[pivot] = nums[pivot], nums[right]</span></span><br><span class="line">    <span class="comment">#     return right</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, nums, l, r</span>):</span></span><br><span class="line">        ran = random.randint(l, r)</span><br><span class="line">        nums[l], nums[ran] = nums[ran], nums[l]</span><br><span class="line">        pivot = l</span><br><span class="line">        left = r</span><br><span class="line">        i = l + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= left:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= nums[pivot]:</span><br><span class="line">                nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        nums[left], nums[pivot] = nums[pivot], nums[left]</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p>两个partition的效果是一样的。</p>
<p>注意，我们使用一种随机方法，保证了我们的快排在遇到严格递增序列或者严格递减序列的时候，期望也是O(nlogn)时间复杂度的。这是一种随机方法，还有其他随机算法的实现。这种比较简单。而这个随机的步骤，也使得我们的快排不是稳定。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么最快地复制一张表？</title>
    <url>/2020/08/28/%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>我在上一篇文章最后，给你留下的问题是怎么在两张表中拷贝数据。如果可以控制对源表的扫描行数和加锁范围很小的话，我们简单地使用insert..select语句即可实现。</p>
<p>当然，为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表。这时，有两种常用的方法。接下来的内容，我会和你详细展开一下这两种方法。</p>
<p>为了便于说明，我还是先创建一个表db1.t，并插入1000行数据，同时创建一个相同结构的db2.t。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db1;</span><br><span class="line"><span class="keyword">use</span> db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line">delimiter;;</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">     <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">     while (i &lt;= 1000)do</span><br><span class="line">            <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i,i);</span><br><span class="line">           <span class="keyword">set</span> i = i + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">  <span class="keyword">end</span>;;</span><br><span class="line">delimiter;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db2;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db2.t <span class="keyword">like</span> db1.t; </span><br></pre></td></tr></table></figure>
<p>假设，我们要把db1.t里面a&gt;900的数据行导出来，插入到db2.t中。</p>
<h3 id="mysqldump方法">mysqldump方法</h3>
<p>一种方法是，使用mysqldump命令将数据导出成一组INSERT语句。你可以使用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -h<span class="variable">$host</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> --add-locks=0 --no-create-info --single-transaction  --<span class="built_in">set</span>-gtid-purged=OFF db1 t --<span class="built_in">where</span>=<span class="string">&quot;a&gt;900&quot;</span> --result-file=/client_tmp/t.sql</span><br></pre></td></tr></table></figure>
<p>把结果输出到临时文件。</p>
<p>这条命令中，主要参数含义如下：</p>
<ol type="1">
<li>--single-transaction的作用是，在导出数据的时候不需要对表db1.t加表锁，而是使用START TRANSACTION WITH CONSISTENT SNAPSHOT的方法；</li>
<li>--add-locks设置为0，表示在输出文件结果里，不增加"LOCK TABLES t WRITE;";</li>
<li>--no-create-info的意思是，不需要导出表结构。</li>
<li>--set-gtid-purged=off表示的是，不输出跟GTID相关的信息；</li>
<li>--result-file指定了输出文件的路径，其中client表示生成的文件是在客户端机器上的；</li>
</ol>
<p>通过这条mysqldump命令生成的t.sql文件中就包含了如图1所示的INSERT语句。</p>
<img data-src="/2020/08/28/%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%9F/%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A81.png" class>
<p>可以看到，一条INSERT语句里面会包含多个value对，这是为了后续用这个文件来写入数据的时候，执行速度可以更快。</p>
<p>如果你希望生成的文件中一条INSERT语句只插入一行数据的话，可以在执行mysqldump命令时，加上参数--skip-extended-insert。</p>
<p>然后，你可以通过下面这条命令，将这些INSERT语句放到db2库里去执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -h127.0.0.1 -P13000  -uroot db2 -e <span class="string">&quot;source /client_tmp/t.sql&quot;</span></span><br></pre></td></tr></table></figure>
<p>需要说明的是，source并不是一条SQL语句，而是一个客户端命令。mysql客户端执行这个命令的流程是这样的：</p>
<ol type="1">
<li>打开文件，默认以分号为结尾读取一条条的SQL语句；</li>
<li>将SQL语句发送到服务端执行。</li>
</ol>
<p>也就是说，服务端执行并不是这个"source t.sql"语句，而是INSERT语句。所以，不论是在慢查询日志（slow log），还是在binlog，记录的都是这些要被真正执行的INSERT语句。</p>
<h3 id="导出csv文件">导出CSV文件</h3>
<p>另一种方法是直接将结果导出成.csv文件。MySQL提供了下面的语法，用来将查询结果导出到服务端本地目录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> db1.t <span class="keyword">where</span> a&gt;<span class="number">900</span> <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">&#x27;/server_tmp/t.csv&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>我们在使用这条语句时，需要注意如下几点。</p>
<ol type="1">
<li>这条语句会将结果保存在服务端。如果你执行命令的客户端和MySQL服务端不在同一个机器上，客户端机器的临时目录下是不会生辰恶搞t.csv文件的。</li>
<li>into outfile指定了文件的生成位置（/server_tmp/)，这个位置必须受参数secure_file_priv的限制。参数secure_file_priv的可选值和作用分别是：
<ul>
<li>如果设置为empty，表示不限制文件生成的位置，这是不安全的设置；</li>
<li>如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</li>
<li>如果设置为NULL，就表示禁止在MySQL实例上执行select...into outfile操作。</li>
</ul></li>
<li>这条命不会帮你覆盖文件，因此你需要确保/server_tmp/t.csv这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。</li>
<li>这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上'\'这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。</li>
</ol>
<p>得到.csv导出文件后，你就可以用下面的load data命令将数据导入到目标表db2.t中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">&#x27;/server_tmp/t.csv&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> db2.t;</span><br></pre></td></tr></table></figure>
<p>这条语句的执行流程如下所示。</p>
<ol type="1">
<li>打开文件/server_tmp/t.csv，以制表符(\t)作为字段间的分隔符，以换行符(\n)作为记录之间的分隔符，进行数据读取；</li>
<li>启动事务。</li>
<li>判断每一行的字段数与表db2.t是否相同；
<ul>
<li>若不相同，则直接报错，事务回滚；</li>
<li>若相同，则构造成一行，调用InnoDB引擎接口，写入到表中。</li>
</ul></li>
<li>重复步骤3，直到/server_tmp/t.csv整个文件读入完成，提交事务。</li>
</ol>
<p>你可能会有一个疑问，<strong>如果binlog_format=statement，这个load语句记录到binlog里以后，怎么在备库重放呢？</strong></p>
<p>由于/server_tmp/t.csv文件只保存在主库所在的主机上，如果只是把这条语句原文写到binlog中，在备库执行的时候，备库的本地机器上没有这个文件，就会导致主备同步停止。</p>
<p>所以，这条语句执行的完整流程，其实是下面这样的。</p>
<ol type="1">
<li>主库执行完成后，将/server_tmp/t.csv文件的内容直接写到binlog文件中。</li>
<li>往binlog文件中写入语句load data local infile '/tmp/SQL_LOAD_MB-1-0' INTO TABLE `db2`.`t`。</li>
<li>把这个binlog日志传到备库。</li>
<li>备库的apply线程在执行这个事务日志时：
<ol type="1">
<li>先将binlog中的t.csv文件的内容读出来，写入到本地临时目录/tmp/SQL_LOAD_MB-1-0中；</li>
<li>再执行load data语句，往备库的db2.t表中插入跟主库相同的数据。</li>
</ol></li>
</ol>
<p>执行流程如下图所示：</p>
<img data-src="/2020/08/28/%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%9F/%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A82.jpg" class>
<p>注意，这里备库执行的load data语句里面，多了一个”local“。它的意思是”将执行这条命令的客户端所在机器的本地文件/tmp/SQL_LOAD_MB-1-0的内容，加载到目标表db2.t中“。</p>
<p>也就是说，<strong>load data 命令有两种用法：</strong></p>
<ol type="1">
<li>不加"local"，是读取服务端的文件，这个文件必须在secure_file_priv指定的目录或子目录下；</li>
<li>加上"local"，读取的是客户端的文件，只要mysql客户端有访问这个文件的权限即可。这时候，MySQL客户端会先把本地文件传给服务端，然后执行上述的load data流程。</li>
</ol>
<p>另外需要注意的是，<strong>select...into outfile 方法不会生成表结构文件</strong>，所以我们导数据时还需要单独的命令得到表结构定义。mysqldump提供了一个--tab参数，可以同时导出表结构定义文件和csv文件。这条命令的使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -h<span class="variable">$host</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> ---single-transaction  --<span class="built_in">set</span>-gtid-purged=OFF db1 t --<span class="built_in">where</span>=<span class="string">&quot;a&gt;900&quot;</span> --tab=<span class="variable">$secure_file_priv</span></span><br></pre></td></tr></table></figure>
<p>这条命令会在$secure_file_priv定义的目录下，创建一个t.sql文件保存建表语句，同时创建一个t.txt保存CSV数据。</p>
<h3 id="物理拷贝方法">物理拷贝方法</h3>
<p>前面我们提到的mysqldump方法和导出CSV文件的方法，都是逻辑导数据的方法，也就是将数据从表db1.t中读出来，生成文本，然后再写入目标表db2.t中。</p>
<p>你可能回文，有物理导数据的方法吗？比如，直接把db1.t表的.frm文件和.ibd文件拷贝到db2目录下，是否可行呢？</p>
<p>答案是不行的。</p>
<p>因为，一个InnoDB表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两个文件的话，因为数据字典中没有db2.t这个表，系统是不会识别和接收它们的。</p>
<p>不过，在MySQL5.6版本引入了<strong>可传输表空间</strong>（transportable tablespace）的方法，可以通过导出+导入表空间的方式，实现物理拷贝表的功能。</p>
<p>假设我们现在的目标是在db1库下，复制一个跟表t相同的表r，具体的执行步骤如下：</p>
<ol type="1">
<li>执行 create table r like t，创建一个相同表结构的空表；</li>
<li>执行alter table r discard tablespace，这时候r.ibd文件会被删除；</li>
<li>执行flush table t for export，这时候db1目录下会生成一个t.cfg文件；</li>
<li>在db1目录下执行cp t.cfg r.cfg; cp t.ibd r.ibd; 这两个命令（这里需要注意的是，拷贝得到的两个文件，MySQL进程要有读写权限）；</li>
<li>执行unlock tables，这时候t.cfg文件会被删除；</li>
<li>执行alter table r import tablesapce，将这个r.ibd文件作为表r的新的表空间，由于这个文件的数据内容和t.ibd是相同的，所以表r中就有了和表t相同的数据。</li>
</ol>
<p>至此，拷贝表数据操作就完成了。这个流程的执行过程图如下：</p>
<img data-src="/2020/08/28/%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%9F/%E6%80%8E%E4%B9%88%E6%9C%80%E5%BF%AB%E5%9C%B0%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A83.jpg" class>
<p>关于拷贝表的这个流程，有以下几个注意点：</p>
<ol type="1">
<li>在第3步执行完flush table命令之后，db1.t整个表处于只读状态，直到执行unlock tables命令后才释放读锁；</li>
<li>在执行import tablespace的时候，为了让文件里的表空间id和数据字典中的一致，会修改r.ibd的表空间id。而这个表空间id存在于每一个数据页中。因此，如果是一个很大的文件（比如TB级别），每个数据页都需要修改，所以你会看到这个import语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import语句的耗时是非常短的。</li>
</ol>
<h3 id="小结">小结</h3>
<p>今天这篇文章，我和你介绍了三种将一个表的数据导入到另外一个表中的方法。</p>
<p>我们来对比一下这三种方法的优缺点。</p>
<ol type="1">
<li>物理拷贝的方式速度最快，尤其对于大表拷贝来说是最快的方法。如果出现误删表的情况，用备份恢复出误删之前的临时库，然后再把临时库的表拷贝到生产库上，是恢复数据最快的方法。但是，这种方法的使用也有一定的局限性：
<ul>
<li>必须是全表拷贝，不能只拷贝部分数据；</li>
<li>需要到服务器上拷贝数据，在用户无法登陆数据库主机的场景下无法使用；</li>
<li>由于是通过拷贝物理文件实现的，源表和目标表都是使用InnoDB引擎时才能使用。</li>
</ul></li>
<li>用mysqldump生成包含INSERT语句文件的防范，可以在where参数增加锅炉条件，来实现只导出部分数据。这个方式的不足之一是，不能使用join这种比较复杂的where条件写法。</li>
<li>用select...into outfile的方法是最灵活的，支持所有的SQL写法。但，这个方法的缺点之一就是，每次只能导出一张表的数据，而且表结构也需要另外的语句单独备份。</li>
</ol>
<p>后两种都是逻辑备份的方式，是可以跨引擎使用的。</p>
<p>最后，我给你留下一个思考题吧。</p>
<p>我们前面介绍binlog_format=statement的时候，binlog记录的load data命令是带local的。既然这条命令是发送到备库去执行的，那么备库执行的时候也是本地执行，为什么需要这个local呢？如果写到binlog中的命令不带local，又会出现什么问题呢？</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>总结：MySQL中的锁和MySQL的内部临时表</title>
    <url>/2020/08/29/%E6%80%BB%E7%BB%93%EF%BC%9AMySQL%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<p>按照锁的粒度（级别、密度）分，MySQL有三种级别的锁：页级、表级、行级。</p>
<p>1、表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最</p>
<p>高，并发度最低。</p>
<p>2、行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最</p>
<p>低，并发度也最高。</p>
<p>3、页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表</p>
<p>锁和行锁之间，并发度一般。</p>
<p>按禁止的操作可分为读锁和写锁，其中，互斥的关系如下</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>读锁</th>
<th>写锁</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>读锁</strong></td>
<td>不互斥</td>
<td>互斥</td>
</tr>
<tr class="even">
<td><strong>写锁</strong></td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody>
</table>
<h3 id="一些重要的锁">一些重要的锁：</h3>
<h4 id="mdl锁-metadata-lock-元数据锁">MDL锁 metadata lock 元数据锁</h4>
<p>用于解决或保证DDL操作与DML操作之间的一致性。</p>
<p>属于表级锁。</p>
<h4 id="间隙锁">间隙锁</h4>
<p>间隙锁加锁规则详见丁奇老师的<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83NTY1OQ==">文章<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="自增id锁">自增id锁</h4>
<h4 id="trx_id锁">trx_id锁</h4>
<p>涉及到竞争资源，很多处都有锁。</p>
<p>小结一下：表锁、行锁、间隙锁（next-key lock）、自增id锁，MDL metadata lock 元数据锁</p>
<h3 id="mysql什么时候会使用内部临时表">MySQL什么时候会使用内部临时表？</h3>
<ol type="1">
<li>如果语句执行过程可以一边读数据，一遍直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li>
<li>join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；</li>
<li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union需要用到唯一索引约束，group by还需要用到另外一个字段来存累积计数。</li>
</ol>
<h3 id="mysql常用操作">MySQL常用操作</h3>
<ol type="1">
<li>explain查看命令优化器优化结果；</li>
<li>show engine innodb status;</li>
<li>show warnings，看优化器改写后的语句；</li>
<li>show create table t; 查看t的建表语句；</li>
</ol>
<h3 id="mysql中的重要概念">MySQL中的重要概念</h3>
<ol type="1">
<li><strong>MVCC（Multi View Concurrent Control）多视图并发控制</strong>，可重复读（RR，repeatable read）隔离级别下提供一致性视图的重要概念。以及MySQL巧妙的使用了undoLog来完成这些。</li>
<li>redoLog，undoLog，binLog重要概念。</li>
<li>索引的<strong>最左前缀规则</strong>（前缀索引规则），利用最左前缀规则，节省索引数量，节省空间。</li>
<li>error log 错误日志，slow log慢查询日志</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>今生就是我们的哨岗，站好哨就可以了</title>
    <url>/2020/08/27/%E6%88%91%E6%9C%AC%E5%B0%B1%E8%82%A4%E6%B5%85%EF%BC%8C%E4%BD%86%E6%88%91%E5%90%91%E5%BE%80%E5%B4%87%E9%AB%98/</url>
    <content><![CDATA[<p>人生唯一确定的就是不确定的人生。人的有限性就体现在，我们是无法寻找到从我们自己而来的一个确定。</p>
<p>第一还是阅读，跟人类伟大的灵魂对话，因为你的困惑在两千多年前人类就已经有过这样的困惑。人类所有伟大的思想家都试图对抗这种困惑。</p>
<p>但第二的话更重要的是去做，做一些事情，从身边的小事开始做起。每天都只是一个礼物，昨天的已经成为过去，明天还没有到来，我们唯一能够拥有的就是今天。所以今天是一个礼物，是一个gift，是一个present。所以我们做好每天该做的事情。<strong>今生就是我们的哨岗，站好哨就可以了。</strong></p>
<p>人的内心始终有两面，一面有幽暗的一面，一面有光明的一面，你做哪一面？是做幽暗的一面，还是做光明的一面？<strong>人不是做自己，人是朝着人性中良善的那一面去前进，去尽量地抑制自己内心的幽暗。这个叫做自己。</strong></p>
<p><strong>接收自己的有限，去迎接未知的无限。</strong></p>
<p>感谢罗翔罗老师。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>拔智齿</title>
    <url>/2020/07/11/%E6%8B%94%E6%99%BA%E9%BD%BF/</url>
    <content><![CDATA[<p>我一共有四颗智齿，上面两颗长的过程中有坏的现象，去年已经一并拔去。</p>
<p>因为这个手术不大，所以两颗智齿可以一起拔。晚上疼了一会，就过去了。</p>
<p>下面的两颗智齿，在长的过程中是横着长的，其实这是很常见的现象，如果不管，会挤坏掉好牙。</p>
<p>上周已经拔掉了一颗，医生在伤口上缝了针，也是疼了一晚上，没吃止痛药，甚至没吃消炎药，也好了。</p>
<p>今天，要拔最后一颗智齿了，至此困扰我的四颗智齿都将拔除。</p>
<p>按医生的话，我满口的牙也将从左右上下32颗变成28颗，不会再忍受因为智齿而难以刷干净的牙缝。</p>
<p>一切都是好兆头。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>拔智齿II</title>
    <url>/2020/07/12/%E6%8B%94%E6%99%BA%E9%BD%BFII/</url>
    <content><![CDATA[<p>上午11：30</p>
<p>大约10点开始拔的智齿，医生很温柔。用针都是很慢的，一针麻醉之后，渐渐的从舌根麻到舌尖。我这时心里挺安定的，既来之则安之。医生大概就用了20分钟。左下这颗智齿就拔完了。缝合的医生来缝了两针，就咬上了棉花止血。我出去坐在了椅子上，使劲咬着，没什么痛感，就是麻。这时大概10点40。坐了好一会，大概11点20，我打开手机，买了医生叮嘱昨天去药店还没买到的替硝唑，加上昨天买的罗红霉素，两种消炎药已经备齐了。拔牙的时候，听见医生说，现在手段都高级了，以前他拔牙的时候，北大医学院的医生，也要上锤子去拔，他疼了半个月。今天他给我做的是最微创的一种。两三天就好了，一天就能吃东西了。大概到了11点半，棉花咬得差不多了，医生叫进屋里要看一看血止的情况。我吐掉棉花球，医生看了看，血已经不流了。挺好，就可以走了。在11点半左右，我感谢了医生，走出了医院。伴随我的四颗智齿至此都已拔除。人的牙一共有32颗，我完成了很多人都会做的拔智齿，也和很多人一样还剩下28颗。</p>
<p>现在敷着冰袋。没什么痛感。挺好的。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>拔智齿后记</title>
    <url>/2020/07/17/%E6%8B%94%E6%99%BA%E9%BD%BF%E5%90%8E%E8%AE%B0/</url>
    <content><![CDATA[<p>还记得刚拔完最后一颗智齿那天，去超市买了一个西瓜，虽然不能张口吃东西，甚至不能说话，但是买了西瓜，冰镇着，心里就很高兴。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>接口限流算法：漏桶算法 &amp; 令牌桶算法</title>
    <url>/2020/07/22/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%EF%BC%9A%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概念">概念</h2>
<p>工作中对外提供的API接口设计都要考虑限流，如果不考虑限流，会造成系统的连锁反应，轻者响应缓慢，重者系统宕机，整个业务线崩溃，如何应对这种情况呢，我们可以对请求进行引流或者直接拒绝等操作，保持系统的可用性和稳定性，防止因流量暴增而导致的系统运行缓慢或宕机。</p>
<p>在开发高并发系统时有三把利器用来保护系统：<strong>缓存、降级和限流</strong></p>
<p><strong>缓存：</strong>缓存的目的是提升系统访问速度和增大系统处理容量</p>
<p><strong>降级：</strong>降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行</p>
<p><strong>限流：</strong>限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理</p>
<h2 id="限流算法">限流算法</h2>
<p>常用的限流算法有<strong>令牌桶</strong>和<strong>漏桶</strong>，而Google开源项目Guava中的RateLimiter使用的就是令牌桶控制算法。</p>
<h3 id="漏桶算法">漏桶算法</h3>
<p>把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而水不够快时就会导致水直接溢出，即拒绝服务。</p>
<img data-src="/2020/07/22/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%EF%BC%9A%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%951.png" class>
<p>漏斗有一个进水口和一个出水口，出水口以一定速率出水，并且有一个最大出水率：</p>
<p>在漏斗中没有水的时候，</p>
<ul>
<li>如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，此时，不会积水</li>
<li>如果进水速率大于最大出水速率，那么，漏斗以最大速率出水，此时，多于的水会积在漏斗中</li>
</ul>
<p>在漏斗中有水的时候，</p>
<ul>
<li>出水口以最大速率出水</li>
<li>如果漏斗未满，且有进水的话，那么这些水会积在漏斗中</li>
<li>如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外</li>
</ul>
<h3 id="令牌桶算法">令牌桶算法</h3>
<p>对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。</p>
<p>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶没有令牌，那么则拒绝该请求。</p>
<img data-src="/2020/07/22/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%EF%BC%9A%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%952.png" class>
<p>google guava实现了令牌桶限流算法：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9ndWF2YQ==">https://github.com/google/guava<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="令牌桶算法-vs-漏桶算法">令牌桶算法 vs 漏桶算法</h3>
<p><strong>漏桶：</strong></p>
<p>漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。</p>
<p><strong>令牌桶：</strong></p>
<p>生成令牌的速度时恒定的，而请求去哪令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。</p>
<h2 id="最后">最后</h2>
<p>不论是对于令牌桶拿不到令牌被拒绝，还是漏桶的水满了溢出，都是为了保证大部分流量的正常使用，而牺牲掉了少部分流量，这是合理的，如果因为极少部分流量需要保证的话，那么就可能导致系统达到极限而挂掉，得不偿失。</p>
<p>本文讲的单机的限流，是JVM级别的限流，所有的令牌生成都是在内存中，在分布式环境下不能直接这么用，可以使用，可以使用redis限流</p>
<h2 id="出处">出处</h2>
<p>https://www.ymq.io/2018/08/11/RateLimiter/</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统的设计原理</title>
    <url>/2020/08/16/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>文件及硬盘管理是计算机操作系统的重要组成部分，让微软走上成功之路的正是微软最早推出的个人电脑 PC 操作系统，这个操作系统就叫 DOS，即 Disk Operating System，硬盘操作系统。我们每天使用电脑都离不开硬盘，硬盘既有大小的限制，通常大一点的硬盘也不过几 T，又有速度限制，快一点的硬盘也不过每秒几百 M。</p>
<p>文件是存储在硬盘上的，文件的读写访问速度必然受到硬盘的物理限制，那么如何才能 1 分钟完成一个 100T 大文件的遍历呢？</p>
<p>想要知道这个问题的答案，我们就必须知道文件系统的原理。做软件开发时，必然要经常和文件系统打交道，而文件系统也是一个软件，了解文件系统的设计原理，可以帮助我们更好地使用文件系统，另外设计文件系统时的各种考量，也对我们自己做软件设计有诸多借鉴意义。</p>
<p>让我们先从硬盘的物理结构说起。</p>
<h3 id="硬盘">硬盘</h3>
<p>硬盘是一种可持久保存、多次读写数据的存储介质。硬盘的形式主要两种，一种是机械式硬盘，一种是固态硬盘。</p>
<p>机械式硬盘的结构，主要包含盘片、主轴、次投币，主轴带动盘片高速旋转，当需要读写盘上的数据的时候，磁头臂会移动磁头到盘片所在的磁道上，磁头读取磁道上的数据。读写数据需要移动磁头，这样一个机械的动作，至少需要花费数毫秒的时间，这是机械式硬盘访问延迟的主要原因。</p>
<p>如果一个文件的数据在硬盘上不是连续存储的，比如数据库的B+树文件，那么要读取这个文件，磁头臂就必须来回移动，花费的时间必然很长。如果文件数据是连续存储的，比如日志文件，那么磁头臂就可以较少移动，相比离散存储的同样大小的文件，连续存储的文件的读写速度要快得多。</p>
<p>机械式硬盘的数据就存储在具有磁性特质的盘片上，因此这种硬盘也被称为磁盘，而固态硬盘则没有这种磁性特质的存储介质，也没有电机驱动的机械式结构。</p>
<p>其中主控芯片处理端口输入的指令和数据，然后控制闪存颗粒进行数据读写。由于固态硬盘没有了机械式硬盘的电机驱动磁头臂进行机械式物理移动的环节，而是完全的电子操作，因此固态硬盘的访问速度远快于机械式硬盘。</p>
<p>但是，到目前为止固态硬盘的成本还是明显高于机械式磁盘，因此在生产环境中，最主要的存储介质依然是机械式硬盘。如果一个场景对数据访问速度、存储容量、成本都有较高要求，那么可以采用固态硬盘和机械式硬盘混合部署的方式，即在一台服务器上既有富态硬盘，也有机械式硬盘，以满足不同文件类型的存储需求，比如日志文件存储在机械式硬盘上，而系统文件和随机读写的文件存储在固态硬盘上。</p>
<h3 id="文件系统">文件系统</h3>
<p>作为应用程序开发者，我们不需要直接操作硬盘，而是通过操作系统，以文件的方式对硬盘上的数据进行读写访问。文件系统将硬盘空间以块为单位进行划分，每个文件占据若干个块，然后在通过一个文件控制块FCB记录每个文件占据的硬盘数据块。</p>
<img data-src="/2020/08/16/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F1.png" class>
<p>这个文件控制块在Linux操作系统中就是inode，要想访问文件，就必须获得文件的inode信息，在inode中查找文件数据块索引表，根据索引中记录的硬盘地址信息访问硬盘，读写数据。</p>
<p>inode中记录着文件权限、所有者、修改时间和文件大小等文件属性信息，以及文件数据块硬盘地址索引。inode是固定结构的，能够记录的硬盘地址索引数也是固定的，只有15个索引。其中前12个索引直接记录数据块地址，第13个索引记录索引地址，也就是说，索引块指向的硬盘数据块并不直接记录文件数据，而是记录文件数据块的索引表，每个索引表可以记录256个索引；第14个索引记录二级索引地址，第15个索引记录三级索引地址，如下图：</p>
<img data-src="/2020/08/16/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F2.jpg" class>
<p>这样，每个inode最多可以存储12+256+256*256+256*256*256个数据块，如果每个数据块的大小为4k，也就是单个文件最大不超过70G，而且即使可以扩大数据块大小，文件大小也要受单个硬盘容量的限制。这样的话，对于我们开头提出的一分钟完成100T大文件的遍历，Linux文件系统是无法完成的。</p>
<p>那么，有没有更给力的解决方案呢？</p>
<h3 id="raid">RAID</h3>
<p>RAID，即独立硬盘冗余阵列，将多块硬盘通过硬件RAID卡或者软件RAID的方案管理起来，使其共同对外提供服务。RAID的核心思路其实是利用文件系统将数据写入硬盘中不同数据块的特性，将多块硬盘上的空闲空间看作一个整体，进行数据写入，也就是说，一个文件的多个数据块可能写入多个硬盘。</p>
<p>根据硬盘组织和使用方式不同，常用RAID有五种，分别是RAID 0、RAID 1、RAID 10、RAID 5和RAID 6。we</p>
<img data-src="/2020/08/16/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F3.jpg" class>
<p>RAID 0 将一个文件的数据分成 N 片，同时向 N 个硬盘写入，这样单个文件可以存储在 N 个硬盘上，文件容量可以扩大 N 倍，（理论上）读写速度也可以扩大 N 倍。但是使用 RAID 0 的最大问题是文件数据分散在 N 块硬盘上，任何一块硬盘损坏，就会导致数据不完整，整个文件系统全部损坏，文件的可用性极大地降低了。</p>
<p>RAID 1 则是利用两块硬盘进行数据备份，文件同时向两块硬盘写入，这样任何一块硬盘损坏都不会出现文件数据丢失的情况，文件的可用性得到提升。</p>
<p>RAID 10 结合 RAID 0 和 RAID 1，将多块硬盘进行两两分组，文件数据分成 N 片，每个分组写入一片，每个分组内的两块硬盘再进行数据备份。这样既扩大了文件的容量，又提高了文件的可用性。但是这种方式硬盘的利用率只有 50%，有一半的硬盘被用来做数据备份。</p>
<p>RAID 5 针对 RAID 10 硬盘浪费的情况，将数据分成 N-1 片，再利用这 N-1 片数据进行位运算，计算一片校验数据，然后将这 N 片数据写入 N 个硬盘。这样任何一块硬盘损坏，都可以利用校验片的数据和其他数据进行计算得到这片丢失的数据，而硬盘的利用率也提高到 N-1/N。</p>
<p>RAID 5 可以解决一块硬盘损坏后文件不可用的问题，那么如果两块文件损坏？RAID 6 的解决方案是，用两种位运算校验算法计算两片校验数据，这样两块硬盘损坏还是可以计算得到丢失的数据片。</p>
<p>实践中，使用最多的是 RAID 5，数据被分成 N-1 片并发写入 N-1 块硬盘，这样既可以得到较好的硬盘利用率，也能得到很好的读写速度，同时还能保证较好的数据可用性。使用 RAID 5 的文件系统比简单的文件系统文件容量和读写速度都提高了 N-1 倍，但是一台服务器上能插入的硬盘数量是有限的，通常是 8 块，也就是文件读写速度和存储容量提高了 7 倍，这远远达不到 1 分钟完成 100T 文件的遍历要求。</p>
<p>那么，有没有更给力的解决方案呢？</p>
<h3 id="分布式文件系统">分布式文件系统</h3>
<p>我们再回过头看下Linux的文件系统：文件的基本信息，也就是文件元信息记录在文件控制块inode中，文件的数据记录在硬盘的数据块中，inode通过索引记录数据块的地址，读写文件的时候，查询inode中的索引记录得到数据块的硬盘地址，然后访问数据。</p>
<p>如果将数据块的地址改成分布式服务器的地址？也就是查询得到的数据块地址不只是本机的硬盘容量，还可以是其他服务器的地址，那么文件的存储容量就将是整个分布式服务器集群的硬盘容量，这样还可以在不同的服务器上同时并行读取文件的数据块，文件访问速度也将极大的加快。</p>
<p>这样的文件系统就是分布式文件系统，分布式文件系统的思路其实和RAID是一脉相承的，就是将数据分成很多片，同时向N台服务器上进行数据写入。针对一片数据丢失就导致整个文件损坏的情况，分布式文件系统也是采取数据备份的方式，将多个备份数据片写入多个服务器，以保证文件的可用性。当然，也可以采用RAID 5的方式通过计算校验数据片的方式提高文件可用性。</p>
<p>我们以Hadoop分布式文件系统HDFS为例，看下分布式文件系统的具体架构设计。</p>
<img data-src="/2020/08/16/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F4.png" class>
<p>HDFS的关键组件有两个，一个是DataNode，一个是NameNode。</p>
<p>DataNode负责文件数据的存储和读写操作，HDFS将文件数据分隔成若干数据块（Block），每个DataNode存储一部分数据块，这样文件就分部存储在整个HDFS服务器集群中。应用程序客户端（Client）可以并行对这些数据块进行访问，从而使得HDFS可以在服务器集群规模上实现数据并行访问，极大地提高了访问速度。在实践中，HDFS集群的DataNode服务器会有很多台，一般在几百台到几千台这样的规模，每台服务器配有数块硬盘，整个集群的存储容量大概在几PB到数百PB。</p>
<p>NameNode负责整个分布式文件系统的元数据（MetaData）管理，也就是文件路径名、访问权限、数据块的ID以及存储位置等信息，相当于Linux系统中inode的角色。HDFS为了保证数据的高可用，会将一个数据块复制为多分（缺省情况下为3份），并将多份相同的数据块存储在不同的服务器上，甚至不同的机架上。这样当有硬盘损坏，或者某个DataNode服务器宕机，甚至某个交换机宕机，导致其存储的数据块不能访问的时候，客户端会查找其备份的数据块进行访问。</p>
<p>有了HDFS，可以实现单一文件存储几百T的数据，再配合大数据计算框架MapReduce或者Spark，可以对这个文件的数据块进行并发计算。也可以使用Impala这样的SQL引擎对这个文件进行结构化查询，在数千台服务器上并发遍历100T的数据，1分钟都是绰绰有余的。</p>
<h3 id="小结">小结</h3>
<p>文件系统从简单操作系统文件，到RAID没再到分布式文件系统，其设计思路其实是具有统一性的。这种统一性方面体现在文件数据如何管理，也就是如何通过文件控制块管理文件的数据，这个文件控制块在Linux系统中就是inode，在HDFS中就是NameNode。</p>
<p>另一方面体现在如何利用更多的硬盘实现越来越大的文件存储需求和越来越快的读写速度需求，也就是将数据分片后同时写入多块硬盘。单服务器我们可以通过RAID来实现，多服务器则可以将这些服务器组成一个文件系统集群，共同对外提供文件服务，这时候，数千台服务器的数万块硬盘以单一存储资源的方式对文件使用提供服务，也就是一个文件可以存储数百T的数据，并在一分钟完成这样一个大文件的遍历。</p>
<h3 id="思考题">思考题</h3>
<p>在RAID 5的示意图中，P表示校验和数据，我们看到P不是单独存储在一块硬盘上，而是分散在不同的盘上，实际上，校验数据P的存储位置是螺旋式的散落在所有硬盘上的，为什么要这样设计？</p>
<p>1.高可用，避免检验盘损坏了所有都用不了了。 2.读取速度快，实现了检验数据的并行访问，大大加快了检验速度。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>文凭只是敲门砖--于谦</title>
    <url>/2020/07/15/%E6%96%87%E5%87%AD%E5%8F%AA%E6%98%AF%E6%95%B2%E9%97%A8%E7%A0%96-%E4%BA%8E%E8%B0%A6/</url>
    <content><![CDATA[<p>现在这个社会，不光现在这个社会，实际上从有史以来，这个人，为了养家糊口，要学一门手艺。你包括你读书，你读到硕士，读到博士，你无非就是，学什么，都是为了找一份好工作。对吧，到最后。手艺人，是最吃香的。文凭，是个敲门砖，之后的一切素质，包括你工作上，用的一些东西，都是之后，进入社会，以后的再教育。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行商问题（使用MST的近似算法）</title>
    <url>/2020/08/21/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88%E4%BD%BF%E7%94%A8MST%E7%9A%84%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<p>上一篇中介绍了旅行商问题，并讨论了该问题的朴素和DP解决方案。这两种解决方案都是不可行的。事实上，这个问题没有多项式时间的解决方案，因为这个问题是一个已知的NP-Hard问题。不过有近似算法可以解决这个问题。近似算法只有在问题满足三角形不等式的情况下才有效。</p>
<p><strong>三角形不等式</strong>：从顶点i到顶点j的最短路径总是直接从i到达j，而不是通过其他顶点k，即dist(i, j)总是小于等于dist(i, k) + dist(k, j)。三角形不等式在很多情况下都是成立的。当成本函数满足三角形不等式时，我们可以为TSP设计一个近似算法，该算法返回的旅游成本永远不会超过最优旅游成本的两倍。其思想是使用最小生成树（Minimum Spanning Tree, MST)。以下是基于MST的算法。</p>
<h2 id="算法">算法</h2>
<ol type="1">
<li>让1成为销售员的起点和终点。</li>
<li>用Prim's Algorithm以1为根构建MST。</li>
<li>列出构造的MST的前序遍历中所访问的顶点，并在最后添加1.</li>
</ol>
<p>让我们考虑下面的例子。第一张图是给定的图，第二张图是以1为根构建的MST。MST的前序遍历是1-2-4-3。在末尾加1，得到1-2-4-3-1，这就是这个算法的输出。</p>
<img data-src="/2020/08/21/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88%E4%BD%BF%E7%94%A8MST%E7%9A%84%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95%EF%BC%89/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98MST1.png" class>
<img data-src="/2020/08/21/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88%E4%BD%BF%E7%94%A8MST%E7%9A%84%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95%EF%BC%89/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98MST2.png" class>
<p>这种情况下，近似算法会产生最优线路，但未必在所有情况下都能产生最优路径。</p>
<p><strong>这个算法是如何2倍近似的？</strong>上述算法产生的输出成本永远不会超过最佳可能输出成本的两倍。我们来看看上述算法是如何保证这一点的。</p>
<p>让我们定义一个术语"full walk"来理解这个问题。一个full walk是当一个顶点被前序遍历访问访问时列出它们，并且当某个顶点的子树被返回时也列出这些顶点。上面树的full walk将是1-2-1-4-1-3-1。下面是证明2-近似性的一些重要事实。</p>
<ol type="1">
<li>最好的旅行商路线的成本绝不小于MST的成本。（MST的定义说，它是连接所有顶点的最小成本树。）</li>
<li>full walk的总成本最多是MST成本的两倍（MST的每条边最多被访问两次）。</li>
<li>上述算法的输出小于full walk的成本。在上面的算法中，我们打印出preorder walk作为输出。在前序遍历中，full walk的两条或多条边被一条边所取代。例如，2-1和1-4被一条边2-4所取代。所以，如果图形遵循三角形不等式，那么这条结论总是对的。</li>
</ol>
<p>从以上三句陈述中，我们可以得出结论，近似算法产生的输出成本永远不会超过最佳可能解成本的两倍。</p>
<p>我们讨论了一个非常简单的旅行商问题的2-近似算法。对于这个问题还有其他更好的近似算法。例如Christofides算法是1.5近似算法。我们将很快把这些算法作为单独的文章来讨论。</p>
<h2 id="参考">参考</h2>
<p>https://www.geeksforgeeks.org/travelling-salesman-problem-set-2-approximate-using-mst/?ref=lbp</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行商问题（朴素和dp方法）</title>
    <url>/2020/08/20/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%B4%E7%B4%A0%E5%92%8Cdp%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<p>Travelling Salesman Problem(TSP)旅行商问题：给定一个集合的城市和每一对城市之间的距离，问题是找到最短可能的路径，访问每个城市恰好一次，并且返回出发的城市。</p>
<p>注意汉密尔顿循环问题和TSP问题的区别。汉密尔顿循环问题是要找到是否存在一条完全访问每个城市一次的旅游路线。这里我们知道汉密尔顿循环路线存在（因为图是完整的），事实上很多这样的环存在，问题是找到一个最小权重的汉密尔顿循环。</p>
<img data-src="/2020/08/20/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%B4%E7%B4%A0%E5%92%8Cdp%E6%96%B9%E6%B3%95%EF%BC%89/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%981.png" class>
<p>比如，考虑右图所示的图形。图中一个TSP循环是1-2-4-3-1。旅行的费用是10+25+30+15即80。</p>
<p>这个问题是一个著名的NP问题。这个问题没有多项式时间的已知解。</p>
<p>以下是旅行商问题的不同解法。</p>
<p><strong>朴素的解法：</strong></p>
<ol type="1">
<li>将城市1作为起点和终点</li>
<li>生成所有（n-1）！城市的排列组合</li>
<li>计算每个排列组合的成本，并跟踪成本最小的排列组合</li>
<li>返回成本最小的排列组合</li>
</ol>
<p>时间复杂度：O(n!)</p>
<p><strong>DP 动态递推</strong></p>
<p>让给定的顶点集为{1, 2, 3, 4, ..., n}。让我们把1作为输出的起点和终点。对于每一个其他的顶点i（1除外），我们找到以1为起点，i为终点，且所有顶点只出现一次的最小成本路径。让这条路径的成本为cost(i)。对应CUcle的成本将是cost(i) + dist(i, 1)，其中dist(i, 1)是i到1的距离。最后我们返回所有[cost(i) + dist(i, 1)]值的最小值。到目前为止，这看起来很简单。现在的问题是如何得到cost(i)？</p>
<p>为了使用DP计算cost(i)，我们需要在子问题方面有一些地推关系。让我们定义一个术语C(S, i)为从1开始，到i结束，精确访问集S中每个顶点一次的最小成本路径的成本。我们从大小为2的所有子集开始，计算S为子集的所有子集的C(S, i)，然后我们计算大小为3的所有子集S的C(S, i)，以此类推。注意，每个子集中必须有1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If size of S is 2, then S must be &#123;1, i&#125;,</span><br><span class="line"> C(S, i) &#x3D; dist(1, i) </span><br><span class="line">Else if size of S is greater than 2.</span><br><span class="line"> C(S, i) &#x3D; min &#123; C(S-&#123;i&#125;, j) + dist(j, i)&#125; where j belongs to S, j !&#x3D; i and j !&#x3D; 1.</span><br></pre></td></tr></table></figure>
<p>对于一个大小为n的集合，我们考虑每个大小为n-1的n-2个子集，使所有子集中没有t（代表集合的排序）。</p>
<p>利用上述递归关系，我们可以写出基于DP的解决方案。最多有O(n*2^n)个子问题，每个子问题的求解都需要线性时间。因此，总的运行时间是O(n^2*2^n)。时间复杂度远小于O(n!)，但仍是指数级的。所需空间也是指数级的。所以这种方法即使对于稍高的顶点数量也是不可行的。</p>
<p>我们很快就会讨论旅行推销员问题的近似算法。</p>
<p><strong>参考：</strong></p>
<p>https://www.geeksforgeeks.org/travelling-salesman-problem-set-1/</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组Binary Indexed Tree</title>
    <url>/2020/07/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Binary-Indexed-Tree/</url>
    <content><![CDATA[<h2 id="参考">参考</h2>
<p>https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/</p>
<h2 id="实际问题简单记想快速知道数组的前缀和同时数组的修改频繁用树状数组使得这两种操作都变成ologn两边查询的树状数组可以相当于线段树的功能">实际问题（简单记，想快速知道数组的前缀和，同时数组的修改频繁，用树状数组，使得这两种操作都变成O(logn)，两边查询的树状数组可以相当于线段树的功能）</h2>
<p>We have an array arr[0 . . . n-1]. We would like to <strong>1</strong> Compute the sum of the first i elements. <strong>2</strong> Modify the value of a specified element of the array arr[i] = x where 0 &lt;= i &lt;= n-1.</p>
<p>A <strong>simple solution</strong> is to run a loop from 0 to i-1 and calculate the sum of the elements. To update a value, simply do arr[i] = x. The first operation takes O(n) time and the second operation takes O(1) time.</p>
<p>Another simple solution is to create an extra array and store the sum of the first i-th elements at the i-th index in this new array. The sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now. This works well if there are a large number of query operations but a very few number of update operations.</p>
<p><strong>Could we perform both the query and update operations in O(log n) time?</strong> One efficient solution is to use <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvc2VnbWVudC10cmVlLXNldC0xLXN1bS1vZi1naXZlbi1yYW5nZS8=">Segment Tree<i class="fa fa-external-link-alt"></i></span> that performs both operations in O(Logn) time.</p>
<p><em>An alternative solution is Binary Indexed Tree, which also achieves O(Logn) time complexity for both operations. Compared with Segment Tree, Binary Indexed Tree requires less space and is easier to implement.</em>.</p>
<p>给定一个数组[0, .., n-1]，我们想：</p>
<ol type="1">
<li>计算出前i个元素的和</li>
<li>将任何一个元素改为x，arr[i] = x where 0&lt;=i&lt;=n-1</li>
</ol>
<p>和线段树的实际问题的区别在于，线段树是从l到r任何一段，树状数组只是前i个。</p>
<p>同样第一个简单的解法就是循环求和O(n)，改变为O(1)。</p>
<p>或者创建一个新数组的每个元素存的前i个数的和，这样求和就是O(1)，但是改变后数组就要调整O(n)的时间复杂度。</p>
<p><strong>Representation</strong> Binary Indexed Tree is represented as an array. Let the array be BITree[]. Each node of the Binary Indexed Tree stores the sum of some elements of the input array. The size of the Binary Indexed Tree is equal to the size of the input array, denoted as n. In the code below, we use a size of n+1 for ease of implementation.</p>
<p><strong>Construction</strong> We initialize all the values in BITree[] as 0. Then we call update() for all the indexes, the update() operation is discussed below.</p>
<p><strong>Operations</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getSum(x): Returns the sum of the sub-array arr[0,...,x]</span><br><span class="line">&#x2F;&#x2F; Returns the sum of the sub-array arr[0,...,x] using BITree[0..n], which is constructed from arr[0..n-1]</span><br><span class="line">1) Initialize the output sum as 0, the current index as x+1.</span><br><span class="line">2) Do following while the current index is greater than 0.</span><br><span class="line">...a) Add BITree[index] to sum</span><br><span class="line">...b) Go to the parent of BITree[index].  The parent can be obtained by removing</span><br><span class="line">     the last set bit from the current index, i.e., index &#x3D; index - (index &amp; (-index))【index&amp;(index-1) 也可以】</span><br><span class="line">3) Return sum.</span><br></pre></td></tr></table></figure>
<img data-src="/2020/07/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Binary-Indexed-Tree/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%841.png" class>
<p>The diagram above provides an example of how getSum() is working. Here are some important observations.</p>
<p>BITree[0] is a dummy node.</p>
<p>BITree[y] is the parent of BITree[x], if and only if y can be obtained by removing the last set bit from the binary representation of x, that is y = x – (x &amp; (-x)).【index&amp;(index-1) 也可以】</p>
<p>The child node BITree[x] of the node BITree[y] stores the sum of the elements between y(inclusive) and x(exclusive): arr[y,…,x).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update(x, val): Updates the Binary Indexed Tree (BIT) by performing arr[index] +&#x3D; val</span><br><span class="line">&#x2F;&#x2F; Note that the update(x, val) operation will not change arr[].  It only makes changes to BITree[]</span><br><span class="line">1) Initialize the current index as x+1.</span><br><span class="line">2) Do the following while the current index is smaller than or equal to n.</span><br><span class="line">...a) Add the val to BITree[index]</span><br><span class="line">...b) Go to parent of BITree[index].  The parent can be obtained by incrementing</span><br><span class="line">     the last set bit of the current index, i.e., index &#x3D; index + (index &amp; (-index))</span><br></pre></td></tr></table></figure>
<img data-src="/2020/07/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Binary-Indexed-Tree/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%842.png" class>
<p>The update function needs to make sure that all the BITree nodes which contain arr[i] within their ranges being updated. We loop over such nodes in the BITree by repeatedly adding the decimal number corresponding to the last set bit of the current index.</p>
<p><strong>How does Binary Indexed Tree work?</strong> The idea is based on the fact that all positive integers can be represented as the sum of powers of 2. For example 19 can be represented as 16 + 2 + 1. Every node of the BITree stores the sum of n elements where n is a power of 2. For example, in the first diagram above (the diagram for getSum()), the sum of the first 12 elements can be obtained by the sum of the last 4 elements (from 9 to 12) plus the sum of 8 elements (from 1 to 8). The number of set bits in the binary representation of a number n is O(Logn). Therefore, we traverse at-most O(Logn) nodes in both getSum() and update() operations. The time complexity of the construction is O(nLogn) as it calls update() for all n elements.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 树状数组binary-indexed-tree.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BITree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        self.n = len(nums)</span><br><span class="line">        self.tree = [<span class="number">0</span>] * (self.n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            self.update(i + <span class="number">1</span>, num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, i, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            i: 指的是更新数组中的第几个数，对应索引是i-1</span></span><br><span class="line"><span class="string">            k: 更新的数值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= self.n:</span><br><span class="line">            self.tree[i] += k</span><br><span class="line">            i += (i &amp; -i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span>(<span class="params">self, i</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            i: 返回前几个数的前缀和</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns: 前i个数的前缀和</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i:</span><br><span class="line">            s += self.tree[i]</span><br><span class="line">            i -= (i &amp; -i)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    tree = BITree(nums)</span><br><span class="line">    <span class="comment"># 打印前1,2,3,4个数的前缀和</span></span><br><span class="line">    print(tree.getSum(<span class="number">1</span>))</span><br><span class="line">    print(tree.getSum(<span class="number">2</span>))</span><br><span class="line">    print(tree.getSum(<span class="number">3</span>))</span><br><span class="line">    print(tree.getSum(<span class="number">4</span>))</span><br><span class="line">    <span class="comment"># 更新第2个数的值，增加3</span></span><br><span class="line">    tree.update(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 再次打印前1,2,3,4个数的前缀和</span></span><br><span class="line">    print(tree.getSum(<span class="number">1</span>))</span><br><span class="line">    print(tree.getSum(<span class="number">2</span>))</span><br><span class="line">    print(tree.getSum(<span class="number">3</span>))</span><br><span class="line">    print(tree.getSum(<span class="number">4</span>))</span><br><span class="line">    <span class="comment"># 更新第2个数的值，减少3</span></span><br><span class="line">    tree.update(<span class="number">2</span>, <span class="number">-3</span>)</span><br><span class="line">    print(tree.getSum(<span class="number">1</span>))</span><br><span class="line">    print(tree.getSum(<span class="number">2</span>))</span><br><span class="line">    print(tree.getSum(<span class="number">3</span>))</span><br><span class="line">    print(tree.getSum(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sum of elements in arr[0..5] is 12</span><br><span class="line">Sum of elements in arr[0..5] after update is 18</span><br></pre></td></tr></table></figure>
<p><strong>Can we extend the Binary Indexed Tree to computing the sum of a range in O(Logn) time?</strong> Yes. rangeSum(l, r) = getSum(r) – getSum(l-1).</p>
<p><strong>Applications:</strong> The implementation of the arithmetic coding algorithm.</p>
<h2 id="典型题目">典型题目</h2>
<p>leetcode 315 计算右侧小于当前元素的个数</p>
<p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p>示例：</p>
<p>输入：[5,2,6,1] 输出：[2,1,1,0] 解释： 5 的右侧有 2 个更小的元素 (2 和 1) 2 的右侧仅有 1 个更小的元素 (1) 6 的右侧有 1 个更小的元素 (1) 1 的右侧有 0 个更小的元素</p>
<p>链接：https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self</p>
<p>树状数组解法，用每个数的rank来离散化，反序插入树状数组中，前一位的前缀和就是右侧小于当前元素的个数。</p>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        rank = &#123;val: i + <span class="number">1</span> <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(sorted(nums))&#125;</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        BITree = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">i, k=<span class="number">1</span></span>):</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">                BITree[i] += k</span><br><span class="line">                i += i &amp; -i</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getSum</span>(<span class="params">i</span>):</span></span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i:</span><br><span class="line">                s += BITree[i]</span><br><span class="line">                i -= i &amp; -i</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> reversed(nums):</span><br><span class="line">            res.append(getSum(rank[num] - <span class="number">1</span>))</span><br><span class="line">            update(rank[num])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解MySQL索引底层实现原理丨技术干货</title>
    <url>/2020/07/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%A8%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7/</url>
    <content><![CDATA[<h3 id="转载">转载：</h3>
<p>https://zhuanlan.zhihu.com/p/77383599</p>
<h2 id="一索引的本质">一、索引的本质</h2>
<p><strong>MySQL官方对索引的定义为</strong>：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>看一个例子：</p>
<img data-src="/2020/07/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%A8%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%861.jpg" class>
<p>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p>
<h2 id="二二叉排序树">二、二叉排序树</h2>
<p>在介绍B树之前，先来看另一颗神奇的树——二叉排序树（Binary Sort Tree）。关于这棵树大家已经很熟悉了，我不多说了，看原文吧。</p>
<ul>
<li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值</li>
<li>若右子树不空，则右字数上所有节点的值均大于它的根节点的值</li>
<li>它的左、右子树也分别为二叉排序数（递归定义）</li>
</ul>
<img data-src="/2020/07/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%A8%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%862.jpg" class>
<p>从图中可以看出，二叉排序树组织数据时，用于查找是比较方便的，因为每次经过一次节点时，最多可以减少一半的可能，不过极端情况会出现所有节点都位于同一侧，直观上看就是一条直线，那么这种查询的效率就比较低了，因此需要对二叉树左右子树的高度进行平衡化处理，于是就有了平衡二叉树（Balenced Binary Tree）。</p>
<p>所谓“平衡”，说的是这棵树的各个分支的高度是均匀的，它的左子树和右子树的高度之差绝对值小于1，这样就不会出现一条支路特别长的情况。于是，在这样的平衡树中进行查找时，总共比较节点的次数不超过树的高度，这就确保了查询的效率（时间复杂度为O(logn)）</p>
<h2 id="三b树">三、B树</h2>
<p>还是直接看图比较清楚，图中所示，B树事实上是一种平衡的多叉查找树，也就是说最多可以开m个叉（m&gt;=2)，我们称之为m阶B树，为了体现本博客的良心之处，不同于其他地方都能看到2阶B树，这里特意画了一棵5阶B树 。博主棒。</p>
<img data-src="/2020/07/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%A8%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%863.jpg" class>
<p>总的来说，m阶B树满足以下条件：</p>
<ul>
<li>每个节点至多可以拥有m棵子树</li>
<li>根节点，至少有2个节点（要么极端情况，就是一棵树就一个根节点，单细胞生物，既是根，也是叶，也是树）。</li>
<li>非根非叶的节点至少有Ceil(m/2)个子树（Ceil表示向上取整，图中5阶B树，每个节点至少有3个子树，也就是至少有3个叉）。</li>
<li>非叶子节点中的信息包括[n, A0, K1, A1, K2, A2, ..., Kn, An]，其中n表示该节点中保存的关键字个数，K为关键字且Ki&lt;Ki+1，A为指向子树根节点的指针。</li>
<li>从根到叶子的每一条路径都有相同的长度，也就是说，叶子节点在相同的层，并且这些节点不带信息，实际上这些节点就表示找不到指定的值，也就是指向这些节点的指针为空。</li>
<li>B树的查询过程和二查排序树比较类似，从根节点依次比较每个节点，因为每个节点中的关键字和左右子树都是有序的，所以只要比较节点中的关键字，或者沿着指针就能很快的找到指定的关键字，如果查找失败，则会返回叶子节点，即空指针。</li>
</ul>
<p><strong>例如查询图中字母表中的K</strong>：</p>
<ul>
<li>从根节点P开始，K的位置在P之前，进入左侧指针</li>
<li>左子树中，依次比较C、F、J、M，发现K在J和M之间。</li>
<li>沿着J和M之间的指针，继续访问子树，并依次进行比较，发现第一个关键字K即为指定查找的值。</li>
</ul>
<p>B树搜索的简单伪代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">BTree_Search(node, key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span>(node.key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.key[i] == key) <span class="keyword">return</span> node.data[i];</span><br><span class="line">        <span class="keyword">if</span>(node.key[i] &gt; key) <span class="keyword">return</span> BTree_Search(point[i]-&gt;node, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BTree_Search(point[i+<span class="number">1</span>]-&gt;node, key);</span><br><span class="line">&#125;</span><br><span class="line">data = BTree_Search(root, my_key);</span><br></pre></td></tr></table></figure>
<p><strong>B树的特点可以总结为如下：</strong></p>
<ul>
<li>关键字集合分布在整颗树中</li>
<li>任何一个关键字出现且只出现在一个节点中</li>
<li>搜索有可能在非叶子节点结束</li>
<li>其搜索性能等价于在关键字集合内做一次二分查找</li>
<li>B树的插入删除新的数据记录会破坏B-Tree的性质，因为在插入删除时，需要对树进行分裂、合并、转移等操作以保持B-Tree的性质。</li>
</ul>
<h2 id="四plus版-b树">四、Plus版-B+树</h2>
<p>作为B树的加强版，B+树与B树的差异在于</p>
<p>有n棵子树的节点含有n个关键字（也有人认为是n-1个关键字）。</p>
<p>所有的关键字全部存储在叶子节点上，且叶子节点本身根据关键字自小而大顺序连接。</p>
<p>非叶子节点可以看成索引部分，节点中仅包含有其子树（根节点）中的最大（最小）关键字。</p>
<img data-src="/2020/07/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%A8%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%864.jpg" class>
<p>B+树的查找过程，与B树类似，只不过查找时，如果在非叶子节点上的关键字等于给定值，并不终止，而是继续沿着指针直到叶子节点位置。因此在B+树中，不管查找成功与否，每次查找都是走了一条从根到叶子节点的路径。</p>
<p><strong>B+树的特性如下：</strong></p>
<ul>
<li>所有关键字都存储在叶子节点上，且链表中的关键字恰好是有序的</li>
<li>不可能非叶子节点命中返回</li>
<li>非叶子节点相当于叶子节点的索引，叶子节点相当于是存储（关键字）数据的数据层。</li>
<li>更适合文件索引系统</li>
</ul>
<h2 id="五带有顺序访问指针的btree">五、带有顺序访问指针的B+Tree</h2>
<p>一般在数据库系统或文件系统中使用的B+Tree结构都在进店B+Tree的基础上进行了优化，增加了顺序访问指针，</p>
<img data-src="/2020/07/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%A8%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7/MySQL%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%865.jpg" class>
<p>如上图所示，在B+Tree的每个叶子节点增加一个指向相邻子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提高了取件查找效率。</p>
<h2 id="六mysql为什么使用b树b树">六、MySQL为什么使用B树（B+树）</h2>
<p>红黑树等数据结构也可以用来实现索引，但是文件系统以及数据库系统普遍采用B树或者B+树，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
<p>太长了，后面我总结一下</p>
<ol type="1">
<li>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</li>
<li>B-Tree巧妙地利用磁盘预读原理，将一个节点的大小设为等于一个页。每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>猫抓老鼠的简单讨论</title>
    <url>/2020/07/27/%E7%8C%AB%E6%8A%93%E8%80%81%E9%BC%A0%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A8%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="两个问题以及其解答">两个问题以及其解答</h2>
<ol type="1">
<li><p><strong>问题一：有一个圆形的操场，四周都是墙壁，无法逾越。操场里面有一只老鼠和一只猫，猫在努力的捉老鼠。如果老鼠和猫的奔跑速度一样，那么猫一定能够追到老鼠吗？</strong></p>
<p><strong>正确的结论正是猫永远也追不上老鼠</strong>。</p>
<p>我们可以通过数学证明证明出，只要老鼠时刻沿着猫的位置到圆心的位置的连线的垂直方向跑，可以证明出永远也不会追上。数学证明见<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84MDcwMTA2OA==">https://zhuanlan.zhihu.com/p/80701068<i class="fa fa-external-link-alt"></i></span>。</p></li>
<li><p><strong>在一个圆形池塘中有一只老鼠，池塘岸边有一只不会游泳的猫。这只老鼠游泳的速度比猫在岸上奔跑的速度要小，但其在岸上奔跑的速度却大于猫的速度。所以，只要老鼠能够在猫还没跑过来的时候游到岸边，那么老鼠就得救了。问，猫的奔跑速度要至少是老鼠游泳速度的多少倍，才能确保抓得住老鼠？</strong></p>
<p>这道问题的一个简单问法是，假如猫在岸上的速度时老鼠游泳的4倍，那么猫能抓到老鼠吗？</p>
<p>答案是不能。</p>
<p>我们可以这么想，老鼠只要在小于1/4r处做绕圆心的圆运动，猫就跟不上老鼠，最终老鼠和猫和圆心会在一条直线上，圆心在老鼠和猫的中间。</p>
<p>这时候只要老鼠沿着这条直线向远离猫的圆周跑去，假设老鼠的位置距离圆心为x，那么只要</p>
<p><span class="math display">\[
\frac{r-x}{v_{老鼠}} &lt; \frac{\pi r}{v_{猫}}
\]</span></p>
<p>老鼠就会比猫先到岸边，这时猫就再也抓不到老鼠了。</p>
<p>根据猫的速度是老鼠的4倍，</p>
<p><span class="math display">\[
x = \frac{4-\pi}{4}r \approx0.2146r
\]</span></p>
<p>所以，只要老鼠在0.2146r到0.25r之间，走到和猫与圆心呈一条直线的位置，猫和老鼠分别在圆心两侧，老鼠往远离猫的方向走，就可以走出。</p>
<p>原问题问猫的最小速度是多少，才能保证抓住老鼠，依然可以看这篇文章的数学推导<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84MDcwMTA2OA==">https://zhuanlan.zhihu.com/p/80701068<i class="fa fa-external-link-alt"></i></span>。</p></li>
</ol>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>社会文明程度很大程度上体现为对弱者的尊重</title>
    <url>/2020/08/22/%E7%A4%BE%E4%BC%9A%E6%96%87%E6%98%8E%E7%A8%8B%E5%BA%A6%E5%BE%88%E5%A4%A7%E7%A8%8B%E5%BA%A6%E4%B8%8A%E4%BD%93%E7%8E%B0%E4%B8%BA%E5%AF%B9%E5%BC%B1%E8%80%85%E7%9A%84%E5%B0%8A%E9%87%8D/</url>
    <content><![CDATA[<p>在现代社会，公众对艾滋病人的接纳，其实也是一个非常奢侈的话题。虽然每一年，我们都有一个专门的日子，我们来表达对艾滋病人的关心。但是，仅仅有这个日子是不够的。</p>
<p>人们对于疾病总是有一种本能的恐惧。不要说艾滋病了，甚至乙肝病毒携带者，甚至白血病，等等都在社会中备受歧视。新闻就曾经报道过，有些白血病的孩子入学，被拒绝。所以在这样一种背景下，各位可以想象，艾滋病患呢，也很难走出歧视，并因为这个歧视，可能他们滋生对社会的仇恨和苦毒。</p>
<p>社会文明程度很大程度上它体现为对弱者的尊重。即便你跌入谷底，社会也应该为你提供基本的保障。当然话虽如此，同理心，始终是人们最匮乏的一种品质。</p>
<p>对于每个个体，如果我们无法真正的接纳弱者，这不也是我们道德上的免疫缺陷吗？</p>
<iframe src="//player.bilibili.com/player.html?aid=754134170&amp;bvid=BV1dk4y1m7oJ&amp;cid=224031902&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
]]></content>
      <tags>
        <tag>社会</tag>
      </tags>
  </entry>
  <entry>
    <title>科比--曼巴精神永不逝去</title>
    <url>/2020/01/30/%E7%A7%91%E6%AF%94-%E6%9B%BC%E5%B7%B4%E7%B2%BE%E7%A5%9E%E6%B0%B8%E4%B8%8D%E9%80%9D%E5%8E%BB/</url>
    <content><![CDATA[纪念老科 Tomorrow is not grante. Inspire yourself.
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=668058137&amp;bvid=BV1ua4y1i7ZK&amp;cid=186683490&amp;page=1" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">
</iframe>
</div>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>经典同步问题</title>
    <url>/2020/08/20/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="哲学家进餐问题">1.哲学家进餐问题</h2>
<img data-src="/2020/08/20/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98.jpg" class>
<p>五个哲学家围着一张圆桌，每个哲学家免签放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃法时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等到其他哲学家吃完并释放自己手中的筷子，导致死锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(i)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读者-写者问题">2.读者-写者问题</h2>
<p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量count记录在对数据进行读操作的进程数量，一个互斥量count_mutex用于对count加锁，一个互斥量data_mutex用于对读写的数据加锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题泛型</title>
    <url>/2020/08/04/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>自增id用完怎么办？</title>
    <url>/2020/08/29/%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
    <content><![CDATA[<p>MySQL里有很多自增的id，每个自增id都是定义了初始值，然后不停地往上加步长。虽然自然数是没有上限的，但是在计算机里，只要定义了表示这个数的字节长度，那它就有上限。比如，无符号整型（unsigned int）是4个字节，上限就是2^32-1。</p>
<p>既然自增id有上限，我们就来看看MySQL里面的几种自增id，一起分析一下它们的值达到上限之后，会出现什么情况。</p>
<h3 id="表定义自增值id">表定义自增值id</h3>
<p>说到自增id，你第一个想到的应该就是表结构定义里的自增字段，也就是我在第39篇文章<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS84MDUzMQ==">《自增主键为什么不是连续的？》<i class="fa fa-external-link-alt"></i></span>和你介绍过的自增主键id。</p>
<p>表定义的自增值达到上限后的逻辑是：再申请下一个id时，得到的值保持不变。</p>
<p>我们可以通过下面这个语句序列验证一下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> auto_increment primary <span class="keyword">key</span>) auto_increment=<span class="number">4294967295</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>);</span><br><span class="line">//成功插入一行 4294967295</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t;</span><br><span class="line"><span class="comment">/* CREATE TABLE `t` (</span></span><br><span class="line"><span class="comment">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="comment">  PRIMARY KEY (`id`)</span></span><br><span class="line"><span class="comment">) ENGINE=InnoDB AUTO_INCREMENT=4294967295;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>);</span><br><span class="line">//Duplicate entry &#x27;4294967295&#x27; for key &#x27;PRIMARY&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到，第一个insert语句插入数据成功后，这个表的AUTO_INCREMENT没有改变（还是4294967295），就导致了第二个insert语句又拿到相同的自增id值，再试图执行插入语句，报主键冲突错误。</p>
<p>2^32-1（4294967295）不是一个特别大的数，对于一个频繁插入删除数据的表来说，是可能会被用完的。因此在建表的时候你需要考察你的表是否有可能达到这个上限，如果有可能，就应该创建成8个字节的bigint unsigned。</p>
<h3 id="innodb系统自增row_id">InnoDB系统自增row_id</h3>
<p>如果你创建的InnoDB表没有指定主键，那么InnoDB会给你创建一个不可见的，长度为6个字节的row_id。InnoDB维护了一个全局的dict_sys.row_id值，所有无主键的InnoDB表，每插入一行数据，都将当前的dict_sys.row_id值作为要插入数据的row_id，然后把dict_sys.row_id的值加1。</p>
<p>实际上，在代码实现时row_id是一个长度为8字节的无符号长整型（bigint unsigned）。但是，InnoDB在设计时，给row_id留的只是6个字节的长度，这样写到数据表中时只放了最后6个字节，所以row_id能写到数据表中的值，就有两个特征：</p>
<ol type="1">
<li>row_id写入表中额值范围，是从0到2^48-1；</li>
<li>当dict_sys.row_id=2^48时，如果再有插入数据的行为要来申请row_id，拿到以后再取最后6个字节的话就是0。</li>
</ol>
<p>也就是说，写入表的row_id是从0开始到2^48-1。达到上限后，下一个值就是0，然后继续循环。</p>
<p>当然，2^48-1这个值本身已经很大了，但是如果一个MySQL实例跑得足够久的话，还是可能达到这个上限的。在InnoDB逻辑里，申请到row_id=N后，就将这行数据写入表中；如果表中已经存在row_id=N的行，新写入的行就会覆盖原有的行。</p>
<p>要验证这个结论的话，你可以通过gdb修改系统的自增row_id来实现。注意，用gdb改变量这个操作是为了便于我们复现问题，只能在测试环境使用。</p>
<img data-src="/2020/08/29/%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E4%BA%86%E5%9B%BE1.png" class>
<img data-src="/2020/08/29/%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E4%BA%86%E5%9B%BE2.png" class>
<p>可以看到，在我用gdb将dict_sys.row_id设置为2^48之后，再插入的a=2的行会出现在表t的第一行，因为这个值的row_id=0。之后再插入的a=3的行，由于row_id=1，就覆盖了之前a=1的行，因为a=1这一行的row_id也是1。</p>
<p>从这个角度看，我们还是应该在InnoDB表中主动创建自增主键。因为，表自增id到达上限后，再插入数据时报主键冲突错误，是更能被接受的。</p>
<p>毕竟覆盖数据，就意味着数据丢失，影响的是数据可靠性；报主键冲突，是插入失败，影响的是可用性。而一般情况下，可靠性优先于可用性。</p>
<h3 id="xid">Xid</h3>
<p>在第15篇文章<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83MzE2MQ==">《答疑文章（一）：日志和索引相关问题》<i class="fa fa-external-link-alt"></i></span>中，我和你介绍redo log和binlog相配合的时候，提到了它们有一个共同的字段叫做Xid。它在MySQL中是用来对应事务的。</p>
<p>那么，Xid在MySQL内部是怎么生成的呢？</p>
<p>MySQL内部维护了一个全局变量global_query_id，每次执行语句的时候将它赋值给Query_id，然后给这个变量加1。如果当前语句是这个事务执行的第一条语句，那么MySQL还会同时把Query_id赋值给这个事务的Xid。</p>
<p>而global_query_id是一个纯内存变量，重启之后就清零了。所以你就知道了，在同一个数据库实例中，不同事务的Xid也是有可能相同的。</p>
<p>但是MySQL重启之后会重新生成新的binlog文件，这就保证了，同一个binlog文件里，Xid一定是唯一的。</p>
<p>虽然MySQL重启不会导致同一份binlog里面出现两个相同的Xid，但是如果global_query_id达到上限后，就会继续从0开始计数。从理论上讲，还是会出现同一个binlog里面出现相同Xid的场景。</p>
<p>因为global_query_id定义的长度是8个字节，这个自增值的上限是2^64-1。要出现这种情况，必须是下面这样的过程：</p>
<ol type="1">
<li>执行一个事务，假设Xid是A；</li>
<li>接下来执行2^64次查询语句，让global_query_Id回到A；</li>
<li>再启动一个事务，这个事务的Xid也是A。</li>
</ol>
<p>不过，2^64这个值太大了，大到你可以认为这个可能性只会存在于理论上。</p>
<h3 id="innodb-trx_id">Innodb trx_id</h3>
<p>Xid和InnoDB的trx_Id是两个容易混淆的概念。</p>
<p>Xid是由server层维护的。InnoDB内部使用Xid，就是为了能够在InnoDB事务和server之间做关联。但是，InnoDB自己的trx_id，是另外维护的。</p>
<p>其实，你应该非常熟悉这个trx_id。它就是我们在第8篇文章<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83MDU2Mg==">《事务到底是隔离的还是不隔离的？》<i class="fa fa-external-link-alt"></i></span>讲事务可见性时，用到的事务id（transaction id）。</p>
<p>InnoDB内部维护了一个max_trx_id全局变量，每次需要申请一个新的trx_id时，就获得max_trx_id的当前值，然后将max_trx_id加1。</p>
<p>InnoDB数据可见性的核心思想是：每一行数据都记录了更新它的trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的trx_id做对比。</p>
<p>对于正在执行的事务，你可以从information_schema.innodb_trx表中看到事务的trx_id。</p>
<p>我在上一篇文章的末尾留给你的思考题，是关于从innodb_trx表里面查到的trx_id的。现在，我们一起来看看一个事务现场：</p>
<img data-src="/2020/08/29/%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E4%BA%86%E5%9B%BE3.png" class>
<p>session B里，我从innodb_trx表里查出的这两个字段，trx_id和trx_mysql_thread_id，第二个字段trx_mysql_thread_id就是线程id。显示线程id，是为了说明这两次查询看到的事务对应的线程id都是5，也就是session A所在的线程。</p>
<p>可以看到，T2时刻显示的trx_id是一个很大的数；T4时刻显示的trx_id是1289，看上去是一个比较正常的数字。这是什么原因呢？</p>
<p>实际上，在T1时刻，session A还没有涉及到更新，是一个只读事务。而对于只读事务，InnoDB并不会分配trx_id。也就是说：</p>
<ol type="1">
<li>在T1时刻，trx_id的值其实就是0。而这个很大的数，只是显示用的。一会儿我会再和你说说这个数据的生成逻辑。</li>
<li>直到session A在T3时刻执行insert语句的时候，InnoDB才真正分配了trx_id。所以，T4时刻，session B查到的这个trx_id的值就是1289。</li>
</ol>
<p>需要注意的是，除了显而易见的修改类语句外，如果select语句后面加上for update，这个事务也不是只读事务。</p>
<p>在上一篇文章的评论区，有同学提出，实验的时候发现不止加1。这是因为：</p>
<ol type="1">
<li>update和delete语句除了事务本身，还涉及到标记删除旧数据，也就是要把数据放到purge队列里等待后续的物理删除，这个操作也会把max_trx_id+1，因此在一个事务中至少加2；</li>
<li>而InnoDB的后台操作，比如表的索引信息统计这类操作，也是会启动内部事务的，因此你可能看到，trx_id值并不是按照加1递增的。</li>
</ol>
<p>那么，<strong>T2时刻查到的这个很大的数字是怎么来的呢？</strong></p>
<p>其实，这个数字是每次查询的时候由系统临时计算出来的。它的算法是：把当前事务的trx变量的指针地址转成整数，再加上2^48。使用这个算法，就可以保证以下两点：</p>
<ol type="1">
<li>因为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在innodb_trx还是在innodb_locks表里，同一个只读事务查出来的trx_id就会是一样的。</li>
<li>如果有并行的多个只读事务，每个事务的trx变量的指针地址肯定不同。这样，不同的并发只读事务，查出来的trx_id就是不同的。</li>
</ol>
<p>那么，<strong>为什么还要再加上2^48呢？</strong></p>
<p>在显示值里面加上2^48，目的是保证只读事务显示的trx_id值比较大，正常情况下就会区别于读写事务的id。但是，trx_id跟row_id的逻辑类似，定义长度也是8个字节。因此，在理论上还是可能出现一个读写事务与一个只读事务显示的trx_id相同的情况。不过，这个概率很低，并且也没有什么实质的危害，可以不管它。</p>
<p>另一个问题是，<strong>只读事务不分配trx_id，有什么好处呢？</strong></p>
<ul>
<li>一个好处是，这样做可以减小事务视图里面活跃事务数组的大小。因为正在运行的只读事务，是不影响数据的可见性判断的，所以在创建事务的一致性视图时，InnoDB就只需要拷贝读写事务的trx_id；</li>
<li>另一个好处是，可以减少trx_id的申请次数。在InnoDB里，即使你只是执行一个普通的select语句，在执行过程中，也是要对应一个只读事务的。所以只读事务优化后，普通的查询语句不需要申请trx_id，就大大减少了并发事务申请trx_id时的锁冲突。</li>
</ul>
<p>由于只读事务不分配trx_id，一个自然而然的结果就是trx_id的增加速度变慢了。</p>
<p>但是，max_trx_id会持久化存储，重启也不会重置为0，那么从理论上讲，只要一个MySQL服务跑得足够久，就可能出现max_trx_id达到2^48-1的上限，然后从0开始的情况。</p>
<p>当达到这个状态后，MySQL就会持续出现一个脏读的bug，我们来复现一下这个bug。</p>
<p>首先我们需要把当前max_trx_id先修改成2^48-1。注意：这个case里使用的是可重复读隔离级别。具体的操作流程如下：</p>
<img data-src="/2020/08/29/%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/%E8%87%AA%E5%A2%9Eid%E7%94%A8%E5%AE%8C%E4%BA%86%E5%9B%BE4.png" class>
<p>由于我们已经把系统的max_trx_id设置成了2^48，所以在session A启动的事务TA的低水位就是2^48-1。</p>
<p>在T2时刻，session B执行第一条update语句的事务id就是2^48-1，而第二条update语句的事务id就是0了，这条update语句执行后生成的数据版本上的trx_id就是0。</p>
<p>在T3时刻，session A执行select语句的时候，判断可见性发现，c=3这个数据版本的trx_id，小于事务TA的低水位，因此认为这个数据可见。</p>
<p>但，这是个脏读。</p>
<p>由于低水位值会持续增加，而事务id从0开始计数，就导致了系统在这个时刻之后，所有的查询都会出现脏读的。</p>
<p>并且，MySQL重启时max_trx_id也不会清0，也就是说重启MySQL，这个bug仍然存在。</p>
<p>那么，<strong>这个bug也是只存在于理论上吗？</strong></p>
<p>假设一个MySQL实例的TPS是每秒50万，持续这个压力的话，在17.8年以后，就会出现这个情况。如果TPS更高，这个年限自然也就更短了。但是，从MySQL真正开始流行到现在，恐怕都还没有实例跑到过这个上限。不过，这个bug是只要MySQL实例的服务时间够长，就会必然出现的。</p>
<p>当然，这个例子更现实的意义是，可以加深我们对低水位和数据可见性的理解。你也可以借此机会，再回顾一下第8篇文章中<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83MDU2Mg==">《事务到底是隔离的还是不隔离的？》<i class="fa fa-external-link-alt"></i></span>中相关的内容。</p>
<h3 id="thread_id">thread_id</h3>
<p>接下来，我们再看看线程id（thread_id）。其实，线程id才是MySQL中最常见的一种自增id。平时我们在查各种现象的时候，show processlist里面的第一列，就是thread_id。</p>
<p>thread_id的逻辑很好理解：系统保存了一个全局变量thread_id_counter，每新建一个连接，就将thread_id_counter赋值给这个新链接的线程变量。</p>
<p>thread_id_counter定义的大小是4个字节，因此达到2^32-1后，它就会重置为0，然后继续增加。但是，你不会再show processlist里看到两个相同的thread_id。</p>
<p>这是因为，MySQL设计了一个唯一数组的逻辑，给新线程分配thread_id的时候，逻辑代码是这样的：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">   new_id = thread_id_counter++;</span></span><br><span class="line"><span class="comment">&#125;</span> <span class="keyword">while</span> (!thread_ids.insert_unique(new_id).second);</span><br></pre></td></tr></table></figure>
<p>这个代码逻辑简单而且实现优雅，相信你一看就能明白。（唯一数组中存在，就加1，直到不存在。）</p>
<h3 id="小结">小结</h3>
<p>今天这篇文章，我给你介绍了MySQL不同的自增id达到上限以后的行为。数据库系统作为一个可能需要7*24小时全年无休的服务，考虑这些边界是非常有必要的。</p>
<p>每种自增id有各自的应用场景，在达到上限后的表现也不同：</p>
<ol type="1">
<li>表的自增id达到上限后，在申请时它的值就不改变，进而导致继续插入数据时报主键冲突的错误。</li>
<li>row_id达到上限后，会归0再重新递增，如果出现相同的row_id，后写的数据会覆盖之前的数据。</li>
<li>Xid只需要不在同一个binlog文件中出现重复值即可，虽然理论上会出现重复值，但是概率极小，可以忽略不计。</li>
<li>InnoDB的max_trx_id递增值每次MySQL重启都会被保存起来，所以我们在文章中提到的脏读的例子就是一个必现的bug，好在留给我们的时间还很充裕。</li>
<li>thread_id是我们使用中最常见的，而且也是处理得最好的一个自增id逻辑了。</li>
</ol>
<p>当然，在MySQL里还有别的自增id，比如table_id、binlog文件序号等，就留给你去验证和探索了。</p>
<p>不同的自增id有不同的上限值，上限值的大小取决于声明的类型长度。而我们的专栏声明的上限id就是45，所以今天这篇文章也是我们最后一篇技术文章了。</p>
<p>既然没有下一个id了，课后也就没有思考题了</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>蓄水池算法</title>
    <url>/2020/07/21/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="蓄水池采样算法reservoir-sampling">蓄水池采样算法（Reservoir Sampling）</h1>
<p>蓄水池采样算法是非常常用的一种<strong>流式数据处理算法</strong>。</p>
<h2 id="问题">问题</h2>
<h3 id="大致描述">大致描述：</h3>
<p>给出一个数据流，这个数据流的长度很大或未知，并且对该数据流中的数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。</p>
<h3 id="一些实际问题">一些实际问题</h3>
<ol type="1">
<li>从 100,000 分调查报告中抽取1000份进行统计。</li>
<li>从一本很厚的电话簿中抽取1000人进行姓氏统计。</li>
<li>从google搜索"Ken Thompson"，从中抽取100个结果查看哪些是今年的。</li>
</ol>
<p>这些都是很基本的采样问题。</p>
<p>既然说的采样问题，最重要的就是做到公平，也就是保证每个元素被采样到的概率是相同的。</p>
<p>对于第一个问题，我们已经知道数据的规模，通过算法生成[0, 100,000-1]间的随机数1000个，并且保证不重复即可。再取出对应的元素即可。</p>
<p>但是对于第二和第三个问题，我们不知道数据的整体规模是多大。可能有人会想到，可以先对数据进行一次遍历，计算出数据的规模N，然后按照第一题的方法采样即可。这当然可以，但是并不好。因为这可能需要遍历两次，需要花两次的时间。也可以尝试估算数据的规模，但是这样得到的采样数据可能并不平均。</p>
<h3 id="问题严格定义">问题严格定义</h3>
<p>给你一个长度为N的链表。N很大，但你不知道N有多大。你的任务是从这N个元素中随机抽取k个元素。你只能遍历这个链表一次。你的算法必须保证取出的元素恰好有k个，且它们是完全随机的（出现概率相等的）。</p>
<h2 id="解法">解法</h2>
<h3 id="蓄水池算法">蓄水池算法：</h3>
<p>蓄水池算法是针对从一个序列中随机抽取不重复的K个数，保证每个数被抽取到的概率都为K/N这个问题构建的。</p>
<h3 id="做法">做法：</h3>
<p>首先构造一个可以容纳k个元素的蓄水池（数组），将序列前k个元素直接放入蓄水池数组中。</p>
<p>然后从第i = k+1个数据开始，以k/i（k&lt;i&lt;=n）的概率决定它是否进入到蓄水池中。蓄水池中的k个元素被替换出去的概率是相同的。</p>
<p>当遍历完所有元素之后，数组中剩下的元素即为所需采取的样本。</p>
<h2 id="证明">证明</h2>
<p>对于第i个数（i &lt;= k）。在k步之前，被选中的概率为1。当走到第k+1步时，被k+1个元素替换的概率=第k+1个元素被选中的概率<em>i被替换的概率，即为 k/(k+1) </em> 1/k = 1/(k+1)。则不被第k+1个元素替换的概率为1 - 1/(k+1) = k/(k+1)。依次类推，不被K+2个元素替换的概率为1-k/(k+2) * 1/k = (k+1)/(k+2)。则运行到第n步时，第i个数仍保留的概率=被选中的概率<em>不被替换的概率，即： <span class="math display">\[
1 \times \frac {k}{k+1}\times \frac {k+1}{k+2}\times \frac {k+2}{k+3}\times ...\times \frac {n-1}{n} = \frac {k}{n}
\]</span> 对于第j个数（j&gt;k）。我们知道，在第j步被选中的概率为k/j。不被j+1个元素替换的概率为1 - k/(j+1) </em> 1/k = j/(j+1)。则运行到第n步时，第i个数仍保留的概率=被选中的概率*不被替换的概率，即： <span class="math display">\[
\frac {k}{j}\times \frac {j}{j+1}\times \frac {j+1}{j+2}\times \frac {j+2}{j+3}\times ... \times \frac {n-1}{n} = \frac {k}{n}
\]</span> 所以对于中每个元素，被保留的概率都为k/n。</p>
<h2 id="实现">实现</h2>
<p>python3版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 蓄水池算法实现.py</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReservoirSampling</span>(<span class="params">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sample</span>(<span class="params">self, node, k</span>):</span></span><br><span class="line">        data = []</span><br><span class="line">        <span class="comment"># 计数器</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            counter += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 前k个元素直接放入</span></span><br><span class="line">            <span class="keyword">if</span> counter &lt;= k:</span><br><span class="line">                data.append(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 判断第j个元素是否留下</span></span><br><span class="line">                <span class="keyword">if</span> random.randint(<span class="number">1</span>, counter) &lt;= k:</span><br><span class="line">                    <span class="comment"># 判断替换掉哪个元素</span></span><br><span class="line">                    removed_idx = random.randint(<span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># 替换该元素，放入新元素</span></span><br><span class="line">                    data[removed_idx] = node</span><br><span class="line">                <span class="comment"># 如果不留下，就继续</span></span><br><span class="line">            <span class="comment"># 访问下一个node</span></span><br><span class="line">            node = next(node)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params">object</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">            self.val = val</span><br><span class="line">            self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> self.next</span><br><span class="line"></span><br><span class="line">    head = ListNode(<span class="number">0</span>)</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">        cur.next = ListNode(i)</span><br><span class="line">        cur = cur.next</span><br><span class="line">    rs = ReservoirSampling()</span><br><span class="line">    res = rs.sample(head, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> res:</span><br><span class="line">        print(node.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="实战题目">实战题目</h2>
<h4 id="链表随机节点"><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtcmFuZG9tLW5vZGUv">382. 链表随机节点<i class="fa fa-external-link-alt"></i></span></h4>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>被讨厌的勇气</title>
    <url>/2020/08/24/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/</url>
    <content><![CDATA[<p>「被讨厌的勇气」真是一本好书，希望大家都能看一看。</p>
<p>这里开始简单记录书中一些我认为很有意义的话。</p>
<ol type="1">
<li><p>阿德勒心理学就是勇气心理学，人不能缺乏”<strong>获得幸福的勇气</strong>“。</p></li>
<li><p>人之所以不幸正是因为自己亲手选择了”不幸“，而不是因为生来就不幸。是因为你认为”不幸“对你自身而言是一种”善“。是因为你在不断地下着不改变自己生活方式的决心。即使人们有各种不满，但还是认为保持现状更加轻松、更能安心。</p></li>
<li><p>哲人：是的。<strong>以自己的不幸为武器支配对方</strong>。通过诉说自己如何不幸、如何痛苦来让周围的人——比如家人或朋友——担心或束缚支配其言行。刚开始提到的那些闭门不出者就常常沉浸在以不幸为武器的优越感中。阿德勒甚至指出：”在我们的文化中，弱势其实非常强大而且具有特权。”</p>
<p>青年：什么叫“弱势具有特权”？</p>
<p>哲人：阿德勒说：“在我们的文化中，如果要问谁最强大，那答案也许是婴儿。婴儿其实总是处于支配而非被支配的地位。”婴儿就是通过其弱势的特点来支配大人。并且，婴儿因为弱势所以不受任何人的支配。</p>
<p>青年：……根本没有这种观点。</p>
<p>哲人：当然，负伤之人所说的“你无法体会我的心情”之类的话中也包含着一定的事实。谁都无法完全理解痛苦的当事人的心情。但是，只要把自己的不幸当作保持“特别”的武器来用，<strong>那人就会永远需要不幸</strong>。</p></li>
<li><p>哲人：<strong>健全的自卑感不是来自与别人的比较，而是来自与“理想的自己”的比较。</strong></p>
<p>青年：但是……</p>
<p>哲人：好吧，我们都不一样。性别、年龄、知识、经验、外貌，没有完全一样的人，我们应该积极地看待自己与别人的差异。但是，我们“<strong>虽然不同但是平等</strong>”。</p></li>
<li><p><strong>可以把马带到水边，但不能强迫其喝水。基本上，一切人际关系矛盾都起因于对别人的课题妄加干涉或者自己的课题被别人妄加干涉。能够改变自己的只有自己。</strong>别人不是为了满足你的期待而活。即使是自己的孩子也不是为了满足父母的期待而活。</p></li>
<li><p>关于自己的人生你能够做的就只有“<strong>选择自己认为最好的道路</strong>”。另一方面，<strong>别人如何评价你的选择，那是别人的课题，你根本无法左右</strong>。</p></li>
<li><p><strong>不去干涉别人的课题也不让别人干涉自己的课题。</strong>这就是阿德勒心理学给出的具体而且可能彻底改变人际关系烦恼的具有划时代意义的观点。</p></li>
<li><p><strong>毫不在意别人的评价、不害怕被别人讨厌、不追求被他人认可，如果不付出以上这些代价，那就无法贯彻自己的生活方式</strong>，也就是不能获得自由。</p></li>
<li><p><strong>活在害怕关系破裂的恐惧之中，那是为他人而活的一种不自由的生活方式。</strong></p></li>
<li><p><strong>不可以表扬也不可以批评</strong>，这就是阿德勒心理学的立场。</p></li>
<li><p><strong>表扬这种行为含有“有能力者对没能力者所做的评价”这方面的特点。</strong></p></li>
<li><p><strong>阿德勒心理学反对一切”纵向关系“，提倡把所有的人际关系都看作”横向关系“。</strong>在某种意义上，这可以说是阿德勒心理学的基本原理。</p></li>
<li><p><strong>自卑感原本就是从纵向关系中产生的一种意识</strong>。只要能够对所有人都建立起”虽不同但平等“的横向关系，那就根本不会产生自卑情结。</p></li>
<li><p>那么，人为什么会去干涉别人呢？其背后实际上也是一种纵向关系。<strong>正因为把人际关系看成纵向关系、把对方看得比自己低，所以才会去干涉。</strong>希望通过干涉行为把对方导向成自己希望的方向。这是坚信自己正确而对方错误。</p>
<p>当然，这里的干涉就是操纵。命令孩子”好好学习“的父母就是个典型例子。也许本人是出于善意，但结果却是妄加干涉，因为这是想按照自己的意思去操纵对方。</p></li>
<li><p><strong>阿德勒心理学把这种基于横向关系的援助称为”鼓励“。</strong></p></li>
<li><p><strong>因为人会因为被表扬而形成”自己没能力“的信念。</strong></p></li>
<li><p><strong>最重要的是不"评价"他人</strong>，评价性的语言是基于纵向关系的语言。如果是基于横向关系，那自然就会说出一些更加真诚地表示感谢、尊敬或者喜悦的话。</p></li>
<li><p><strong>人在听到感谢之词的时候，就会知道自己能够对别人有所贡献。</strong></p></li>
<li><p>例如，人样才能够获得“勇气”？阿德勒的简洁是：<strong>人只有在能够感觉到自己有价值的时候才可以获得勇气。</strong></p></li>
<li><p><strong>人只有在可以体会到“我对共同体有用”的时候才能够感觉到自己的价值。</strong></p></li>
<li><p>请不要用“行为”标准而是用“存在”标准去看待他人；不要用他人“做了什么”去判断，而应对其存在本身表示喜悦和感谢。</p></li>
<li><p>关于共同体感觉问题，也有人向阿德勒本人提出过同样的疑问。当时，阿德勒的回答是这样的：<strong>“必须得有人开始。即使其他人不合作，那也跟你没关系。我的意见就是这样：应该由你来开始。不必去考虑他人是否合作。”</strong></p></li>
<li><p><strong>如果你与某人建立起了纵向关系，那你就会不自觉地从“纵向”去把握所有的人际关系。</strong></p></li>
<li><p>并不是说将任何人都变成朋友或者像对待朋友一样去对待每一个人，不是这样的，<strong>重要的是意识上的平等以及坚持自己应有的主张。</strong></p></li>
<li><p><strong>上帝，请赐予我平静，去接受我无法改变的；给予我勇气，去改变我能改变的；赐我智慧，分辨这两者的区别。</strong></p></li>
<li><p>是的，我们并不缺乏能力，只是缺乏“勇气”。一切都是“勇气”的问题。</p></li>
<li><p><strong>在相信他人的时候不附加任何条件。</strong>即使没有足以构成信用的客观依据也依然相信，不考虑抵押之类的事情，无条件的相信。这就是信赖。</p></li>
<li><p>你现在认为“无条件地信赖别人只会遭到背叛”。但是，决定背不背判的不是你，那是他人的课题。<strong>你只需要考虑“我该怎么做”。</strong></p></li>
<li><p>你现在一味地担心“被背叛”，也只关注因此受到的伤痛。但是，<strong>如果不敢去信赖别人，那最终就会与任何人都建立不了深厚的关系。</strong></p></li>
<li><p><strong>他者贡献并不是舍弃“我”而为他人效劳，它反而是为了能够体会到“我”的价值而采取的一种手段。</strong></p></li>
<li><p><strong>任何情况下都只是攻击我的“那个人”有问题，而绝不是“大家”的错。</strong></p></li>
<li><p><strong>只不过是以工作为借口来逃避其他责任。</strong>本来家务、育儿、交友或兴趣应该全都给予关心，阿德勒不认可任何一方面突出的生活方式。</p></li>
<li><p><strong>对人而言，最大的不幸就是不喜欢自己。</strong>对于这种现实，阿德勒准备了极其简单的回答——“我对共同体有益”或者“我对他人有用”这种想法就足以让人体会到自己的价值。</p></li>
<li><p>青年：您是说，只要有了共同体感觉认可欲求就会消失吗？</p>
<p>哲人：会消失。<strong>不再需要他人的认可。</strong></p></li>
<li><p>如果人生是一条线，那么人生规划就有可能。但是，我们的人生只是点的连续。<strong>计划式的人生不是有没有必要，而是根本不可能。</strong></p></li>
<li><p>请你这样想。<strong>人生就像是在每一个瞬间不同旋转起舞的连续的刹那。</strong>并且，蓦然四顾时常常会惊觉：”已经来到这里了吗？“</p></li>
<li><p>在舞蹈中，跳舞本身就是目的，最终会跳到哪里谁都不知道。当然，作为跳的结果最终会到达某个地方。因为一直在跳动所以不会停在原地。但是，<strong>并不存在目的地</strong>。</p></li>
<li><p><strong>如果把强烈的聚光灯对准”此时此刻“，那就会既看不到过去也看不到未来。</strong></p></li>
<li><p>过去发生了什么与你的”此时此刻“没有任何关系，未来会如何也不是”此时此刻“要考虑的问题。</p></li>
<li><p>人生中最大的黄痰就是不活在”此时此刻“。</p></li>
<li><p>所以阿德勒再说了”并不存在普遍性的人生意义“之后还说：”<strong>人生意义是自己赋予自己的。</strong>“</p></li>
<li><p>无论你过着怎么的刹那，即使有人讨厌你，<strong>只要没有迷失”他者贡献“这颗引导之星，那么你就不会迷失而且做什么都可以</strong>。即使被讨厌自己的人讨厌着也可以自由的生活。</p></li>
<li><p><strong>世界不是靠他人改变而只能靠”我“来改变。</strong></p></li>
</ol>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>要不要使用分区表？</title>
    <url>/2020/08/29/%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="分区表是什么">分区表是什么？</h3>
<p>为了说明分区表的组织形式，我先创建一个表t；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`ftime`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">KEY</span> (<span class="string">`ftime`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2017</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2018</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2019</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"><span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="string">&#x27;2017-4-1&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;2018-4-1&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<img data-src="/2020/08/29/%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F/%E5%88%86%E5%8C%BA%E8%A1%A81.png" class>
<p>我在表t初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在p_2018和p_2019这两个分区上。</p>
<p>可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：</p>
<ol type="1">
<li>对于引擎层来说，这是4个表；</li>
<li>对于Server层来说，这是1个表。</li>
</ol>
<p>你可能会觉得这两句话都是废话。其实不然，这两句话非常重要，可以帮我们理解分区变的执行逻辑。</p>
<h3 id="分区表的引擎层行为">分区表的引擎层行为</h3>
<p>我先给你举个在分区表加间隙锁的例子，目的是说明对于InnoDB来说，这是4个表。</p>
<img data-src="/2020/08/29/%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F/%E5%88%86%E5%8C%BA%E8%A1%A82.png" class>
<p>这里顺便复习一下，我在第21篇文章和你介绍的间隙锁加锁规则。</p>
<p>我们初始化表t的时候，只插入了两行数据，ftime的值分别是，’2017-4-1‘和’2018-4-1‘。session A的select语句对索引ftime上这两个记录之间的间隙加了锁。如果是一个普通表的话，那么T1时刻，在表t的ftime索引上，间隙和加锁状态应该是图3这样的。</p>
<img data-src="/2020/08/29/%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F/%E5%88%86%E5%8C%BA%E8%A1%A83.jpg" class>
<p>也就是说，'2017-4-1'和’2018-4-1‘这两个记录之间的间隙是会被锁住的。那么，session B的两条插入语句应该都要进入锁等待状态。</p>
<p>但是，从上面的实验效果可以看出，session B的第一个insert语句是可以执行成功的。这是因为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是2018-4-1，而是p_2018分区的supremum。所以T1时刻，在表t的ftime索引上，间隙和加锁的状态其实是图4这样的：</p>
<img data-src="/2020/08/29/%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F/%E5%88%86%E5%8C%BA%E8%A1%A84.jpg" class>
<p>由于分区表的规则，session A的select语句其实只操作了分区p_2018，因此加锁范围就是图4中深绿色的部分。</p>
<p>所以，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记录，就要等session A的间隙锁。</p>
<p>图5就是这时候的show engine innodb status的部分结果。</p>
<img data-src="/2020/08/29/%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F/%E5%88%86%E5%8C%BA%E8%A1%A85.png" class>
<p>看完InnoDB引擎的例子，我们再来一个MyISAM分区表的例子。</p>
<p>我首先用alter table t engine=myisam，把表t改成MyISAM表；然后，我再用下面这个例子说明，对于MyISAM引擎来说，这是4个表。</p>
<img data-src="/2020/08/29/%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F/%E5%88%86%E5%8C%BA%E8%A1%A86.png" class>
<blockquote>
<p>注：这是在用MyISAM的表锁验证，MyISAM引擎只支持表锁。</p>
</blockquote>
<p>在session A里面，我用sleep(100)将这条语句的执行时间设置为100秒。由于MyISAM引擎只支持表锁，所以这条update语句会锁住整个表t上的读。</p>
<p>但我们看到的结果是，session B的第一条查询语句是可以正常执行的，第二条语句才进入锁等待状态。</p>
<p>这正是因为MyISAM的表锁是在引擎层实现的，session A加的表锁，其实是锁在分区p_2018上。因此，只会堵住在这个分区上执行的查询，落到其他分区的查询是不受影响的。</p>
<p>看到这里，你可能会说，分区表看来还不错嘛，为什么不让用呢？我们使用分区表的一个重要原因就是单表过大。那么，如果不使用分区表的话，我们就是要使用手动分表的方式。</p>
<p>接下来，我们一起看看手动分表和分区表有什么区别。</p>
<p>比如，按照年份来划分，我们就分别创建普通表t_2017、t_2018、t_2019等等。手工分表的逻辑，也是找到需要更新的所有分表，然后依次执行更新。在性能上，这和分区表并没有实质的差别。</p>
<p>分区表和手工分表，一个是有server层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表。因此，从引擎层看，这两种方式也是没有差别的。</p>
<p>其实这两个方案的区别，主要是在server层上。从server层看，我们就不得不提到分区表一个被广为诟病的问题</p>
<p>：打开表的行为。</p>
<h3 id="分区策略">分区策略</h3>
<p>每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。<strong>一个典型的报错情况</strong>是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时候，open_files_limit参数使用的是默认值1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。</p>
<p>下图就是我创建的一个包含了很多分区的表t_myisam，执行一条插入语句后报错的情况。</p>
<img data-src="/2020/08/29/%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F/%E5%88%86%E5%8C%BA%E8%A1%A87.png" class>
<p>可以看到，这条insert语句，明显只需要访问一个分区，但语句却无法执行。</p>
<p>这时，你一定从表名猜到了，这个表我用的是MyISAM引擎。是的，因为使用InnoDB引擎的话，并不会出现这个问题。</p>
<p>MyISAM分区表使用的分区策略，我们称为<strong>通用分区策略</strong>（generic partitioning），每次访问分区都由server层控制。通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。</p>
<p>从MySQL 5.7.9开始，InnoDB引擎引入了<strong>本地分区策略</strong>（native partitioning）。这个策略是在InnoDB内部自己管理打开分区的行为。</p>
<p>MySQL从5.7.17开始，将MyISAM分区表标记为即将弃用（deprecated），意思是”从这个版本开始不建议这么使用，请使用替代方案。在将来的版本中会废弃这个功能“。</p>
<p>从MySQL8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。</p>
<p>接下来，我们再看一下分区表在server层的行为。</p>
<h3 id="分区表的server层行为">分区表的server层行为</h3>
<p>如果从server层看的话，一个分区表就只是一个表。</p>
<p>这句话是什么意思呢？接下来，我就用下面这个例子来和你说明。如图8和如图9所示，分别是这个例子的操作序列和执行结果图。</p>
<img data-src="/2020/08/29/%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F/%E5%88%86%E5%8C%BA%E8%A1%A88.png" class>
<img data-src="/2020/08/29/%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%9F/%E5%88%86%E5%8C%BA%E8%A1%A89.png" class>
<p>可以看到，虽然session B只需要操作p_2017这个分区，但是由于session A持有整个表t的MDL锁，就导致了session B的alter语句被堵住。</p>
<p>这也是DBA同学经常说的，分区表，在做DDL的时候，影响会更大。如果你使用的是普通分表，那么当你在truncate一个分表的时候，肯定不会跟另外一个分表上的查询语句，出现MDL锁冲突。</p>
<p>到这里我们小结一下：</p>
<ol type="1">
<li>MySQL在第一次打开分区表的时候，需要访问所有的分区；</li>
<li>在server层，认为这是同一张表，因此所有分区共用同一个MDL锁；</li>
<li>在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区。</li>
</ol>
<p>而关于”必要的分区“的判断，就是根据SQL语句中的where条件，结合分区规则来实现的。比如我们上面的例子中，where ftime=’2018-4-1‘，根据分区规则year函数算出来的值是2018，那么就会落在p_2019这个分区。</p>
<p>但是，如果这个where条件改成where ftime&gt;='2018-4-1'，虽然查询结果相同，但是这时候根据where条件，就要访问p_2019和p_others这两个分区。</p>
<p>如果查询语句的where条件中没有分区key，那就只能访问所有分区了。当然，这并不是分区表的问题。即使是使用业务分表的方式，where条件中没有使用分表的key，也必须访问所有的分表。</p>
<p>我们已经理解了分区表的概念，那么什么场景下适合使用分区表呢？</p>
<h3 id="分区表的应用场景">分区表的应用场景</h3>
<p>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。</p>
<p>如果一项业务跑的时间足够长，往往就会有根据时间删除历史数组的需求。这时候，按照时间分区的分区表，就可以直接通过alter table t drop partition...这个语法删掉分区，从而删掉过期的历史数据。</p>
<p>这个alter table t drop partition...操作是直接删除分区文件，效果跟drop普通表类似。与使用delete语句删除数据相比，优势是速度快、对系统影响小。</p>
<h3 id="小结">小结</h3>
<p>这篇文章，我主要和你介绍的是server层和引擎层对分区表的处理方式。我希望通过这些介绍，你能够对是否选择使用分区表，有更清晰的想法。</p>
<p>需要注意的是，我是以范围分区（range）为例和你介绍的。实际上，MySQL还支持hash分区、list分区等分区方法。你可以在需要用到的时候，再翻翻<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3BhcnRpdGlvbmluZy10eXBlcy5odG1s">手册<i class="fa fa-external-link-alt"></i></span>。</p>
<p>实际使用时，分区表跟用户分表比起来，有两个绕不开的问题：一个是第一次访问的时候需要访问所有分区，另一个是共用MDL锁。</p>
<p>因此，如果要使用分区表，就不要创建太多的分区。我见过一个用户做了按天分区策略，然后预先创建了10年的分区。这种情况下，访问分区表的性能自然是不好的。这里有两个问题需要注意：</p>
<ol type="1">
<li>分区并不是越细越好。实际上，单表或者单分区的数据到1千万行，只要没有特别大的索引，对于现在的硬件能力来说已经算是小表了。</li>
<li>分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的12个分区创建上即可。对于没有数据的历史分区，要及时的drop掉。</li>
</ol>
<p>至于分区表的其他问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是分区表本身的问题，而是数据量的问题，或者说是使用方式的问题了。</p>
<p>当然，如果你的团队已经维护了一个成熟的分库分表中间件，用业务分表，对业务开发同学来说，并没有额外的复杂性，对DBA也更直观，自然是更好的。</p>
<p>最后，我给你留一个思考题吧。</p>
<p>我们举例的表中，没有用到自增主键，假如现在要创建一个自增字段id。MySQL要求分区表中的主键必须包含分区字段。如果要在表t的基础上做修改，你会怎么定义这个表的主键呢？为什么这么定义呢？</p>
<p>解答：</p>
<p>上期的问题是，怎么给分区表t创建自增主键。由于MySQL要求主键包含所有的分区字段，所以肯定是要创建联合主键的。</p>
<p>这时候就有两种可选：一种是（ftime, id），另一种是（id, ftime）。</p>
<p>如果从利用率上来看，应该使用（ftime, id）这种模式。因为用ftime做分区key，说明大多数语句都是包含ftime的，使用这种模式，可以利用前缀索引的规则，减少一个索引。</p>
<p>这时的建表语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"> <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> <span class="string">`ftime`</span> datatime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`ftime`</span>, <span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2017</span>) <span class="keyword">ENGINE</span> = MyISAM,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2018</span>) <span class="keyword">ENGINE</span> = MyISAM,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2019</span>) <span class="keyword">ENGINE</span> = MyISAM,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE <span class="keyword">ENGINE</span> = MyISAM);</span><br></pre></td></tr></table></figure>
<p>当然，我的建议是你要尽量使用InnoDB引擎。InnoDB表要求至少有一个索引，以自增字段作为第一个字段，所以需要一个id的单独索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`ftime`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`ftime`</span>,<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`id`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2017</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2018</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2019</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>);</span><br></pre></td></tr></table></figure>
<p>当然把字段反过来，创建成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PRIMARY KEY (`id`,`ftime`),</span><br><span class="line">KEY `id` (`ftime`)</span><br></pre></td></tr></table></figure>
<p>也是可以的。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>解决博弈问题的动态规划通用思路</title>
    <url>/2020/07/24/%E8%A7%A3%E5%86%B3%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%80%9A%E7%94%A8%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解决博弈问题动态规划通用思路.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们把石头游戏改得更具有一般性</span></span><br><span class="line"><span class="comment"># 你和你的朋友面前有一排石头堆，用一个数组piles表示</span></span><br><span class="line"><span class="comment"># piles[i]表示第i堆石子有多少个。</span></span><br><span class="line"><span class="comment"># 你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。</span></span><br><span class="line"><span class="comment"># 所有石头被拿完后，谁拥有的石头多，谁获胜</span></span><br><span class="line"><span class="comment"># 假设两人都很聪明，请你设计一个算法，返回先手和后手最后得分（石头总数）之差</span></span><br><span class="line"><span class="comment"># 比如：</span></span><br><span class="line"><span class="comment"># piles = [1, 100, 3]</span></span><br><span class="line"><span class="comment"># 先手能得4分，后手能得100分，返回-96</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路</span></span><br><span class="line"><span class="comment"># 子问题</span></span><br><span class="line"><span class="comment"># 在第i到第j堆石头，先手能获得最大石头数是多少，后手是多少</span></span><br><span class="line"><span class="comment"># 定义状态数组</span></span><br><span class="line"><span class="comment"># f(i, j, 0) f(i, j, 1) 表示第i到第j个石头，包括第i和第j个，0表示先手，1表示后手</span></span><br><span class="line"><span class="comment"># 因为两人都极聪明，先手选完就变后手，来回交替的</span></span><br><span class="line"><span class="comment"># 递推方程</span></span><br><span class="line"><span class="comment"># f(i, j, 0) = max 拿左边 f(i+1, j, 1) + a[i]</span></span><br><span class="line"><span class="comment">#            =     拿右边 f(i, j-1, 1) + a[j]</span></span><br><span class="line"><span class="comment"># 知道了拿左边还是右边后</span></span><br><span class="line"><span class="comment"># f(i, j, 1) =     先手拿左边 f(i+1, j, 0)</span></span><br><span class="line"><span class="comment">#            =     先手拿右边 f(i, j-1, 0)</span></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line"><span class="comment"># f(i, i, 0) = a[i] 只有一堆石子的时候，先手为该堆石子个数，后手就为0</span></span><br><span class="line"><span class="comment"># f(i, i, 1) = 0</span></span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line"><span class="comment"># f(0, n-1, 0) 先手最终石子数 - f(0, n-1, 1)后手最终石子数</span></span><br><span class="line"><span class="comment"># 优化空间复杂度</span></span><br><span class="line"><span class="comment"># 是对角线的递推，这种情况最好不要优化空间，还可以利用计算机的缓存</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game</span>(<span class="params">self, piles: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> piles:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(piles)</span><br><span class="line">        dp = [[[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i][<span class="number">0</span>] = piles[i]</span><br><span class="line">        <span class="keyword">for</span> gap <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n - gap):</span><br><span class="line">                j = i + gap</span><br><span class="line">                left = dp[i + <span class="number">1</span>][j][<span class="number">1</span>] + piles[i]</span><br><span class="line">                right = dp[i][j - <span class="number">1</span>][<span class="number">1</span>] + piles[j]</span><br><span class="line">                <span class="comment"># 先手选左边</span></span><br><span class="line">                <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = left</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = dp[i + <span class="number">1</span>][j][<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># 先手选右边</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = right</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = dp[i][j - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>][<span class="number">0</span>] - dp[<span class="number">0</span>][n - <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    sol = Solution()</span><br><span class="line"></span><br><span class="line">    piles = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">3</span>]</span><br><span class="line">    res = sol.game(piles)</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h6 id="代表题目">代表题目：</h6>
<h6 id="leetcode-877">leetcode 877</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 也可以使用第2种解法</span></span><br><span class="line"><span class="comment"># 数学规律</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 先拿者可以拿到序号为 1,3,5...n-1 的石子堆，</span></span><br><span class="line"><span class="comment"># 也可以拿到序号为 2,4,6...n 的石子堆。</span></span><br><span class="line"><span class="comment"># 因为总石子数为奇数，所以这两种方式中，其中一种拿到的石子数大于另一种。</span></span><br><span class="line"><span class="comment"># 所以不按照拿尽量多的石子数，按照这种纯奇数序号或者纯偶数序号的方式拿，先拿者总可以赢。</span></span><br></pre></td></tr></table></figure>
<p>dp解法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lass Solution:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGame</span>(<span class="params">self, piles: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> piles:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        n = len(piles)</span><br><span class="line">        dp = [[[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i][<span class="number">0</span>] = piles[i]</span><br><span class="line">        <span class="keyword">for</span> gap <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n - gap):</span><br><span class="line">                j = i + gap</span><br><span class="line">                left = dp[i + <span class="number">1</span>][j][<span class="number">1</span>] + piles[i]</span><br><span class="line">                right = dp[i][j - <span class="number">1</span>][<span class="number">1</span>] + piles[j]</span><br><span class="line">                <span class="comment"># 先手选左边</span></span><br><span class="line">                <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = left</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = dp[i + <span class="number">1</span>][j][<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># 先手选右边</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = right</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = dp[i][j - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> bool(dp[<span class="number">0</span>][n - <span class="number">1</span>][<span class="number">0</span>] - dp[<span class="number">0</span>][n - <span class="number">1</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>讨论已经到达了&#39;水边&#39;，是否喝水就看你的决心了</title>
    <url>/2020/08/28/%E8%AE%A8%E8%AE%BA%E5%B7%B2%E7%BB%8F%E5%88%B0%E8%BE%BE%E4%BA%86-%E6%B0%B4%E8%BE%B9-%EF%BC%8C%E6%98%AF%E5%90%A6%E5%96%9D%E6%B0%B4%E5%B0%B1%E7%9C%8B%E4%BD%A0%E7%9A%84%E5%86%B3%E5%BF%83%E4%BA%86/</url>
    <content><![CDATA[<p><strong>只要没有迷失”他者贡献“这课引导之星，那么你就不会迷失，而且做什么都可以。</strong></p>
<p>我们要像跳舞一样认真过好作为刹那的”此时此刻“，既不看过去也不看未来，只需过好每一个完结的刹那。没必要与谁竞争，也不需要目的地，只要跳着，就一定会到达某一个地方。</p>
<p><strong>我的力量无穷大。</strong></p>
<p><strong>世界不是靠他人改变而只能靠我来改变。</strong></p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>转：说一说这些好问题</title>
    <url>/2020/08/29/%E8%BD%AC%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在我看来，能够帮我们扩展一个逻辑的边界的问题，就是好问题。因为通过解决这样的问题，<strong>能够加深我们对这个逻辑的理解，或者帮我们关联到另外一个知识点，进而可以帮助我们建立起自己的知识网络。</strong></p>
<p>在工作中会问好问题，是一个很重要的能力。</p>
<h3 id="join的写法">join的写法</h3>
<p>在35篇文章《join语句怎么优化?》中，我在介绍join执行顺序的时候，用的都是strainght_join。有同学哉问候提出了两个问题：</p>
<ol type="1">
<li>如果用left join的话，左边的表一定是驱动表吗？</li>
<li>如果两个表的join包含多个条件的等值匹配，是都要写到on里面呢，还是只把一个条件写到on里面，其他条件写到where部分？</li>
</ol>
<p>为了同时回答这两个问题，我来构造两个表a和b：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a(f1 <span class="built_in">int</span>, f2 <span class="built_in">int</span>, <span class="keyword">index</span>(f1))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> b(f1 <span class="built_in">int</span>, f2 <span class="built_in">int</span>)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> a <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> b <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>表a和b都有两个字段f1和f2，不同的是表a的字段f1上有索引。然后，我往两个表中都插入了6条记录，其中在表a和b上同时存在的数据有4行。</p>
<p>同学提到的第二个问题，其实就是下面这两种写法的区别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span> (a.f1=b.f1) <span class="keyword">and</span> (a.f2=b.f2); <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span> (a.f1=b.f1) <span class="keyword">where</span> (a.f2=b.f2); <span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure>
<p>我把这两条语句分别记为Q1和Q2。</p>
<p>首先，需要说明的是，这两个left join语句的语义逻辑并不相同。我们先来看一下它们的执行结果。</p>
<img data-src="/2020/08/29/%E8%BD%AC%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/%E5%A5%BD%E9%97%AE%E9%A2%98-%E4%B8%A4%E4%B8%AAjoin%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C.png" class>
<p>可以看到：</p>
<ol type="1">
<li>语句Q1返回的数据集是6行，表a中即使没有满足匹配条件的记录，查询结果中也会返回一行，并将表b的各个字段值填成NULL。</li>
<li>语句Q2返回的是4行。从逻辑上可以这么理解，最后的两行，由于表b中没有匹配的字段，结果集里面b.f2的值是空，不满足where部分的条件判断，因此不能作为结果集的一部分。</li>
</ol>
<p>接下来，我们看看实际执行这两条语句时，MySQL是怎么做的。</p>
<p>我们先一起看看语句Q1的explain结果：</p>
<img data-src="/2020/08/29/%E8%BD%AC%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/%E5%A5%BD%E9%97%AE%E9%A2%98-Q1%E7%9A%84explain%E7%BB%93%E6%9E%9C.png" class>
<p>可以看到，这个结果符合我们的预期：</p>
<ul>
<li>驱动表是表a，被驱动表是表b；</li>
<li>由于表b的f1字段上没有索引，所以使用的是Block Nested Loop Join（简称BNL）算法。</li>
</ul>
<p>看到BNL算法，你就应该知道这条语句执行流程其实是这样的：</p>
<ol type="1">
<li>把表a的内容读入joiin_buffer中。因为是select *，所以字段f1和f2都被放入join_buffer了。</li>
<li>顺序扫描表b，对于每一行数据，判断join条件（也就是(a.f1=b.f1) and (a.f1=1)）是否满足，满足条件的记录，作为结果集的一行返回。如果语句中有where子句，需要先判断where部分满足条件后，再返回。</li>
<li>表b扫描完成后，对于没有被匹配的表a的行（在这个例子中就是(1,1)、(2,2)这两行），把剩余字段补上NULL，再放入结果集中。</li>
</ol>
<p>对应的流程图如下：</p>
<img data-src="/2020/08/29/%E8%BD%AC%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/%E5%A5%BD%E9%97%AE%E9%A2%982.jpg" class>
<p>可以看到，这条语句确实是以表a为驱动表，而且从执行效果看，也和使用straight_join是一样的。</p>
<p>你可能会想，语句Q2的查询结果里面少了最后两行数据，是不是就是把上面流程中的步骤3去掉呢？我们还是先看一下语句Q2的explain结果吧。</p>
<img data-src="/2020/08/29/%E8%BD%AC%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/%E5%A5%BD%E9%97%AE%E9%A2%983.png" class>
<p>可以看到，这条语句是以表b为驱动表的。而如果一条join语句的Extra字段什么都没写的话，就表示使用的是Index Nested-Loop Join (NLJ) 算法。</p>
<p>因此，语句Q2使用了a的f1索引，执行流程是这样的：顺序扫描表b，每一行用b.f1到表a中去查，匹配到记录后判断a.f2=b.f2是否满足，满足条件的话就作为结果集的一部分返回。</p>
<p>那么，<strong>为什么语句Q1和Q2这两个查询的执行流程会差距这么大呢？</strong>其实，这是因为优化器基于Q2这个查询的语义做了优化。</p>
<p>为了理解这个问题，我需要再和你交代一个背景知识点：在MySQL里，NULL跟任何值执行等值判断和不等值判断的结果，都是NULL。这里包括，select NULL = NULL的结果，也是返回NULL。</p>
<p>因此，语句Q2里面where a.f2=b.f2就表示，查询结果里面不会包含b.f2是NULL的行，这样这个left join的语义就是"找到这两个表里面，f1、f2对应相同的行。对于表a中存在，而表b中匹配不到的行，就放弃"。</p>
<p>这样，这条语句虽然用的是left join，但是语义跟join是一致的。</p>
<p>因此，优化器就把这条语句的left join改写成了join，然后因为表a的f1上有索引，就把表b作为驱动表，，这样就可以用上NLJ算法。在执行explain之后，你再执行show warnings，就能看到这个改写的结果，如图5所示。</p>
<img data-src="/2020/08/29/%E8%BD%AC%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/%E5%A5%BD%E9%97%AE%E9%A2%984.png" class>
<p>这个例子说明，即使我们在SQL语句中写成left join，执行过程还是有可能不是从左到右连接的。也就是说，<strong>使用left join时，左边的表不一定是驱动表。</strong></p>
<p>这样看来，<strong>如果需要left join的语义，就不能把被驱动表的字段放在where条件里面做等值判断或不等值判断，必须都写在on里面。</strong>那如果是join语句呢？</p>
<p>这时候，我们再看看这两条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1=b.f1) <span class="keyword">and</span> (a.f2=b.f2); <span class="comment">/*Q3*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1=b.f1) <span class="keyword">where</span> (a.f2=b.f2); <span class="comment">/*Q4*/</span></span><br></pre></td></tr></table></figure>
<p>我们再使用一次看explain和show warnings的方法，看看优化器是怎么做的。</p>
<img data-src="/2020/08/29/%E8%BD%AC%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/%E5%A5%BD%E9%97%AE%E9%A2%985.png" class>
<p>可以看到，这两条语句都被改写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">join</span> b <span class="keyword">where</span> (a.f1=b.f1) <span class="keyword">and</span> (a.f2=b.f2);</span><br></pre></td></tr></table></figure>
<p>执行计划自然也是一模一样的。</p>
<p>也就是所，在这种情况下，join将判断条件是否全部放在on部分就没有区别了。</p>
<h3 id="simple-nested-loop-join的性能问题">Simple Nested Loop Join的性能问题</h3>
<p>我们知道，join语句使用不同的算法，对语句的性能影响会很大。在34篇文章<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83OTcwMA==">《到底可不可以使用join？》<i class="fa fa-external-link-alt"></i></span>的评论区中，有同学提了一个很不错的问题。</p>
<p>我们在文中说道，虽然BNL算法和Simple Nested Loop Join算法都是要判断M*N次（M和N分别是join的两个表的行数），但是Simple Nested Loop Join算法的每轮判断都要走全表扫描，因此性能上BNL算法执行起来会快很多。</p>
<p>为了便于说明，我还是先为你简单描述一下这两个算法。</p>
<p>BNL算法的执行逻辑是：</p>
<ol type="1">
<li>首先，将驱动表的数据全部读入内存join_buffer中，这里join_buffer是无序数组；</li>
<li>然后，顺序遍历被驱动表的所有行，每一行数据都跟join_buffer中的数据进行匹配，匹配成功则作为结果集的一部分返回。</li>
</ol>
<p>Simple Nested Loop join算法的执行逻辑是：顺序取出驱动表中的每一行数据，到被驱动表做全表扫描匹配，匹配成功则作为结果集的一部分返回。</p>
<p>同学的疑问是，Simple Nested Loop Join算法，其实也是把数据读到内存里，然后按照匹配条件进行判断，为什么性能差距会这么大呢？</p>
<p>解释这个问题，需要用到MySQL中索引结构和Buffer Pool的相关知识点：</p>
<ol type="1">
<li><p>在对被驱动表做全表扫描的时候，如果数据没有在Buffer Pool中，就需要等待这部分数据从磁盘读入；</p>
<p>从磁盘读入数据到内存中，会影响正常业务的Buffer Pool命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到Buffer Pool的头部（请参考<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS84MDE0Nw==">第35篇文章<i class="fa fa-external-link-alt"></i></span>中的相关内容）；</p></li>
<li><p>即使被驱动表数据都是在内存中，每次查找”下一个记录的操作“，都是类似指针操作。而join_buffer中的是数组，遍历的成本更低。</p></li>
</ol>
<p>所以说，BNL算法的性能会更好。</p>
<h3 id="distinct和group-by的性能">distinct和group by的性能</h3>
<p>在<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS84MDQ3Nw==">37篇文章《什么时候会使用内部临时表？》<i class="fa fa-external-link-alt"></i></span>中，同学提了一个好问题：如果只需要去重，不需要执行聚合函数，distinct和group by哪种效率高一些呢？</p>
<p>我来展开一下他的问题：如果表t的字段a上没有索引，那么下面这两条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure>
<p>的性能是不是相同的？</p>
<p>首先需要说明的是，这种group by的写法，并不是SQL标准的写法。标准的group by语句，是需要在select部分加一个聚合函数，比如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">selecrt a, count(*) from t group by a order by null;</span><br></pre></td></tr></table></figure>
<p>这条语句的逻辑是：按照字段a分组，计算每组的a出现次数。在这个结果里，由于做的是聚合计算，相同的a只出现一次。</p>
<blockquote>
<p>备注：这里你可以顺便复习一下<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS84MDQ3Nw==">第37篇文章中<i class="fa fa-external-link-alt"></i></span>关于group by 的相关内容。</p>
</blockquote>
<p>没有了count(*)以后，也就是不再需要执行"计算总数"的逻辑时，第一条语句的逻辑就变成是：按照字段a做分组，相同的a的值只返回一行。而这就是distinct的语义，所以不需要执行聚合函数时，distinct和group by这两条语句的语义和执行流程是相同的，因此执行性能也相同。</p>
<p>这两条语句的执行流程是下面这样的：</p>
<ol type="1">
<li>创建一个临时表，临时表有一个字段a，并且在这个字段a上创建一个唯一索引；</li>
<li>遍历表t，依次取数据插入临时表中：
<ul>
<li>如果发现唯一键冲突，就跳过；</li>
<li>否则插入成功；</li>
</ul></li>
<li>遍历完成后，将临时表作为结果集返回给客户端。</li>
</ol>
<h3 id="备库自增主键问题">备库自增主键问题</h3>
<p>除了性能问题，大家对细节的追问也很到位。在<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS84MDUzMQ==">第39篇文章《自增主键为什么不是连续的？》<i class="fa fa-external-link-alt"></i></span>评论区，有同学问道：在binlog_format=statement时，语句A先获取id=1，然后语句B获取id=2；接着语句B提交，写binlog，然后语句A再写binlog。这时候，如果binlog重放，是不是会发生语句B的id为1，而语句A的id为2的不一致情况呢？</p>
<p>首先，这个问题默认了"自增id的生成顺序，和binlog的写入顺序可能是不同的"，这个理解是正确的。</p>
<p>其次，这个问题限定在statement的格式下，也是对的。因为row格式的binlog就没有这个问题了，Write row event里面直接写了每一行的所有字段的值。</p>
<p>而至于为什么不会发生不一致的情况，我们来看一下下面的这个例子。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(<span class="keyword">id</span>, it auto_increment primary <span class="keyword">key</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<img data-src="/2020/08/29/%E8%BD%AC%EF%BC%9A%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%BA%9B%E5%A5%BD%E9%97%AE%E9%A2%98/%E5%A5%BD%E9%97%AE%E9%A2%986.png" class>
<p>可以看到，在insert语句之前，还有一句SET INSERT_ID=1。这条命令的意思是，这个线程里下一次需要用到自增值的时候，不论当前表的自增值是多少，固定用1这个值。</p>
<p>这个SET INSERT_ID语句是固定跟在insert语句之前的，比如同学提到的场景，主库上语句A的id是1，语句B的id是2，但是写入binlog的顺序先B后A，那么binlog就变成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> INSERT_ID=<span class="number">2</span>;</span><br><span class="line">语句B;</span><br><span class="line"><span class="keyword">SET</span> INSERT_ID=<span class="number">1</span>;</span><br><span class="line">语句A;</span><br></pre></td></tr></table></figure>
<p>你看，在备库上语句B用到的INSERT_ID依然是2，跟主库相同。</p>
<p>因此，即使两个INSERT语句在主备库的执行顺序不同，自增主键字段的值也不会不一致。</p>
<h3 id="小结">小结</h3>
<p>今天这篇答疑文章，我选了4个好问题和你分享，并做了分析。在我看来，能够提出好问题，首先表示这些同学理解了我们文章的内容，进而又做了深入思考。</p>
<p>答疑文章也是要有课后思考题的。</p>
<p>在<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83MDU2Mg==">第8篇文章的评论区<i class="fa fa-external-link-alt"></i></span>，有同学提了一个问题：他查看了一下innodb_trx，发现这个事务的trx_id是一个很大的数（281479535353408），而且似乎在同一个session中启动会话得到的trx_Id是保持不变的。当执行任何加写锁的语句后，trx_id都会变成一个很小的数字(118378)。</p>
<p>你可以通过实验验证一下，然后分析看看，事务id的分配规则是什么，以及MySQL为什么要这么设计呢？</p>
<p>解答： 只读事务id是临时生成的，原本trx_id的值就是0。计算的算法是：把当前事务的trx变量的指针地址转成整数，再加上2^48。</p>
<p>实际上，在T1时刻，session A还没有涉及到更新，是一个只读事务。而对于只读事务，InnoDB并不会分配trx_id。也就是说：</p>
<ol type="1">
<li>在T1时刻，trx_id的值其实就是0。而这个很大的数，只是显示用的。一会儿我会再和你说说这个数据的生成逻辑。</li>
<li>直到session A在T3时刻执行insert语句的时候，InnoDB才真正分配了trx_id。所以，T4时刻，session B查到的这个trx_id的值就是1289。</li>
</ol>
<p>需要注意的是，除了显而易见的修改类语句外，如果select语句后面加上for update，这个事务也不是只读事务。</p>
<p>在上一篇文章的评论区，有同学提出，实验的时候发现不止加1。这是因为：</p>
<ol type="1">
<li>update和delete语句除了事务本身，还涉及到标记删除旧数据，也就是要把数据放到purge队列里等待后续的物理删除，这个操作也会把max_trx_id+1，因此在一个事务中至少加2；</li>
<li>而InnoDB的后台操作，比如表的索引信息统计这类操作，也是会启动内部事务的，因此你可能看到，trx_id值并不是按照加1递增的。</li>
</ol>
<p>那么，<strong>T2时刻查到的这个很大的数字是怎么来的呢？</strong></p>
<p>其实，这个数字是每次查询的时候由系统临时计算出来的。它的算法是：把当前事务的trx变量的指针地址转成整数，再加上2^48。使用这个算法，就可以保证以下两点：</p>
<ol type="1">
<li>因为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在innodb_trx还是在innodb_locks表里，同一个只读事务查出来的trx_id就会是一样的。</li>
<li>如果有并行的多个只读事务，每个事务的trx变量的指针地址肯定不同。这样，不同的并发只读事务，查出来的trx_id就是不同的。</li>
</ol>
<p>那么，<strong>为什么还要再加上2^48呢？</strong></p>
<p>在显示值里面加上2^48，目的是保证只读事务显示的trx_id值比较大，正常情况下就会区别于读写事务的id。但是，trx_id跟row_id的逻辑类似，定义长度也是8个字节。因此，在理论上还是可能出现一个读写事务与一个只读事务显示的trx_id相同的情况。不过，这个概率很低，并且也没有什么实质的危害，可以不管它。</p>
<p>另一个问题是，<strong>只读事务不分配trx_id，有什么好处呢？</strong></p>
<ul>
<li>一个好处是，这样做可以减小事务视图里面活跃事务数组的大小。因为正在运行的只读事务，是不影响数据的可见性判断的，所以在创建事务的一致性视图时，InnoDB就只需要拷贝读写事务的trx_id；</li>
<li>另一个好处是，可以减少trx_id的申请次数。在InnoDB里，即使你只是执行一个普通的select语句，在执行过程中，也是要对应一个只读事务的。所以只读事务优化后，普通的查询语句不需要申请trx_id，就大大减少了并发事务申请trx_id时的锁冲突。</li>
</ul>
<p>由于只读事务不分配trx_id，一个自然而然的结果就是trx_id的增加速度变慢了。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>软件=算法+数据结构+文档+数据？</title>
    <url>/2020/08/17/%E8%BD%AF%E4%BB%B6-%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%96%87%E6%A1%A3-%E6%95%B0%E6%8D%AE%EF%BC%9F/</url>
    <content><![CDATA[<p>软件的开始到后来...</p>
<p>开始：</p>
<p>软件=代码？</p>
<p>软件=算法+数据结构？</p>
<p>软件=算法+数据结构+文档？</p>
<p>软件=算法+数据结构+文档+数据？</p>
<p>后来：</p>
<p>软件=算法+数据结构+文档+数据 + 单元测试 + workflow ？</p>
<p>对自己的要求，至少要做到</p>
<p>软件=算法+数据结构+文档。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>郭德纲写给儿子郭麒麟的家书</title>
    <url>/2020/07/23/%E9%83%AD%E5%BE%B7%E7%BA%B2%E5%86%99%E7%BB%99%E5%84%BF%E5%AD%90%E9%83%AD%E9%BA%92%E9%BA%9F%E7%9A%84%E5%AE%B6%E4%B9%A6/</url>
    <content><![CDATA[<h3 id="人生的真谛要用自己一辈子去理解">人生的真谛要用自己一辈子去理解</h3>
<p>甲午年，正月初九。我儿子十八了，正所谓成人长大。学名奇临，取奇妙降临之意。后下海，艺名麒麟，乃仿周大师之遗韵。</p>
<p>人生一世，极不容易。登天难，求人更难。黄连苦，无钱更苦。江湖险，人心更险。春冰薄，人情更薄。过去有句话：既落江湖内，便是薄命人。我本不愿儿从艺，奈何人自有志无法横栏。但有几句话要说清楚。</p>
<p>艺人分几类，相隔种种。一是普通艺人，有一技之长，凭能耐吃饭。一是名演员，知名度高，但不代表艺术高，此类要两说。一是角儿，何为角儿？舞台上的顶梁柱、剧团班社的灵魂。贴出你的名字要保证卖得出票，全团老少指着你吃饭。角儿是有责任的艺人。</p>
<p>郭麒麟刚十八，我不希望儿子大红。人红麻烦多，一大三大，名气大后，开销大压力大是非大。红起来容易，难的是接住自己。年三十吃顿饺子容易，之后呢？得天天吃饺子才行啊，可你有那么多的面和馅儿吗？所以，要多下功夫，并且要保持一个好心态。很多人不成功的原因，主要是太尊重自己了。</p>
<p>一个人刚出道，不狂是没有出息的。但如果一直狂，是肯定没出息的。你眼中的你，和别人眼中的你，不是一回事。无限赞美自己，只是一种胆怯。我一直认为，恐惧到头就是愤怒。发挥无敌想象，给自己描绘了一个童话世界，白衣如雪来去如风。剑影刀光闪过后，你满脸冷酷地立于珠峰顶端，傲视苍生无比英武。此时我要问的是：孩子，你怎么下去？不让古人，是谓有志；不让今人，是谓无良。记住了，小俗便雅，大雅则俗。有人夸你，别信。有人骂你，别听。周围人随意捧骂，不可与之交，因其无志兴也。记住，言语多反复，当防欺诈。忘恩思小过，定会反戈。开口说大义，临大难必变节。逢人称兄弟，即深交也平常。</p>
<p>另外，凡事要慎重。江湖子弟，拿得起来放得下。身边人很重要。一根稻草，扔街上就是垃圾，捆上白菜就是白菜价，捆上大闸蟹就是大闸蟹价。包括脚下的平台，也极重要。同样是一个人，步行一小时能走多远？骑车呢？开车呢？坐飞机呢？平台会决定你的速度，且记且记。</p>
<p>此外，钱财要珍惜，但不可看得太重。财乃天地至公之物，假手于人罢了，雨打残花风卷流云，轮番更转而已。穷转富，富转穷，哪有百世富家翁？至于交友，吃点亏也无妨。人每所谓穷通寿夭为命所系，岂不知造物之报施，全视人之自取。芸芸众生富贵贫寒，不是谁都可以傲视乾坤。其中有命有运，要知因果懂善恶，我儿且记，但行好事，莫问前程。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>钢铁是怎样炼成的</title>
    <url>/2020/08/07/%E9%92%A2%E9%93%81%E6%98%AF%E6%80%8E%E6%A0%B7%E7%82%BC%E6%88%90%E7%9A%84/</url>
    <content><![CDATA[<p>人最宝贵的是生命，生命每人只有一次。</p>
<p>人的一生应该这样度过：当他回忆往事的时候，他不会因为虚度年华而悔恨；也不会因为碌碌无为而羞愧，当他临死的时候，他能够说：我的整个生命和全部精力，都献给了世界上最壮丽的事业——为人类的解放而斗争。</p>
<p>人应当赶紧的充分的生活，因为意外的疾病和悲惨的事故随时都可能结束他的生命。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>银行家算法</title>
    <url>/2020/07/27/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一句话">一句话</h2>
<p>当一个进程申请使用资源的时候，银行家算法通过先<strong>试探</strong>分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</p>
<blockquote>
<p>那么此时会有一个问题，如何判断系统是否处于安全状态？算法流程将用下面一张图来表示。</p>
</blockquote>
<h2 id="一张图">一张图</h2>
<img data-src="/2020/07/27/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%951.png" class>
<ul>
<li><p>首先是银行家算法中的<strong>进程</strong>：</p>
<ul>
<li><p>包含进程Pi的需求资源数量（也是最大需求资源数量，MAX）</p></li>
<li><p>已分配给该进程的资源A（Allocation）</p></li>
<li><p>还需要的资源数量N（Need= M - A）</p></li>
</ul></li>
<li><p>Available为空闲资源数量，即资源池（注意：资源池的剩余资源数量+已分配给所有进程的资源数量=系统中的资源总量）</p></li>
</ul>
<p>假设进程P1申请资源，银行家算法先<strong>试探</strong>的分配给它（当然先要看看当前资源池中的资源数量够不够），若申请的资源数量小于等于Available，然后接着判断分配给P1后剩余的资源，能不能使进程队列的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态（即此时没有一个进程能够完成并释放资源，随时间推移，系统终将处于死锁状态）。</p>
<p>若有进程可执行完毕，则假设回收已分配给它的资源（剩余资源数量增加），把这个进程标记为可完成，并继续判断队列中的其他进程，<strong>若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列</strong>（如{P0, P3, P2, P1}表示将申请后的剩余资源Work先分配给P0 -&gt; 回收（Work+已分配给P0的A0=Work） -&gt; 分配给P3 -&gt; 回收（Work + A3 = Work）-&gt; 分配给P2 -&gt; ...... 满足所有进程）。</p>
<p>如此就可避免系统存在潜在死锁的风险。</p>
<h2 id="来个例子">来个例子</h2>
<p>在银行家算法中，若出现下述资源分配情况：</p>
<img data-src="/2020/07/27/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%952" class>
<blockquote>
<p>注：题中共四种资源，P0的Allocation为（0，0， 3， 2）表示已分配给P0的第一种资源和第二种资源为0个，第三种资源3个，第四种资源2个。</p>
</blockquote>
<ol type="1">
<li><p>该状态是否安全？</p></li>
<li><p>若进程P2提出请求Request（1，2，2，2）后，系统能否将资源分配给它？</p></li>
<li><p>利用安全性算法对上面的状态进行分析（见下表），找到一个安全序列{P0, P3, P4, P1, P2}，故系统是安全的。</p>
<img data-src="/2020/07/27/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%953" class></li>
<li><p>P2发出请求向量Request(1,2,2,2)，系统按银行家算法进行检查:</p>
<ol type="1">
<li><p>Request2(1,2,2,2) &lt;= Need2(2,3,5,6)</p></li>
<li><p>Request2(1,2,2,2) &lt;= Available(1,6,2,2)</p></li>
<li><p>系统先假定可为P2分配资源，并修改Available，Allovation2和Need2向量：</p>
<ol type="1">
<li>Available = （0，4，0，0）</li>
<li>Allocation2 = （2，5，7，6）</li>
<li>Need2 = （1，1，3，4）</li>
</ol>
<p>此时在进行安全检查，发现Available=(0, 4, 0, 0)，不能满足任何一个进程，所以判定系统进入不安全状态，即不能分配给P2相应的Request(1,2,2,2)。</p></li>
</ol></li>
</ol>
<h2 id="简单伪代码">简单伪代码</h2>
<p>P - 进程的集合</p>
<p>Mp - 进程p的最大的请求数目</p>
<p>Cp - 进程p当前被分配的资源</p>
<p>A - 当前可用的资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (P !&#x3D; ∅) &#123;</span><br><span class="line">    found &#x3D; FALSE;</span><br><span class="line">    foreach (p ∈ P) &#123;</span><br><span class="line">            &#x2F;&#x2F; Mp - Cp就是Need</span><br><span class="line">        if (Mp − Cp ≤ A) &#123;</span><br><span class="line">             &#x2F;* p可以获得他所需的资源。假设他得到资源后执行；执行终止，并释放所拥有的资源。*&#x2F;</span><br><span class="line">             A &#x3D; A + Cp ;</span><br><span class="line">             P &#x3D; P − &#123;p&#125;;</span><br><span class="line">             found &#x3D; TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (! found) return FAIL;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙跳荷叶问题</title>
    <url>/2020/08/14/%E9%9D%92%E8%9B%99%E8%B7%B3%E8%8D%B7%E5%8F%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题">问题：</h2>
<p>有一只青蛙，向右跳x步可以到达右边中点，向左边跳n-x步可以到达左边中点，问到达左边中点的概率。</p>
<h2 id="求解方法">求解方法</h2>
<p>我们定义f(x)为到达左边中点的概率。</p>
<p>那么f(0) = 0，因为我们已经到达右边终点，f(n) = 1，因为我们已经到达左边终点。</p>
<p>我们知道，f(x) 接下来有两种走法，f(x-1)和f(x+1)，所以有</p>
<p>f(x) = 0.5 * f(x-1) + 0.5 * f(x+1)</p>
<p>我们由此可得f(x+1) - f(x) = f(x) - f(x-1)。</p>
<p>所以我们知道f(x)构成的序列是一个等差数列。</p>
<p>因为f(0) = 0, f(n) = 1，所以f(1) = 1/n，f(2) = 2/n， f(x) = x/n，f(n-1) = (n-1)/n，f(n) = n/n</p>
<p>所以，综上可得f(x) = x/n。</p>
<p>也就是说，当向右走x步到达右边终点，向左n-x步到达左边终点时，我们最后到达左边终点的概率为x/n</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL读写分离时处理过期读的一些方案</title>
    <url>/2020/08/25/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%97%B6%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>读写分离的主要目标是分摊主库的压力。每个大型架构最终都会实现读写分离。</p>
<p>读写分离的架构有两种。</p>

<p>图1中的结构是客户端（client）主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。</p>
<p>还有一种架构是，在MySQL和客户端之间有一个中间代理层proxy，客户端只连接proxy，由proxy根据请求类型和上下文决定请求的分发路由。</p>
<img data-src="/2020/08/25/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%97%B6%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%A1%88/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%842.jpg" class>
<p>接下来，我们就看一下客户端直连和带proxy的读写分离架构，各有哪些特点。</p>
<ol type="1">
<li><p>客户端直连方案，因为少了一层proxy转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。</p>
<p>你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如ZooKeeper，尽量让业务端只专注于业务逻辑开发。</p></li>
<li><p>带proxy的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由proxy完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy也需要有高可用架构。因此，带proxy架构的整体就相对比较复杂。</p></li>
</ol>
<p>理解了这两种方案的优劣，具体选择哪个方案就取决于数据库团队提供的能力了。但目前看，趋势是往带proxy的架构方向发展的。</p>
<p>但是，不论使用哪种架构，你都会碰到我们今天要讨论的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚事务更新之前的状态。</p>
<p><strong>这种“在从库上会读到系统的一个过期状态”的现象，在这篇文章里，我们暂且称之为“过期读”。</strong></p>
<p>前面我们说过了几种可能导致主备延迟的原因，以及对应的优化策略，但是主从延迟还是不能100%避免的。</p>
<p>不论哪种结构，客户端都希望查询从库的数据结果，跟查主库的数据结果是一样的。</p>
<p>接下来，我们就来讨论怎么处理过期读问题。</p>
<p>这里，我先把文章中涉及到的处理过期读的方案汇总在这里，以帮助你更好的理解和掌握全文的知识脉络。这些方案包括：</p>
<ul>
<li>强制走主库方案；</li>
<li>sleep 方案；</li>
<li>判断主备无延迟方案；</li>
<li>配合 semi-sync 方案；</li>
<li>等主库位点方案；</li>
<li>等 GTID 方案。</li>
</ul>
<h3 id="强制走主库方案">强制走主库方案</h3>
<p>强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两类：</p>
<ol type="1">
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。</li>
<li>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。</li>
</ol>
<p>你可能会说，这个方案是不是有点畏难和取巧的意思，但其实这个方案是用得最多的。</p>
<p>当然，这个方案最大的问题在于，有时候你会碰到”所有查询都不能是过期读“的需求，比如一些金融类的业务。这样的话，你就要放弃读写分离，所有读写压力都在主库，等同于放弃了扩展性。</p>
<p>因此接下来，我们来讨论的话题是：可以支持读写分离的场景下，有哪些解决过期读的方案，并分析各个方案的优缺点。</p>
<h3 id="sleep方案">Sleep方案</h3>
<p>主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。</p>
<p>这个方案的假设是，大多数情况下主备延迟在1s之内，做一个sleep可以有很大概率拿到最新的数据。</p>
<p>这个方案给你的第一感觉，很可能是不靠谱，应该不会有人用吧？并且，你可能还会说，直接在发起查询时限制性一条sleep语句，用户体验很不友好啊。</p>
<p>但，这个思路确实可以在一定程度上解决问题。为了看起来更靠谱，我们可以换一种方式。</p>
<p>以卖家发布商品为例，商品发布后，用Ajax(Asynchronous JavaScript + XML，异步JavaScript和XML）直接把客户端输入的内容作为”新的商品“显示在页面上，而不是真正地去数据库做查询。</p>
<p>这样，卖家就可以通过这个显示，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商品的时候，其实已经过了一段时间了，也就达到了sleep的目的，进而也就解决了过期读的问题。</p>
<p>也就是说，这个sleep方案确实解决了类似场景下的过期读问题。但，从严格意义上来说，这个方案存在的问题就是不精确。这个不精确包含了两层意思：</p>
<ol type="1">
<li>如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒；</li>
<li>如果延迟超过1s，还是会出现过期读。</li>
</ol>
<h3 id="判断主库无延迟方案">判断主库无延迟方案</h3>
<p>要确保备库无延迟，通常有三种做法。</p>
<p>通过前面的文章，我们知道show slave status结果里的seconds_behind_master参数的值，可以用来衡量主备延迟时间的长短。</p>
<p>所以<strong>第一种确保主备无延迟的方法是</strong>，每次从库执行查询请求前，先判断seconds_behind_master是否已经等于0。如果还不等于0，那就必须等到这个参数变为0才能执行查询请求。</p>
<p>seconds_behind_master的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和GTID的方法来确保主备无延迟，也就是我们接下来要说的第二和第三种方法。</p>
<p>如图3所示，是一个show slave status结果的部分截图。</p>
<img data-src="/2020/08/25/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%97%B6%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%A1%88/%E8%BF%87%E6%9C%9F%E8%AF%BB1.png" class>
<p>现在，我们就通过这个结果，来看看具体如何通过对比位点和GTID来确保主备无延迟。</p>
<p><strong>第二种方法</strong>，对比位点确保主备无延迟：</p>
<ul>
<li>Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li>
<li>Relay_Master_Log_FIle和Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li>
</ul>
<p>如果Master_Log_File和Relay_MAster_Log_File、Read_master_Log_Pos和Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。</p>
<p><strong>第三种方法</strong>，对比GTID集合确保主备无延迟：</p>
<ul>
<li>Auto_Position=1，表示这对主备关系使用了GTID协议；</li>
<li>Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合；</li>
<li>Executed_Gtid_Set，是备库所有已经执行完成的GTID集合。</li>
</ul>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p>
<p>可见，对比位点和对比GTID这两种方法，都要比对比seconds_behind_master是否为0更准确。</p>
<p>在执行查询请求之前，先判断从库是否同步完成的方法，相比于sleep方案，准确度确实提升了不少，但还是没有达到”精确“的程度。为什么这么说呢？</p>
<p>我们现在一起回顾一下，一个事务的binlog在主备库之间的状态：</p>
<ol type="1">
<li>主库执行完成，写入binlog，并反馈给客户端；</li>
<li>binlog被从主库发送给备库，备库收到；</li>
<li>在备库执行binlog完成。</li>
</ol>
<p>我们上面判断主备无延迟的逻辑，是”备库收到的日志都执行完成了“。但是，从binlog在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。</p>
<p>如图4所示就是这样的一个状态。</p>
<img data-src="/2020/08/25/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%97%B6%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%A1%88/%E8%BF%87%E6%9C%9F%E8%AF%BB2.png" class>
<p>这是，主库上执行完成了三个事务trx1，trx2和trx3，其中：</p>
<ol type="1">
<li>trx1和trx2已经传到从库，并且已经执行完成了；</li>
<li>trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。</li>
</ol>
<p>如果这时候你在从库B上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但还是查不到trx3的。严格地说，就是出现了过期读。</p>
<p>那么，这个问题有没有办法解决呢？</p>
<h3 id="配合semi-sync">配合semi-sync</h3>
<p>要解决这个问题，就要引入半同步机制，也就是semi-sync replication。</p>
<p>semi-sync做了这样的设计：</p>
<ol type="1">
<li>事务提交的时候，主库把binlog发给从库；</li>
<li>从库收到binlog以后，发回给主库一个ack，表示收到了；</li>
<li>从库收到这个ack以后，才能给客户端返回”事务完成“的确认。</li>
</ol>
<p>也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了日志。</p>
<p>在前面文章的评论区，有同学问道：如果主库掉电的时候，有些binlog还来不及发给从库，会不会导致系统数据丢失？</p>
<p>答案是，如果使用的是普通的异步复制机制，就有可能丢失，但semi-sync就可以解决这个问题。</p>
<p>这样，semi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。</p>
<p>但是，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的ack，就开始给客户端返回确认。这是，在从库上执行查询请求，就有两种情况：</p>
<ol type="1">
<li>如果查询是落在这个响应了ack的从库上，是能够确保读到最新数据；</li>
<li>但如果是查询落到了其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</li>
</ol>
<p>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p>
<p>实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到”主备完全同步“。</p>
<p>为什么这么说呢？我们来看一下这个时序图。</p>
<img data-src="/2020/08/25/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%97%B6%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%A1%88/%E8%BF%87%E6%9C%9F%E8%AF%BB3.png" class>
<p>图5所示，就是等待位点方案的一个bad case。图中备库B下的虚线框，分别表示relaylog和binlog中的事务。可以看到，图5中从状态1到状态4，一直处于延迟一个事务的状态。</p>
<p>备库B一直到状态4都和主库A存在延迟，如果用上面必须等到无延迟才能查询的方案，select语句一直到状态4都不能被执行。</p>
<p>但是，其实客户端是在发完trx1更新后发起的select语句，我们只需要确保trx1已经执行完成就可以执行select语句了。也就是说，如果在状态3执行查询请求，得到的就是预期结果了。</p>
<p>到这里，我们小结一下，semi-sync配合判断主备无延迟的方案，存在两个问题：</p>
<ol type="1">
<li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</li>
<li>在持续延迟的情况下，可能出现过度等待的问题。</li>
</ol>
<p>接下来，我要和你介绍的等主库位点方案，就可以解决这两个问题。</p>
<h3 id="等主库位点方案">等主库位点方案</h3>
<p>要理解等主库位点方案，我需要先和你介绍一条命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">master_pos_wait</span>(<span class="keyword">file</span>, pos[, <span class="keyword">timeout</span>]);</span><br></pre></td></tr></table></figure>
<p>这条命令的逻辑如下：</p>
<ol type="1">
<li>它是在从库执行的；</li>
<li>参数file和pos指的是主库上的文件名和位置；</li>
<li>timeout可选，设置为正整数N表示这个函数最多等待N秒。</li>
</ol>
<p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p>
<p>当然，除了正常返回一个正整数M外，这条命令还会返回一些其他结果，包括：</p>
<ol type="1">
<li>如果执行期间，备库同步线程发生异常，则返回NULL；</li>
<li>如果等待时间超过N秒，就返回-1；</li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。</li>
</ol>
<p>对于图5中先执行trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：</p>
<ol type="1">
<li>trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行select master_pos_wait(FIle, Position, 1);</li>
<li>如果返回值是&gt;=0的正整数，则在这个从库执行查询语句。</li>
<li>否则，到主库执行查询语句。</li>
</ol>
<p>上面的流程画出来。</p>
<img data-src="/2020/08/25/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%97%B6%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%A1%88/%E8%BF%87%E6%9C%9F%E8%AF%BB4.png" class>
<p>这里我们假设，这条select查询最多在从库上等待1秒。那么，如果1秒内master_pos_wait返回一个大于等于0的整数，就确保了从库上执行的这个查询结果一定包含了trx1的数据。</p>
<p>步骤5到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。</p>
<p>你可能会说，如果所有的从库都延迟超过1秒了，那查询压力不就都跑到主库上了吗？确实是这样。</p>
<p>但是，按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询，具体怎么选择，就需要业务开发同学做好限流策略了。</p>
<h3 id="gtid方案">GTID方案</h3>
<p>如果你的数据库开启了GTID模式，对应的也有等待GTID的方案。</p>
<p>MySQL中同样提供了一个类似的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> wait_for_executed_gtid_set(gtid_set, <span class="number">1</span>); </span><br></pre></td></tr></table></figure>
<p>这条命令的逻辑是：</p>
<ol type="1">
<li>等待，直到这个库执行的事务中包含传入的gtid_set，返回0；</li>
<li>超时返回1.</li>
</ol>
<p>在前面等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。而MySQL 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询。</p>
<p>这时，等GTID的执行流程就变成了：</p>
<ol type="1">
<li>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行select wait_for_executed_gtid_set(gtid1, 1);</li>
<li>如果返回值是0，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ol>
<p>跟等主库位点的方案一样，等待超时后时候直接到主库查询，需要业务开发同学来做限流考虑。</p>
<p>我把这个流程图画出来。</p>
<img data-src="/2020/08/25/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%97%B6%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%A1%88/%E8%BF%87%E6%9C%9F%E8%AF%BB5.png" class>
<p>在上面的第一步中，trx1事务更新完成后，从返回包直接获取这个事务的GTID。问题是，怎么能够让MySQL在执行事务后，返回包中带上GTID呢？</p>
<p>你只需要将参数session_track_gtids设置为OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值即可。</p>
<p>在专栏的第一篇文章中，我介绍mysql_reset_connection的时候，有同学留言问这类接口应该怎么使用。</p>
<p>这里我再回答一下。其实，MySQL并没有提供这类接口的SQL用法，是提供给程序的API。</p>
<p>比如，为了让客户端在事务提交后，返回的GTID能够在客户端显示出来，我对MySQL客户端代码做了点修改，如下所示：</p>
<img data-src="/2020/08/25/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%97%B6%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%A1%88/%E8%BF%87%E6%9C%9F%E8%AF%BB6.png" class>
<p>这样，就可以看到语句执行完成，显示出GTID的值。</p>
<img data-src="/2020/08/25/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%97%B6%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%A1%88/%E8%BF%87%E6%9C%9F%E8%AF%BB7.png" class>
<p>当然了，这只是一个例子。你要是用这个方案的时候，还是应该在你的客户端代码中调用mysql_session_track_get_first这个函数。</p>
<h3 id="小结">小结</h3>
<p>在今天这篇文章中，我跟你介绍了一主多从做读写分离时，可能碰到过期读的原因，以及几种应对的方案。</p>
<p>这几种方案中，有的方案看上去是做了妥协，有的方案看上去不那么靠谱儿，但都是有实际应用场景的，你需要根据业务需求选择。</p>
<p>即使是最后等待位点和等待 GTID 这两个方案，虽然看上去比较靠谱儿，但仍然存在需要权衡的情况。如果所有的从库都延迟，那么请求就会全部落到主库上，这时候会不会由于压力突然增大，把主库打挂了呢？</p>
<p>其实，在实际应用中，这几个方案是可以混合使用的。</p>
<p>比如，先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等 GTID 或等位点的方案。</p>
<p>但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。</p>
<h3 id="转载">转载</h3>
<p>感谢丁奇老师的<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83NzYzNg==">专栏<i class="fa fa-external-link-alt"></i></span>，如转载参考有不妥，请通知我立即删除。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>到底可不可以使用join</title>
    <url>/2020/08/29/%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8join/</url>
    <content><![CDATA[<p>问题：</p>
<ol type="1">
<li>能不能使用join？</li>
<li>两个大小不同的表，应该用哪个表做驱动表？</li>
</ol>
<p>为了便于量化分析，我建两个表t1和t2来和你说明。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata;</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=1000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> <span class="keyword">id</span>&lt;=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，这两个表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2里插入了1000行数据，在表t1里插入的是100行数据。</p>
<h3 id="index-nested-loop-join">Index Nested-Loop Join</h3>
<p>我们来看一下这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a=t2.a);</span><br></pre></td></tr></table></figure>
<p>如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响我们分析SQL语句的执行过程。所以，为了便于分析执行过程中的性能问题，我改用strainght_join让MySQL使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去join。在这个语句里，t1是驱动表，t2是被驱动表。</p>
<p>现在，我们来看一下这条语句的explain结果。</p>

<p>可以看到，在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：</p>
<ol type="1">
<li>从表t1中读入一行数据R；</li>
<li>从数据行R中，取出a字段到表t2里查找；</li>
<li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</li>
<li>重复执行步骤1到3，直到表t1的末尾循环结束。</li>
</ol>
<p>这个过程是先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为"Index Nested-Loop Join"，简称NLJ。</p>
<p>它对应的流程图如下所示：</p>

<p>在这个流程里：</p>
<ol type="1">
<li>对驱动表t1做了全表扫描，这个过程需要扫描100行；</li>
<li>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次搜索过程都只扫描一行，也是总共扫描100行；</li>
<li>所以，整个执行流程，总扫描行数是200。</li>
</ol>
<p>现在我们知道了这个过程，再试着回答一下文章开头的两个问题。</p>
<p>先看第一个问题，<strong>能不能使用join？</strong></p>
<p>假设不使用join，那我们就只能单表查询，我们看看上面这条语句的需求，用单表查询怎么实现。</p>
<ol type="1">
<li>执行select * from t1，查出表t1的所有数据，这里有100行；</li>
<li>循环遍历这100行数据：
<ul>
<li>从每一行R取出字段a的值$R.a；</li>
<li>执行select * from t2 where a=$R.a；</li>
<li>把返回的结果和R构成结果集的一行。</li>
</ul></li>
</ol>
<p>可以看到，在这个查询过程，也是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互。除此之外，客户端还要自己拼接SQL语句和结果。</p>
<p>显然，这么做还不如直接join好。</p>
<p>我们再来看看第二个问题：<strong>怎么选择驱动表</strong>？</p>
<p>在这个join语句执行过程中，驱动表是走全表扫描，而被驱动表是走数搜索。</p>
<p>假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，所以在被驱动表上查一行的时间复杂度是2*log2M。</p>
<p>假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。</p>
<p>因此整个执行过程，近似复杂度是N+N<em>2</em>log2M。</p>
<p>显然，N对扫描行数的影响更大，因此应该让小表来做驱动表。</p>
<p>到这里小结一下，通过上面的分析我们得到了两个结论：</p>
<ol type="1">
<li>使用join语句，性能比强拆成多个单表执行SQL语句的性能要好；</li>
<li>如果使用join语句的话，需要让小表做驱动表。</li>
</ol>
<p>但是，你需要注意，这个结论的前提是“可以使用被驱动表的索引”。</p>
<p>接下来，我们再看看被驱动表用不上索引的情况。</p>
<h3 id="simple-nested-loop-join">Simple Nested-Loop Join</h3>
<p>现在，我们把SQL语句改成这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a=t2.b);</span><br></pre></td></tr></table></figure>
<p>由于表t2的字段b上没有索引，因此再用图2的执行流程时，每次到t2去匹配的时候，就要做一次全表扫描。</p>
<p>你可以设想一下这个问题，继续使用图2的算法，是不是可以得到正确的结果呢？如果只看结果的话，这个算法是正确的，而且这个算法也有一个名字，叫做“Simple Nested-Loop Join”。</p>
<p>但是，这样算来，这个SQL请求就要扫描表t2多达100次，总共扫描100*1000=10万行。</p>
<p>这还只是两个小表，如果t1和t2都是10万行的表（当然了，这也还是属于小表的范围，在现在的硬件条件下，1千万行一下的表都可以认为是小表），就要扫描100亿行，这个算法看上去太“笨重”了。</p>
<p>当然，MySQL也没有使用这个Simple Nested-Loop Join算法，而是使用了另一个叫做“Block Nested-Loop Join"的算法，简称BNL。</p>
<h3 id="block-nested-loop-join">Block Nested-Loop Join</h3>
<p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p>
<ol type="1">
<li>把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；</li>
<li>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据作对比，满足join条件的，作为结果集的一部分返回。</li>
</ol>
<p>这个过程的流程图如下：</p>

<p>对应地，这条SQL语句的explain结果如下所示：</p>

<p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做得判断次数是：100*1000=10万次。</p>
<p>前面我们说过，如果使用Simple Nested-Loop Join算法进行查询，扫描行数也是10万行。因此，从时间复杂度上来说，这两个算法是一样的。<strong>但是，Block Nested-Loop 算法的这10万次判断是内存操作，速度上会快很多，性能也更好。</strong>（原因在这里，我们把小表的数据放到了内存中。而对于Simple Nested-Loop Join算法，是对表t2做了全表扫面，每次拿出一个数据页到内存中，再做判断，这样增加了磁盘IO次数，就比较慢）</p>
<p>接下来，我们来看一下，在这种情况下，应该选择哪个表做驱动表。</p>
<p>假设小表的行数是N，大表的行数是M，那么在这个算法里：</p>
<ol type="1">
<li>两个表都做一次全表扫描，所以总的扫描行数是M+N；</li>
<li>内存中判断的次数时M*N。</li>
</ol>
<p>可以看到，调换这两个算式中M和N没差别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。</p>
<p>然后，你可能马上就会问了，这个例子里表t1才100行，要是t1是一个大表，join_buffer放不下怎么办呢？</p>
<p>join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。<strong>如果放不下表t1的所有数据的话，策略很简单，就是分段放。</strong>我把join_buffer_size改成1200，再执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a=t2.b);</span><br></pre></td></tr></table></figure>
<p>执行过程就变成了：</p>
<ol type="1">
<li>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步；</li>
<li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据作对比，满足join条件的，作为结果集的一部分返回；</li>
<li>清空join_buffer;</li>
<li>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。</li>
</ol>
<p>执行流程图也就变成这样：</p>

<p>图中的步骤4和5，表示清空join_buffer再复用。</p>
<p>这个流程才体现出了这个算法名字中"Block"的由来，表示“分块去join"。</p>
<p>可以看到，这时候由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次。虽然分成两次放入join_buffer，但是判断等之条件的次数还是不变的，依然是(88+12)*1000=10万次。</p>
<p>我们再来看下，在这种情况下驱动表的选择问题。</p>
<p>假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。</p>
<p>注意，这里的K不是常数，N越大K就会越大，因此把K表示为λ*N，显然λ的取值范围是（0， 1）。</p>
<p>所以，在这个算法的执行过程中：</p>
<ol type="1">
<li>扫描行数是N+λ*N*M；</li>
<li>内存判断N*M次。</li>
</ol>
<p>显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小。</p>
<p>所以结论是，应该让小表当驱动表。</p>
<p>当然，你会发现，在N+λ*N*M这个式子里，λ才是影响扫描行数的关键因素，这个值越小越好。</p>
<p>刚刚我们说了N越大，分段数K越大。那么，N固定的时候，什么参数会影响K的大小呢？（也就是λ的大小）Join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。</p>
<p>这就是为什么，你可能看到一些建议说，如果你的join语句很慢，就把join_buffer_size改大。</p>
<p>理解了MySQL执行join的两种算法，现在我们再来试着回答文章开头的两个问题。</p>
<p>第一个问题：能不能使用join'语句？</p>
<ol type="1">
<li>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li>
<li>如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</li>
</ol>
<p>所以你在判断要不要使用join语句时，就是看explain结果里面，Extra字段里面有没有出现“Block Nested Loop"字样。</p>
<p>第二个问题：如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？</p>
<ol type="1">
<li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</li>
<li>如果是Block Nested-Loop Join算法：
<ul>
<li>在join_buffer_size足够大的时候，是一样的；</li>
<li>在join_buffer_size不够大的时候（这种情况才是更为常见的），应该选择小表做驱动表。</li>
</ul></li>
</ol>
<p>所以，这个问题的结论就是，总是应该选择小表做驱动表。</p>
<p>当然，这里我需要说明下，<strong>什么叫做"小表"？</strong></p>
<p>我们前面的例子是没有加条件的。如果我在语句的where条件加上t2.id&lt;=50这个限定条件，再来看下这两条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">straight_join</span> t1 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">50</span>;</span><br></pre></td></tr></table></figure>
<p>注意，为了让两条语句的被驱动表都用不上索引，所以join字段都使用了没有索引的字段b。</p>
<p>但如果是用第二个语句的话，join_buffer只需要放入t2的前50行，显然是更好的。所以这里，"t2的前50行"是那个相对小的表，也就是"小表"。</p>
<p>我们再来看另外一组例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.b,t2.* <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">select</span> t1.b,t2.* <span class="keyword">from</span> t2 <span class="keyword">straight_join</span> t1 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.id&lt;=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>这个例子里，表t1和t2都是只有100行参加join。但是，这两条语句每次查询放入join_buffer中的数据是不一样的：</p>
<ol type="1">
<li>表t1只查字段b，因此如果把t1放到join_buffer中，则join_buffer中只需要放入b的值；</li>
<li>表t2需要查所有的字段，因此如果把表t2放到join_buffer中的话，就需要放入三个字段为id、a、b。</li>
</ol>
<p>这里，我们应该选择表t1作为驱动表。也就是说在这个例子里，"只需要一列参与join的表t1"是那个相对小的表。</p>
<p>所以，更准确的说，<strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个子弹的总数据量，数据量小的那个表，就是"小表"，应该作为驱动表。</strong></p>
<h3 id="小结">小结</h3>
<p>今天，我和你介绍了MySQL执行join语句的两种可能算法，这两种算法，是由能否使用被驱动表的索引决定的。而能否用上被驱动表的索引，对join语句的性能影响很大。</p>
<p>通过对Index Nested-Loop Join和Block Nested-Loop Join两个算法执行过程的分析，我们也得到了文章开头两个问题的答案：</p>
<ol type="1">
<li>如果可以使用被驱动表的索引，join语句还是有其优势的；</li>
<li>不能使用被驱动表的索引，只能使用Block Nested-Loop Join算法，这样的语句尽量不要使用；</li>
<li>在使用join的时候，应该让小表做驱动表。</li>
</ol>
<p>最后，又到了今天的问题时间。</p>
<p>我们在上文中说到，使用Block Nested-Loop Join算法，可能会因为join_buffer不够大，需要对被驱动表做多次全表扫描。</p>
<p>我的问题是，如果被驱动表是一个大表，并且是一个冷数据表，除了查询过程中农可能会导致IO压力大以外，你觉得对这个MySQL服务还有什么更严重的影响吗？（这个问题需要结合上一篇<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83OTQwNw==">文章<i class="fa fa-external-link-alt"></i></span>的知识点）</p>
<p>解答：</p>
<p>我在上一篇文章末尾，给你留下的思考题是，使用 Block Nested-Loop Join(BNL) 算法时，可能会对被驱动表做多次扫描。如果这个被驱动表是一个大的冷数据表，除了会导致 IO 压力大以外，还会对系统有什么影响呢？</p>
<p>在<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83OTQwNw==">33篇文章<i class="fa fa-external-link-alt"></i></span>中，我们说到InnoDB的LRU算法的时候提到，由于InnoDB对Buffer Pool的LRU算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在old区域（很像jvm GC分成了Young和Old，但是相反）。如果1秒之后这个数据页不再被访问了，就不会被移动到LRU链表头部，这样对Buffer Pool的命中率影响就不大。</p>
<p>但是，如果一个使用BNL算法的join语句，多次扫描一个冷表，而且这个语句执行时间超过1秒，就会在再次扫描冷表的时候，把冷表的数据页移到LRU链表的头部。</p>
<p>这种情况对应的，是冷表的数据量小于整个Buffer Pool的3/8，能够完全放入old区域的情况。</p>
<p>如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入young区域。</p>
<p>由于优化机制的存在，一个正常访问的数据页，要进入young区域，需要隔1秒后再次被访问到。但是，由于我们的join语句在循环读磁盘和淘汰内存页，进入old区域的数据页，很可能在1秒之内就被淘汰了。这样，就会导致这个MySQL实例的Buffer Pool在这段时间内，young区域的数据页没有被合理地淘汰。</p>
<p>也就是说，这两种情况都会影响Buffer Pool的正常运作。</p>
<p><strong>大表join操作虽然对IO有影响，但是在语句执行结束后，对IO的影响也就结束了。但是，对Buffer Pool的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</strong></p>
<p>为了减少这种影响，你可以考虑增大join_buffer_size的值，减少对被驱动表的扫描次数。</p>
<p>也就是说，BNL算法对系统的影响主要包括三个方面：</p>
<ol type="1">
<li>可能会多次扫描被驱动表，占用磁盘IO资源；</li>
<li>判断join条件需要执行M*N次对比（M、N分别是两张表的行数），如果是大表就会占用非常多的CPU资源；</li>
<li>可能会导致Buffer Pool的热数据被淘汰，影响内存命中率。</li>
</ol>
<p>我们执行语句之前，需要通过理论分析和查看explain结果的方式，确认是否要使用BNL算法。如果确认优化器会使用BNL算法，就需要做优化。优化的常见做法是，给被驱动表的join字段加上索引，把BNL算法转成BKA算法。</p>
<p>关于BKA算法的详细内容，请看下一篇<span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS84MDE0Nw==">文章35<i class="fa fa-external-link-alt"></i></span>。</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>搞定计算机网络面试</title>
    <url>/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="一-osi与tcpip各层的结构与功能都有哪些协议">一 OSI与TCP/IP各层的结构与功能，都有哪些协议</h2>
<h3 id="五层协议的体系结构">五层协议的体系结构</h3>
<p>学习计算机网络时我们一般采取折中的办法，也就是中和OSI和TCP/IP的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1" class>
<p>结合互联网的情况，自上而下的，非常简要的介绍一下各层的作用。</p>
<h4 id="应用层">1 应用层</h4>
<p><strong>应用层（application layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS</strong>，支持万维网应用的<strong>HTTP协议</strong>，支持电子邮件的<strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>
<h5 id="域名系统">域名系统</h5>
<p>域名系统（Domain name System缩写DNS，Domain Name被译为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。例如：一个公司的web网站可看做是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <span class="exturl" data-url="aHR0cDovL3d3dy5pYm0uY29tLw==">www.ibm.com<i class="fa fa-external-link-alt"></i></span>、Oracle 公司的域名是 <span class="exturl" data-url="aHR0cDovL3d3dy5vcmFjbGUuY29tLw==">www.oracle.com<i class="fa fa-external-link-alt"></i></span>、Cisco公司的域名是 <span class="exturl" data-url="aHR0cDovL3d3dy5jaXNjby5jb20v">www.cisco.com<i class="fa fa-external-link-alt"></i></span> 等。</p>
<h5 id="http协议">HTTP协议</h5>
<p>超文本传输协议（HTTP，Hypertext Transfer Protocol）是互联网上应用最广泛的一种网络协议。所有的WWW（万维网）文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>
<h4 id="运输层">2 运输层</h4>
<p><strong>运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。</strong>应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p><strong>运输层主要使用一下两种协议</strong></p>
<ol type="1">
<li><strong>传输控制协议TCP</strong>（Transmisson Control Protocol）--提供<strong>面向连接的，可靠的</strong>数据传输服务。</li>
<li>用户数据报协议UDP（User Datagram Protocol）--提供<strong>无连接的</strong>，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）</li>
</ol>
<p>UDP的主要特点</p>
<ol type="1">
<li>UDP是无连接的。</li>
<li>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态（这里面有许多参数）；</li>
<li>UDP是面向报文的；</li>
<li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如直播，实时视频会议等）；</li>
<li>UDP支持一对一、一对多、多对一和多对多的交互通信；</li>
<li>UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li>
</ol>
<p>TCP的主要特点</p>
<ol type="1">
<li>TCP是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li>
<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li>
<li>TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li>
<li>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>
<li>面向字节流。TCP中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>
</ol>
<h4 id="网络层">3 网络层</h4>
<p><strong>网络层（network layer）负责为分组交换网上的不同主机提供服务</strong>。在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用<strong>IP协议</strong>，因此分组也叫<strong>IP数据报</strong>，简称<strong>数据报</strong>。</p>
<p>这里要注意：<strong>不要把运输层的“用户数据报UDP”和网络层的“IP数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
<p>网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p>
<h4 id="数据链路层">4 数据链路层</h4>
<p><strong>数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong>在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的IP数据报组装成帧，</strong>在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单的丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现的差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h4 id="物理层">5 物理层</h4>
<p>在物理层所传送的数据单位是比特。<strong>物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong>使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p>在互联网使用的各种协议中最重要和最著名的就是TCP/IP两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的的整个TCP/IP协议簇。</p>
<h4 id="总结一下">总结一下</h4>
<p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。</p>
<p>图片来源：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3BlbmdfMjAwNS9hcnRpY2xlL2RldGFpbHMvNzA2NDg2OQ==">blog.csdn.net/yaopeng_200…<i class="fa fa-external-link-alt"></i></span></p>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.gif" class>
<h2 id="二-tcp三次握手和四次挥手面试常客">二 TCP三次握手和四次挥手（面试常客）</h2>
<p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<h3 id="漫画图解">漫画图解：</h3>
<p>图片来源：《图解HTTP》</p>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3" class>
<h3 id="简单示意图">简单示意图：</h3>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4" class>
<ul>
<li>客户端-发送带有SYN标志的数据-一次握手-服务端</li>
<li>服务端-发送带有SYN/ACK标志的数据包-二次握手-客户端</li>
<li>客户端-发送带有ACK标志的数据包-三次握手-服务端</li>
</ul>
<h3 id="为什么要三次握手">为什么要三次握手</h3>
<p><strong>三次握手的目的是建立可靠的通信通道，说道通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client什么都不能确认；Server确认了对方发送正常</p>
<p>第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己接收正常，对方发送正常</p>
<p>第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双方收发功能都正常，缺一不可。</p>
<h3 id="为什么要传回syn">为什么要传回SYN</h3>
<p>接收端传回发送端所发送的SYN是为了告诉发送端，我接收到的信息确实就是你发送的信号。</p>
<h3 id="传了syn为啥还要传ack">传了SYN，为啥还要传ACK</h3>
<p>双方通信无误必须是两者互相发送信息都无误。传了SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道（即Server发送正常，Client接收正常）还需要ACK信号来进行验证。</p>
<blockquote>
<p>SYN是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN-ACK应答表示接收到了这个消息，最后客户机再以ACK（Acknowledge，确认字符，在数据通信传输中，接收站发送给发送站的一种传输控制字符。它表示确认发来的数据已经接收无误。）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C5" class>
<p>断开一个TCP连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个FIN，它返回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h3 id="为什么要四次挥手">为什么要四次挥手</h3>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>举个例子：A和B打电话，通话即将结束后，A说“我没啥要说的了”，B回答说“我知道了”，但是B可能还有要说的话，A不能要求B跟着自己的节奏结束通话，于是B可能又巴拉巴拉说了一通，最后B说”我说完了“，A回答”知道了“，这样通话才算结束。</p>
<p>上面讲的比较概括，推荐一篇讲得比较细致的文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F6Y3N1L2FydGljbGUvZGV0YWlscy83Mjg2MTg5MQ==">blog.csdn.net/qzcsu/artic…<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="三-tcpudp协议的区别">三 TCP、UDP协议的区别</h2>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C6" class>
<p>UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文之后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式（一般用于即时通讯），比如：QQ语音、QQ视频、直播等等。</p>
<p>TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这些难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h2 id="四-tcp协议如何保证可靠运输">四 TCP协议如何保证可靠运输</h2>
<ol type="1">
<li>应用数据被分割成TCP认为最合适发送的数据块。</li>
<li>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和</strong>：TCP将保持它首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化，如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP的接收端会丢弃重复的数据。</li>
<li><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是一个可变大小的滑动窗口协议。（TCP利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。</li>
<li><strong>停止等待协议</strong>：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。<strong>超时重传</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h3 id="停止等待协议">停止等待协议</h3>
<ul>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>
</ul>
<ol type="1">
<li><strong>无差错情况：</strong></li>
</ol>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C7" class>
<p>发送方发送分组，接收方在规定时间内收到，并且回复确认，发送方再次发送。</p>
<ol start="2" type="1">
<li><strong>出现差错情况（超时重传）</strong>：</li>
</ol>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C8" class>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为<strong>自动重传请求 ARQ</strong>。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续ARQ协议</strong>可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明这个分组位置的所有分组都已经正确收到了。</p>
<ol start="3" type="1">
<li><p><strong>确认丢失和确认迟到</strong></p>
<ul>
<li><p><strong>确认丢失</strong>：确认消息在传输过程丢失</p>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C9" class>
<p>当A发送M1消息时，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：</p>
<ol type="1">
<li>丢弃这个重复的M1消息，不向上层交付。</li>
<li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
</ol></li>
<li><p><strong>确认迟到</strong>：确认消息在传输过程中迟到</p>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C10" class>
<p>A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到额2份确认消息）。处理如下：</p>
<ol type="1">
<li>A收到重复的确认后，直接丢弃。</li>
<li>B收到重复的M1后，也直接丢弃重复的M1。</li>
</ol></li>
</ul></li>
</ol>
<h3 id="自动重传请求arq协议">自动重传请求ARQ协议</h3>
<p>停止等待协议中超时重传是指只要过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此没发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。</p>
<p><strong>优点</strong>：简单</p>
<p><strong>缺点</strong>：信道利用率低</p>
<h3 id="连续arq协议">连续ARQ协议</h3>
<p>连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认，接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点</strong>：信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点</strong>：不能向发送方反映出接收方已经正确收到的所有分组的信息。比如：发送方发送了5条消息，中间第三条丢失（3号），这是接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫Go-Back-N（回退N），表示需要退回来重传已经发送过的N个消息。</p>
<h3 id="滑动窗口">滑动窗口</h3>
<ul>
<li>TCP利用滑动窗口实现流控的机制。</li>
<li>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞情况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</li>
<li>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</li>
</ul>
<h3 id="流量控制">流量控制</h3>
<ul>
<li>TCP 利用滑动窗口实现流量控制。</li>
<li>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</li>
<li>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</li>
</ul>
<h3 id="拥塞控制">拥塞控制</h3>
<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的负荷情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
</ul>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C11" class>
<ul>
<li><p><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1.</p></li>
<li><p><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。  当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p></li>
</ul>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C12" class>
<h2 id="五-在浏览器中输入url地址---显示主页的过程面试常客">五 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程（面试常客）</h2>
<p>百度好像最喜欢问这个问题。</p>
<blockquote>
<p>打开一个网页，整个过程会使用哪些协议</p>
</blockquote>
<p>图片来源：《图解HTTP》</p>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C13" class>
<h2 id="六-状态码">六 状态码</h2>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C14" class>
<h2 id="七-各种协议与http协议之间的关系">七 各种协议与HTTP协议之间的关系</h2>
<p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>
<p>图片来源：《图解HTTP》</p>
<img data-src="/2020/07/23/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C15" class>
<h2 id="八-http长连接短连接">八 HTTP长连接、短连接</h2>
<p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源时（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Connection:keep-alive</span></span><br></pre></td></tr></table></figure>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p>
<p>—— <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ290b2RzcC9wLzYzNjYxNjMuaHRtbA==">《HTTP长连接、短连接究竟是什么？》<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="转载感谢原作者">转载（感谢原作者）：</h2>
<p>https://juejin.im/post/5b7be0b2e51d4538db34a51e#heading-17</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2020/07/30/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h2 id="参考">参考：</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv57ea5q615qi5">https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5%E6%A8%B9<i class="fa fa-external-link-alt"></i></span></p>
<p>https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/</p>
<p>原文我觉得挺不错的，暂时觉得先不翻译。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc0NjYyMTgvd2hhdC1hcmUtdGhlLWRpZmZlcmVuY2VzLWJldHdlZW4tc2VnbWVudC10cmVlcy1pbnRlcnZhbC10cmVlcy1iaW5hcnktaW5kZXhlZC10Izp+OnRleHQ9U2VnbWVudCUyMHRyZWUlMjBzdG9yZXMlMjBpbnRlcnZhbHMlMkMlMjBhbmQsd2l0aCUyMGElMjBnaXZlbiUyMGludGVydmFsJTIyJTIwcXVlcmllcy4=">链接<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="实际问题简单记想快速知道数组的某一区间和同时数组的修改频繁使得这两种操作都变成ologn用线段树可利用思想解决最大子段和问题">实际问题（简单记，想快速知道数组的某一区间和，同时数组的修改频繁，使得这两种操作都变成O(logn)，用线段树，可利用思想解决最大子段和问题）</h2>
<p>Let us consider the following problem to understand Segment Trees.</p>
<p>We have an array arr[0 . . . n-1]. We should be able to <strong>1</strong> Find the sum of elements from index l to r where 0 &lt;= l &lt;= r &lt;= n-1</p>
<p><strong>2</strong> Change value of a specified element of the array to a new value x. We need to do arr[i] = x where 0 &lt;= i &lt;= n-1.</p>
<p>A <strong>simple solution</strong> is to run a loop from l to r and calculate the sum of elements in the given range. To update a value, simply do arr[i] = x. The first operation takes O(n) time and the second operation takes O(1) time.</p>
<p><strong>Another solution</strong> is to create another array and store sum from start to i at the ith index in this array. The sum of a given range can now be calculated in O(1) time, but update operation takes O(n) time now. This works well if the number of query operations is large and very few updates.</p>
<p>给定一个数组，我们既想快速的知道任意一段区间的总和是多少，也想经常改变其中任何一个元素的值。</p>
<p>第一种解决办法就是，对每一个l和r，我们计算l和r之间的和，O(n)的复杂度，改变其中任何一个值，O(1)的时间复杂度。</p>
<p>第二种解决办法就是，我们创建好另一个数组，存储从开始到这个索引的元素和是多少，（前缀和，通常前缀和在数组的前面加上一个0，这样所有lr之间的和等于这个_sum数组的 _sum[r] - _sum[l-1]）。这样求l到r之间的和就变成O(1)的时间复杂度了，但是每改变一个值就变成O(n)的了。</p>
<p>What if the number of query and updates are equal? <strong>Can we perform both the operations in O(log n) time once given the array?</strong> We can use a Segment Tree to do both operations in O(Logn) time.</p>
<p><strong>Representation of Segment trees</strong> <strong>1.</strong> Leaf Nodes are the elements of the input array. <strong>2.</strong> Each internal node represents some merging of the leaf nodes. The merging may be different for different problems. For this problem, merging is sum of leaves under a node.</p>
<p>An array representation of tree is used to represent Segment Trees. For each node at index i, the left child is at index 2<em>i+1, right child at 2</em>i+2 and the parent is at <a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/st1.png"><img data-src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/st1.png" alt="st1"></a>.</p>
<img data-src="/2020/07/30/%E7%BA%BF%E6%AE%B5%E6%A0%91/segment-tree1.png" class>
<p><strong>How does above segment tree look in memory?</strong> Like Heap, the segment tree is also represented as an array. The difference here is, it is not a complete binary tree. It is rather a full binary tree (every node has 0 or 2 children) and all levels are filled except possibly the last level. Unlike Heap, the last level may have gaps between nodes. Below are the values in the segment tree array for the above diagram.</p>
<blockquote>
<p><em>Below is memory representation of segment tree for input array {1, 3, 5, 7, 9, 11}</em> <em>st[] = {36, 9, 27, 4, 5, 16, 11, 1, 3, DUMMY, DUMMY, 7, 9, DUMMY, DUMMY}</em></p>
</blockquote>
<p>The dummy values are never accessed and have no use. This is some wastage of space due to simple array representation. We may optimize this wastage using some clever implementations, but code for sum and update becomes more complex.</p>
<p><strong>Construction of Segment Tree from given array</strong> We start with a segment arr[0 . . . n-1]. and every time we divide the current segment into two halves(if it has not yet become a segment of length 1), and then call the same procedure on both halves, and for each such segment, we store the sum in the corresponding node. All levels of the constructed segment tree will be completely filled except the last level. Also, the tree will be a <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvYmluYXJ5LXRyZWUtc2V0LTMtdHlwZXMtb2YtYmluYXJ5LXRyZWUv">Full Binary Tree<i class="fa fa-external-link-alt"></i></span> because we always divide segments in two halves at every level. Since the constructed tree is always a full binary tree with n leaves, there will be n-1 internal nodes. So the total number of nodes will be 2*n – 1. Note that this does not include dummy nodes.</p>
<p><strong>What is the total size of the array representing segment tree?</strong> If n is a power of 2, then there are no dummy nodes. So the size of the segment tree is 2n-1 (n leaf nodes and n-1) internal nodes. If n is not a power of 2, then the size of the tree will be 2*x – 1 where x is the smallest power of 2 greater than n. For example, when n = 10, then size of array representing segment tree is 2*16-1 = 31. An alternate explanation for size is based on heignt. Height of the segment tree will be <a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/st2.png"><img data-src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/st2.png" alt="st2"></a>. Since the tree is represented using array and relation between parent and child indexes must be maintained, size of memory allocated for segment tree will be <a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/st3.png"><img data-src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/st3.png" alt="st3"></a>.</p>
<p><strong>Query for Sum of given range</strong> Once the tree is constructed, how to get the sum using the constructed segment tree. The following is the algorithm to get the sum of elements.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(node, l, r)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> the range of the node is within l <span class="keyword">and</span> r</span><br><span class="line">        <span class="keyword">return</span> value in the node</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> the range of the node is completely outside l <span class="keyword">and</span> r</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> getSum(node<span class="number">&#x27;</span>s left child, l, r) + </span><br><span class="line">           getSum(node<span class="number">&#x27;</span>s right child, l, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Update a value</strong> Like tree construction and query operations, the update can also be done recursively. We are given an index which needs to be updated. Let <em>diff</em> be the value to be added. We start from the root of the segment tree and add <em>diff</em> to all nodes which have given index in their range. If a node doesn’t have a given index in its range, we don’t make any changes to that node.</p>
<p><strong>Implementation:</strong> Following is the implementation of segment tree. The program implements construction of segment tree for any given array. It also implements query and update operations.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python3 program to show segment tree operations like </span></span><br><span class="line"><span class="comment"># construction, query and update </span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil, log2; </span><br><span class="line"></span><br><span class="line"><span class="comment"># A utility function to get the </span></span><br><span class="line"><span class="comment"># middle index from corner indexes. </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMid</span>(<span class="params">s, e</span>) :</span> </span><br><span class="line">   <span class="keyword">return</span> s + (e -s) // <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; A recursive function to get the sum of values </span></span><br><span class="line"><span class="string">   in the given range of the array. The following </span></span><br><span class="line"><span class="string">   are parameters for this function. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  st --&gt; Pointer to segment tree </span></span><br><span class="line"><span class="string">    si --&gt; Index of current node in the segment tree. </span></span><br><span class="line"><span class="string">     Initially 0 is passed as root is always at index 0 </span></span><br><span class="line"><span class="string">   ss &amp; se --&gt; Starting and ending indexes of the segment </span></span><br><span class="line"><span class="string">                represented by current node, i.e., st[si] </span></span><br><span class="line"><span class="string">    qs &amp; qe --&gt; Starting and ending indexes of query range &quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSumUtil</span>(<span class="params">st, ss, se, qs, qe, si</span>) :</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># If segment of this node is a part of given range, </span></span><br><span class="line"> <span class="comment"># then return the sum of the segment </span></span><br><span class="line">    <span class="keyword">if</span> (qs &lt;= ss <span class="keyword">and</span> qe &gt;= se) : </span><br><span class="line">     <span class="keyword">return</span> st[si]; </span><br><span class="line"></span><br><span class="line">    <span class="comment"># If segment of this node is </span></span><br><span class="line">    <span class="comment"># outside the given range </span></span><br><span class="line">   <span class="keyword">if</span> (se &lt; qs <span class="keyword">or</span> ss &gt; qe) : </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> <span class="comment"># If a part of this segment overlaps </span></span><br><span class="line">    <span class="comment"># with the given range </span></span><br><span class="line">  mid = getMid(ss, se); </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> getSumUtil(st, ss, mid, qs, qe, <span class="number">2</span> * si + <span class="number">1</span>) + \ </span><br><span class="line">      getSumUtil(st, mid + <span class="number">1</span>, se, qs, qe, <span class="number">2</span> * si + <span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; A recursive function to update the nodes </span></span><br><span class="line"><span class="string">which have the given index in their range. </span></span><br><span class="line"><span class="string">The following are parameters st, si, ss and se </span></span><br><span class="line"><span class="string">are same as getSumUtil() </span></span><br><span class="line"><span class="string">i --&gt; index of the element to be updated. </span></span><br><span class="line"><span class="string">    This index is in the input array. </span></span><br><span class="line"><span class="string">diff --&gt; Value to be added to all nodes </span></span><br><span class="line"><span class="string">which have i in range &quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateValueUtil</span>(<span class="params">st, ss, se, i, diff, si</span>) :</span> </span><br><span class="line"></span><br><span class="line"> <span class="comment"># Base Case: If the input index lies </span></span><br><span class="line">    <span class="comment"># outside the range of this segment </span></span><br><span class="line"> <span class="keyword">if</span> (i &lt; ss <span class="keyword">or</span> i &gt; se) : </span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">   <span class="comment"># If the input index is in range of this node, </span></span><br><span class="line">  <span class="comment"># then update the value of the node and its children </span></span><br><span class="line">    st[si] = st[si] + diff; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (se != ss) : </span><br><span class="line"> </span><br><span class="line">      mid = getMid(ss, se); </span><br><span class="line">        updateValueUtil(st, ss, mid, i, </span><br><span class="line">                      diff, <span class="number">2</span> * si + <span class="number">1</span>); </span><br><span class="line">       updateValueUtil(st, mid + <span class="number">1</span>, se, i, </span><br><span class="line">                      diff, <span class="number">2</span> * si + <span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment"># The function to update a value in input array </span></span><br><span class="line"><span class="comment"># and segment tree. It uses updateValueUtil() </span></span><br><span class="line"><span class="comment"># to update the value in segment tree </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateValue</span>(<span class="params">arr, st, n, i, new_val</span>) :</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check for erroneous input index </span></span><br><span class="line">   <span class="keyword">if</span> (i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt; n - <span class="number">1</span>) : </span><br><span class="line">        </span><br><span class="line">      print(<span class="string">&quot;Invalid Input&quot;</span>, end = <span class="string">&quot;&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">   <span class="comment"># Get the difference between </span></span><br><span class="line">    <span class="comment"># new value and old value </span></span><br><span class="line">   diff = new_val - arr[i]; </span><br><span class="line"></span><br><span class="line">   <span class="comment"># Update the value in array </span></span><br><span class="line"> arr[i] = new_val; </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Update the values of nodes in segment tree </span></span><br><span class="line">    updateValueUtil(st, <span class="number">0</span>, n - <span class="number">1</span>, i, diff, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment"># Return sum of elements in range from </span></span><br><span class="line"><span class="comment"># index qs (quey start) to qe (query end). </span></span><br><span class="line"><span class="comment"># It mainly uses getSumUtil() </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSum</span>(<span class="params">st, n, qs, qe</span>) :</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Check for erroneous input values </span></span><br><span class="line">  <span class="keyword">if</span> (qs &lt; <span class="number">0</span> <span class="keyword">or</span> qe &gt; n - <span class="number">1</span> <span class="keyword">or</span> qs &gt; qe) : </span><br><span class="line"></span><br><span class="line">     print(<span class="string">&quot;Invalid Input&quot;</span>, end = <span class="string">&quot;&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> getSumUtil(st, <span class="number">0</span>, n - <span class="number">1</span>, qs, qe, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment"># A recursive function that constructs </span></span><br><span class="line"><span class="comment"># Segment Tree for array[ss..se]. </span></span><br><span class="line"><span class="comment"># si is index of current node in segment tree st </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructSTUtil</span>(<span class="params">arr, ss, se, st, si</span>) :</span> </span><br><span class="line"></span><br><span class="line">   <span class="comment"># If there is one element in array, </span></span><br><span class="line"> <span class="comment"># store it in current node of </span></span><br><span class="line">   <span class="comment"># segment tree and return </span></span><br><span class="line">   <span class="keyword">if</span> (ss == se) : </span><br><span class="line"> </span><br><span class="line">      st[si] = arr[ss]; </span><br><span class="line">        <span class="keyword">return</span> arr[ss]; </span><br><span class="line"> </span><br><span class="line">  <span class="comment"># If there are more than one elements, </span></span><br><span class="line">  <span class="comment"># then recur for left and right subtrees </span></span><br><span class="line">    <span class="comment"># and store the sum of values in this node </span></span><br><span class="line">  mid = getMid(ss, se); </span><br><span class="line">    </span><br><span class="line">  st[si] = constructSTUtil(arr, ss, mid, st, si * <span class="number">2</span> + <span class="number">1</span>) +\ </span><br><span class="line">            constructSTUtil(arr, mid + <span class="number">1</span>, se, st, si * <span class="number">2</span> + <span class="number">2</span>); </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> st[si]; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; Function to construct segment tree </span></span><br><span class="line"><span class="string">from given array. This function allocates memory </span></span><br><span class="line"><span class="string">for segment tree and calls constructSTUtil() to </span></span><br><span class="line"><span class="string">fill the allocated memory &quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constructST</span>(<span class="params">arr, n</span>) :</span> </span><br><span class="line"></span><br><span class="line"> <span class="comment"># Allocate memory for the segment tree </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Height of segment tree </span></span><br><span class="line">    x = (int)(ceil(log2(n))); </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Maximum size of segment tree </span></span><br><span class="line">  max_size = <span class="number">2</span> * (int)(<span class="number">2</span>**x) - <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Allocate memory </span></span><br><span class="line">   st = [<span class="number">0</span>] * max_size; </span><br><span class="line"></span><br><span class="line">   <span class="comment"># Fill the allocated memory st </span></span><br><span class="line">  constructSTUtil(arr, <span class="number">0</span>, n - <span class="number">1</span>, st, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"> <span class="comment"># Return the constructed segment tree </span></span><br><span class="line">   <span class="keyword">return</span> st; </span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver Code </span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span> : </span><br><span class="line"></span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]; </span><br><span class="line">   n = len(arr); </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Build segment tree from given array </span></span><br><span class="line">   st = constructST(arr, n); </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Print sum of values in array from index 1 to 3 </span></span><br><span class="line">    print(<span class="string">&quot;Sum of values in given range = &quot;</span>, </span><br><span class="line">                   getSum(st, n, <span class="number">1</span>, <span class="number">3</span>)); </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Update: set arr[1] = 10 and update </span></span><br><span class="line">    <span class="comment"># corresponding segment tree nodes </span></span><br><span class="line">  updateValue(arr, st, n, <span class="number">1</span>, <span class="number">10</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find sum after the value is updated </span></span><br><span class="line">   print(<span class="string">&quot;Updated sum of values in given range = &quot;</span>, </span><br><span class="line">                   getSum(st, n, <span class="number">1</span>, <span class="number">3</span>), end = <span class="string">&quot;&quot;</span>); </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sum of values in given range &#x3D; 15</span><br><span class="line">Updated sum of values in given range &#x3D; 22</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity:</strong> Time Complexity for tree construction is O(n). There are total 2n-1 nodes, and value of every node is calculated only once in tree construction.</p>
<p>Time complexity to query is O(Logn). To query a sum, we process at most four nodes at every level and number of levels is O(Logn).</p>
<p>The time complexity of update is also O(Logn). To update a leaf value, we process one node at every level and number of levels is O(Logn).</p>
<h2 id="示例题目">示例题目</h2>
<ol type="1">
<li><h3 id="spoj-gss1">SPOJ-GSS1</h3>
<p>You are given a sequence A[1], A[2], ..., A[N] . ( |A[i]| ≤ 15007 , 1 ≤ N ≤ 50000 ). A query is defined as follows: Query(x,y) = Max { a[i]+a[i+1]+...+a[j] ; x ≤ i ≤ j ≤ y }. Given M queries, your program must output the results of these queries.</p>
<h3 id="input">Input</h3>
<ul>
<li>The first line of the input file contains the integer N.</li>
<li>In the second line, N numbers follow.</li>
<li>The third line contains the integer M.</li>
<li>M lines follow, where line i contains 2 numbers xi and yi.</li>
</ul>
<h3 id="output">Output</h3>
<p>Your program should output the results of the M queries, one query per line.</p>
<h3 id="example">Example</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">3 </span><br><span class="line">-1 2 3</span><br><span class="line">1</span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li>
</ol>
<p>大致翻译：给定一段长度为n的序列a1, a2, ..., an （a有正有负），每次询问[L, R] (即aL ~ aR)范围内的最大子段和，并涉及单点修改操作。</p>
<p>线段树：维护区间最大子段和。</p>
<p>这里不能用传统的线段树了，我们维护的值要更多。</p>
<ol type="1">
<li><p>定义：</p>
<p>线段树一共要维护4个值，如下：（每个值的含义都是相对于该结点对应区间[l, r]而言）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;       <span class="comment">//[l,r]区间之和</span></span><br><span class="line">    <span class="keyword">int</span> max_sum;   <span class="comment">//[l,r]内的最大子段和</span></span><br><span class="line">    <span class="keyword">int</span> max_pre;   <span class="comment">//[l,r]内的最大前缀和</span></span><br><span class="line">    <span class="keyword">int</span> max_post;  <span class="comment">//[l,r]内的最大后缀和</span></span><br><span class="line">&#125;t[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>向上传递</li>
</ol>
<p>我们采用分治归并的思路，我们知道在l=r时这四个值都是确定的，都等于al。那么通过左右两边的四个值如何求出合并后的值呢。这里我觉得这段话讲的很清楚。</p>
<p>我们定义一个操作get(a, l, r)表示查询a序列[l, r]区间内的最大子段和。如何分治实现这个操作呢？对于一个区间l, r，我们取m = (l + r)/2， 对区间[l,m] 和 [m+1, r]分治求解。当递归逐层深入直到区间长度缩小为1的时候，递归「开始回升」。这个时候我们考虑如何通过[l, m]区间的信息和[m+1, r]区间的信息合并成区间[l, r]的信息。最关键的两个问题是：</p>
<ul>
<li>我们要维护区间的哪些信息呢？</li>
<li>我们如何合并这些信息？</li>
</ul>
<p>对于一个区间[l, r]，我们可以维护四个量：</p>
<ul>
<li>lSum表示[l, r]内以l为左端点的最大子段和</li>
<li>rSum表示[l, r]内以r为右端点的最大字段和</li>
<li>mSum表示[l, r]内的最大子段和</li>
<li>iSum表示[l, r]的区间和</li>
</ul>
<p>以下简称[l, m]为[l, r]的「左子区间」，[m+1, r]为[l, r]的右子区间。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到[l,r]的信息）？对于长度为1的区间[i,i]，四个量的值都和ai相等。对于长度大于1的区间：</p>
<p>首先最好维护的是iSum，区间[l, r]的iSum就等于「左子区间」的iSum加上「右子区间」的iSum。</p>
<p>对于[l, r]的lSum，存在两种可能，它要么等于「左子区间」的lSum，要么等于「左子区间」的iSum加上「右子区间」的lSum，两者取大。</p>
<p>对于[l, r]的rSum，同理，它要么等于「右子区间」的rSum，要么等于「右子区间」的iSum加上「左子区间」的rSum，两者取大。</p>
<p>当计算好上面的三个量之后，就很好计算[l, r]的mSum了。我们可以考虑[l, r]的mSum对应的区间是否跨越m--它可能不跨越m，也就是说[l, r]的mSum可能是「左子区间」的mSum和「右子区间」的mSum中的一个；它可能跨越m，可能是「左子区间」的rSum和「右子区间」的lSum求和。三者取大。</p>
<p>我们把这个过程叫做向上传递，英文叫做pushup。</p>
<p>如果我们把 [0,n−1] 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一颗真正的树之后，我们就可以在 O(logn) 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 O(logn) 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是线段树。</p></li>
<li><p>leetcode，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS8=">53. 最大子序和<i class="fa fa-external-link-alt"></i></span>，可用dp也可用线段树求解。与上一题一样，只不过上一题有多个query，适合把线段树存下来。</p>
<p>示例解法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线段树</span></span><br><span class="line"><span class="comment"># 我们定义一个操作get(a, l, r)表示查询a序列[l, r]区间内的最大子段和，</span></span><br><span class="line"><span class="comment"># 那么最终我们要求的答案就是get(arr, 0, n-1)。如何分治实现这个操作呢？</span></span><br><span class="line"><span class="comment"># 对于一个区间l, r，我们取m = (l + r)/2， 对区间[l,m] 和 [m+1, r]分治求解。</span></span><br><span class="line"><span class="comment"># 当递归逐层深入直到区间长度缩小为1的时候，递归「开始回升」。</span></span><br><span class="line"><span class="comment"># 这个时候我们考虑如何通过[l, m]区间的信息和[m+1, r]区间的信息合并成区间[l, r]的信息。</span></span><br><span class="line"><span class="comment"># 最关键的两个问题是：</span></span><br><span class="line"><span class="comment"># 我们要维护区间的哪些信息呢？</span></span><br><span class="line"><span class="comment"># 我们如何合并这些信息？</span></span><br><span class="line"><span class="comment"># 对于一个区间[l, r]，我们可以维护四个量：</span></span><br><span class="line"><span class="comment"># lSum表示[l, r]内以l为左端点的最大子段和</span></span><br><span class="line"><span class="comment"># rSum表示[l, r]内以r为右端点的最大字段和</span></span><br><span class="line"><span class="comment"># mSum表示[l, r]内的最大子段和</span></span><br><span class="line"><span class="comment"># iSum表示[l, r]的区间和</span></span><br><span class="line"><span class="comment"># 以下简称[l, m]为[l, r]的「左子区间」，[m+1, r]为[l, r]的右子区间。</span></span><br><span class="line"><span class="comment"># 我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到[l,r]的信息）？</span></span><br><span class="line"><span class="comment"># 对于长度为1的区间[start,start]，四个量的值都和ai相等。对于长度大于1的区间：</span></span><br><span class="line"><span class="comment"># 首先最好维护的是iSum，区间[l, r]的iSum就等于「左子区间」的iSum加上「右子区间」的iSum。</span></span><br><span class="line"><span class="comment"># 对于[l, r]的lSum，存在两种可能，它要么等于「左子区间」的lSum，</span></span><br><span class="line"><span class="comment"># 要么等于「左子区间」的iSum加上「右子区间」的lSum，两者取大。</span></span><br><span class="line"><span class="comment"># 对于[l, r]的rSum，同理，它要么等于「右子区间」的rSum，</span></span><br><span class="line"><span class="comment"># 要么等于「右子区间」的iSum加上「左子区间」的rSum，两者取大</span></span><br><span class="line"><span class="comment"># 当计算好上面的三个量之后，就很好计算[l, r]的mSum了。</span></span><br><span class="line"><span class="comment"># 我们可以考虑[l, r]的mSum对应的区间是否跨越m--它可能不跨越m，</span></span><br><span class="line"><span class="comment"># 也就是说[l, r]的mSum可能是「左子区间」的mSum和「右子区间」</span></span><br><span class="line"><span class="comment"># 的mSum中的一个；</span></span><br><span class="line"><span class="comment"># 它可能跨越m，可能是「左子区间」的rSum和「右子区间」的lSum求和。三者取大。</span></span><br><span class="line"><span class="comment"># 时间复杂度，相当于遍历一个二叉树的所有结点，结点最多为2*n个，所以时间为O(n)</span></span><br><span class="line"><span class="comment"># 空间复杂度：递归：O(logn)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.get(nums, l, r)[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, nums, l, r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> [nums[l]] * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        lSum1, rSum1, mSum1, iSum1 = self.get(nums, l, mid)</span><br><span class="line">        lSum2, rSum2, mSum2, iSum2 = self.get(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">        iSum = iSum1 + iSum2</span><br><span class="line">        lSum = max(lSum1, iSum1 + lSum2)</span><br><span class="line">        rSum = max(rSum2, iSum2 + rSum1)</span><br><span class="line">        mSum = max(mSum1, mSum2, rSum1 + lSum2)</span><br><span class="line">        <span class="keyword">return</span> lSum, rSum, mSum, iSum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储一颗线段树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        res = self.build(nums, l, r, memo)[<span class="number">2</span>]</span><br><span class="line">        print(memo)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, nums, l, r, memo</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            memo[l, r] = [nums[l]] * <span class="number">4</span></span><br><span class="line">            <span class="keyword">return</span> [nums[l]] * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        lSum1, rSum1, mSum1, iSum1 = self.build(nums, l, mid, memo)</span><br><span class="line">        lSum2, rSum2, mSum2, iSum2 = self.build(nums, mid + <span class="number">1</span>, r, memo)</span><br><span class="line">        iSum = iSum1 + iSum2</span><br><span class="line">        lSum = max(lSum1, iSum1 + lSum2)</span><br><span class="line">        rSum = max(rSum2, iSum2 + rSum1)</span><br><span class="line">        mSum = max(mSum1, mSum2, rSum1 + lSum2)</span><br><span class="line">        memo[l, r] = [lSum, rSum, mSum, iSum]</span><br><span class="line">        <span class="keyword">return</span> lSum, rSum, mSum, iSum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># f(i) s[:i]的最大子序和，且一定包括i</span></span><br><span class="line"><span class="comment"># f(i) = max(f(i-1), 0) + a[i]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        pre, cur = float(<span class="string">&#x27;-inf&#x27;</span>), float(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            pre = max(pre + n, n)</span><br><span class="line">            cur = max(cur, pre)</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，</span></span><br><span class="line"><span class="comment"># 运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。</span></span><br><span class="line"><span class="comment"># 那么这种方法存在的意义是什么呢？</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 对于这道题而言，确实是如此的。但是仔细观察「方法二」，它不仅可以解决区间 [0,n−1]，</span></span><br><span class="line"><span class="comment"># 还可以用于解决任意的子区间 [l,r] 的问题。</span></span><br><span class="line"><span class="comment"># 如果我们把 [0,n−1] 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，</span></span><br><span class="line"><span class="comment"># 即建成一颗真正的树之后，我们就可以在 O(logn) 的时间内求到任意区间内的答案，</span></span><br><span class="line"><span class="comment"># 我们甚至可以修改序列中的值，做一些简单的维护，</span></span><br><span class="line"><span class="comment"># 之后仍然可以在 O(logn) 的时间内求到任意区间内的答案，</span></span><br><span class="line"><span class="comment"># 对于大规模查询的情况下，这种方法的优势便体现了出来。</span></span><br><span class="line"><span class="comment"># 这棵树就是上文提及的一种神奇的数据结构——线段树。</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>
